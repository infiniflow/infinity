#
# Autogenerated by Thrift Compiler (0.17.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import shared.ttypes

from thrift.transport import TTransport
all_structs = []


class Operation(object):
    """
    You can define enums, which are just 32 bit integers. Values are optional
    and start at 1 if not supplied, C style again.

    """
    ADD = 1
    SUBTRACT = 2
    MULTIPLY = 3
    DIVIDE = 4

    _VALUES_TO_NAMES = {
        1: "ADD",
        2: "SUBTRACT",
        3: "MULTIPLY",
        4: "DIVIDE",
    }

    _NAMES_TO_VALUES = {
        "ADD": 1,
        "SUBTRACT": 2,
        "MULTIPLY": 3,
        "DIVIDE": 4,
    }


class LiteralType(object):
    kBoolean = 0
    kDouble = 1
    kString = 2
    kInt64 = 3
    kNull = 4
    kIntegerArray = 5
    kDoubleArray = 6

    _VALUES_TO_NAMES = {
        0: "kBoolean",
        1: "kDouble",
        2: "kString",
        3: "kInt64",
        4: "kNull",
        5: "kIntegerArray",
        6: "kDoubleArray",
    }

    _NAMES_TO_VALUES = {
        "kBoolean": 0,
        "kDouble": 1,
        "kString": 2,
        "kInt64": 3,
        "kNull": 4,
        "kIntegerArray": 5,
        "kDoubleArray": 6,
    }


class Work(object):
    """
    Structs are the basic complex data structures. They are comprised of fields
    which each have an integer identifier, a type, a symbolic name, and an
    optional default value.

    Fields can be declared "optional", which ensures they will not be included
    in the serialized output if they aren't set.  Note that this requires some
    manual management in some languages.

    Attributes:
     - num1
     - num2
     - op
     - comment

    """


    def __init__(self, num1=0, num2=None, op=None, comment=None,):
        self.num1 = num1
        self.num2 = num2
        self.op = op
        self.comment = comment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num2 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.comment = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Work')
        if self.num1 is not None:
            oprot.writeFieldBegin('num1', TType.I32, 1)
            oprot.writeI32(self.num1)
            oprot.writeFieldEnd()
        if self.num2 is not None:
            oprot.writeFieldBegin('num2', TType.I32, 2)
            oprot.writeI32(self.num2)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 3)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 4)
            oprot.writeString(self.comment.encode('utf-8') if sys.version_info[0] == 2 else self.comment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InvalidOperation(TException):
    """
    Structs can also be exceptions, if they are nasty.

    Attributes:
     - whatOp
     - why

    """


    def __init__(self, whatOp=None, why=None,):
        super(InvalidOperation, self).__setattr__('whatOp', whatOp)
        super(InvalidOperation, self).__setattr__('why', why)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.whatOp, self.why, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        whatOp = None
        why = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    whatOp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    why = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            whatOp=whatOp,
            why=why,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InvalidOperation')
        if self.whatOp is not None:
            oprot.writeFieldBegin('whatOp', TType.I32, 1)
            oprot.writeI32(self.whatOp)
            oprot.writeFieldEnd()
        if self.why is not None:
            oprot.writeFieldBegin('why', TType.STRING, 2)
            oprot.writeString(self.why.encode('utf-8') if sys.version_info[0] == 2 else self.why)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Option(object):
    """
    That just about covers the basics. Take a look in the test/ folder for more
    detailed examples. After you run this file, your generated code shows up
    in folders with names gen-<language>. The generated code isn't too scary
    to look at. It even has pretty indentation.

    """


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Option')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CreateDatabaseRequest(object):
    """
    Attributes:
     - db_name
     - session_id
     - option

    """


    def __init__(self, db_name=None, session_id=None, option=None,):
        self.db_name = db_name
        self.session_id = session_id
        self.option = option

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.session_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.option = Option()
                    self.option.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CreateDatabaseRequest')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.session_id is not None:
            oprot.writeFieldBegin('session_id', TType.I64, 2)
            oprot.writeI64(self.session_id)
            oprot.writeFieldEnd()
        if self.option is not None:
            oprot.writeFieldBegin('option', TType.STRUCT, 3)
            self.option.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommonResponse(object):
    """
    Attributes:
     - success
     - error_msg
     - session_id

    """


    def __init__(self, success=None, error_msg=None, session_id=None,):
        self.success = success
        self.error_msg = error_msg
        self.session_id = session_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.error_msg = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.session_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommonResponse')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 1)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.error_msg is not None:
            oprot.writeFieldBegin('error_msg', TType.STRING, 2)
            oprot.writeString(self.error_msg.encode('utf-8') if sys.version_info[0] == 2 else self.error_msg)
            oprot.writeFieldEnd()
        if self.session_id is not None:
            oprot.writeFieldBegin('session_id', TType.I64, 3)
            oprot.writeI64(self.session_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class CommonRequest(object):
    """
    Attributes:
     - session_id

    """


    def __init__(self, session_id=None,):
        self.session_id = session_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.session_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CommonRequest')
        if self.session_id is not None:
            oprot.writeFieldBegin('session_id', TType.I64, 1)
            oprot.writeI64(self.session_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParsedExprType(object):
    """
    Attributes:
     - constant_expr
     - column_expr
     - function_expr

    """


    def __init__(self, constant_expr=None, column_expr=None, function_expr=None,):
        self.constant_expr = constant_expr
        self.column_expr = column_expr
        self.function_expr = function_expr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.constant_expr = ConstantExpr()
                    self.constant_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.column_expr = ColumnExpr()
                    self.column_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.function_expr = FunctionExpr()
                    self.function_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParsedExprType')
        if self.constant_expr is not None:
            oprot.writeFieldBegin('constant_expr', TType.STRUCT, 1)
            self.constant_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.column_expr is not None:
            oprot.writeFieldBegin('column_expr', TType.STRUCT, 2)
            self.column_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.function_expr is not None:
            oprot.writeFieldBegin('function_expr', TType.STRUCT, 3)
            self.function_expr.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ParsedExpr(object):
    """
    Attributes:
     - type
     - alias

    """


    def __init__(self, type=None, alias=None,):
        self.type = type
        self.alias = alias

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.type = ParsedExprType()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.alias = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ParsedExpr')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRUCT, 1)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        if self.alias is not None:
            oprot.writeFieldBegin('alias', TType.STRING, 2)
            oprot.writeString(self.alias.encode('utf-8') if sys.version_info[0] == 2 else self.alias)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ConstantExpr(object):
    """
    Attributes:
     - literal_type
     - bool_value
     - i64_value
     - f64_value
     - str_value

    """


    def __init__(self, literal_type=None, bool_value=None, i64_value=None, f64_value=None, str_value=None,):
        self.literal_type = literal_type
        self.bool_value = bool_value
        self.i64_value = i64_value
        self.f64_value = f64_value
        self.str_value = str_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.literal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.bool_value = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.i64_value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.f64_value = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.str_value = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ConstantExpr')
        if self.literal_type is not None:
            oprot.writeFieldBegin('literal_type', TType.I32, 1)
            oprot.writeI32(self.literal_type)
            oprot.writeFieldEnd()
        if self.bool_value is not None:
            oprot.writeFieldBegin('bool_value', TType.BOOL, 2)
            oprot.writeBool(self.bool_value)
            oprot.writeFieldEnd()
        if self.i64_value is not None:
            oprot.writeFieldBegin('i64_value', TType.I64, 3)
            oprot.writeI64(self.i64_value)
            oprot.writeFieldEnd()
        if self.f64_value is not None:
            oprot.writeFieldBegin('f64_value', TType.DOUBLE, 4)
            oprot.writeDouble(self.f64_value)
            oprot.writeFieldEnd()
        if self.str_value is not None:
            oprot.writeFieldBegin('str_value', TType.STRING, 5)
            oprot.writeString(self.str_value.encode('utf-8') if sys.version_info[0] == 2 else self.str_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ColumnExpr(object):
    """
    Attributes:
     - column_name
     - star

    """


    def __init__(self, column_name=None, star=None,):
        self.column_name = column_name
        self.star = star

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.column_name = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.column_name.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.star = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ColumnExpr')
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.column_name))
            for iter6 in self.column_name:
                oprot.writeString(iter6.encode('utf-8') if sys.version_info[0] == 2 else iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.star is not None:
            oprot.writeFieldBegin('star', TType.BOOL, 2)
            oprot.writeBool(self.star)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class FunctionExpr(object):
    """
    Attributes:
     - function_name
     - arguments

    """


    def __init__(self, function_name=None, arguments=None,):
        self.function_name = function_name
        self.arguments = arguments

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.function_name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.arguments = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = ParsedExpr()
                        _elem12.read(iprot)
                        self.arguments.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FunctionExpr')
        if self.function_name is not None:
            oprot.writeFieldBegin('function_name', TType.STRING, 1)
            oprot.writeString(self.function_name.encode('utf-8') if sys.version_info[0] == 2 else self.function_name)
            oprot.writeFieldEnd()
        if self.arguments is not None:
            oprot.writeFieldBegin('arguments', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.arguments))
            for iter13 in self.arguments:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Work)
Work.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num1', None, 0, ),  # 1
    (2, TType.I32, 'num2', None, None, ),  # 2
    (3, TType.I32, 'op', None, None, ),  # 3
    (4, TType.STRING, 'comment', 'UTF8', None, ),  # 4
)
all_structs.append(InvalidOperation)
InvalidOperation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'whatOp', None, None, ),  # 1
    (2, TType.STRING, 'why', 'UTF8', None, ),  # 2
)
all_structs.append(Option)
Option.thrift_spec = (
)
all_structs.append(CreateDatabaseRequest)
CreateDatabaseRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    (2, TType.I64, 'session_id', None, None, ),  # 2
    (3, TType.STRUCT, 'option', [Option, None], None, ),  # 3
)
all_structs.append(CommonResponse)
CommonResponse.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'success', None, None, ),  # 1
    (2, TType.STRING, 'error_msg', 'UTF8', None, ),  # 2
    (3, TType.I64, 'session_id', None, None, ),  # 3
)
all_structs.append(CommonRequest)
CommonRequest.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'session_id', None, None, ),  # 1
)
all_structs.append(ParsedExprType)
ParsedExprType.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'constant_expr', [ConstantExpr, None], None, ),  # 1
    (2, TType.STRUCT, 'column_expr', [ColumnExpr, None], None, ),  # 2
    (3, TType.STRUCT, 'function_expr', [FunctionExpr, None], None, ),  # 3
)
all_structs.append(ParsedExpr)
ParsedExpr.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'type', [ParsedExprType, None], None, ),  # 1
    (2, TType.STRING, 'alias', 'UTF8', None, ),  # 2
)
all_structs.append(ConstantExpr)
ConstantExpr.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'literal_type', None, None, ),  # 1
    (2, TType.BOOL, 'bool_value', None, None, ),  # 2
    (3, TType.I64, 'i64_value', None, None, ),  # 3
    (4, TType.DOUBLE, 'f64_value', None, None, ),  # 4
    (5, TType.STRING, 'str_value', 'UTF8', None, ),  # 5
)
all_structs.append(ColumnExpr)
ColumnExpr.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'column_name', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.BOOL, 'star', None, None, ),  # 2
)
all_structs.append(FunctionExpr)
FunctionExpr.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'function_name', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'arguments', (TType.STRUCT, [ParsedExpr, None], False), None, ),  # 2
)
fix_spec(all_structs)
del all_structs
