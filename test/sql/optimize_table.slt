 # name: test/sql/optimize_table.slt
# description: Test table optimization statements and operations
# group: [optimization]

# Test basic table creation and optimization
statement ok
DROP TABLE IF EXISTS optimize_test_table;

statement ok
CREATE TABLE optimize_test_table (
    id INTEGER PRIMARY KEY,
    name VARCHAR(50),
    value FLOAT,
    created_at TIMESTAMP
);

statement ok
INSERT INTO optimize_test_table VALUES 
    (1, 'test1', 10.5, '2023-01-01 10:00:00'),
    (2, 'test2', 20.3, '2023-01-02 11:00:00'),
    (3, 'test3', 15.7, '2023-01-03 12:00:00');

# Test basic table optimization without specific parameters
statement ok
OPTIMIZE optimize_test_table;

# Verify data integrity after optimization
query I
SELECT COUNT(*) FROM optimize_test_table;
----
3

query T
SELECT id, name, value FROM optimize_test_table ORDER BY id;
----
1 test1 10.5
2 test2 20.3
3 test3 15.7

# Test optimization on table with indexes
statement ok
CREATE INDEX idx_name ON optimize_test_table (name);

statement ok
CREATE INDEX idx_value ON optimize_test_table (value);

# Test optimization on table with indexes (will optimize all indexes)
statement ok
OPTIMIZE optimize_test_table;

# Test optimization on table with embedding column
statement ok
DROP TABLE IF EXISTS optimize_embedding_table;

statement ok
CREATE TABLE optimize_embedding_table (
    id INTEGER PRIMARY KEY,
    embedding_col EMBEDDING(FLOAT, 4)
);

statement ok
INSERT INTO optimize_embedding_table VALUES 
    (1, [0.1, 0.2, 0.3, 0.4]),
    (2, [0.5, 0.6, 0.7, 0.8]),
    (3, [0.9, 1.0, 1.1, 1.2]);

statement ok
CREATE INDEX idx_embedding ON optimize_embedding_table (embedding_col) USING Hnsw WITH (M = 16, ef_construction = 200, metric = l2);

# Test optimization on embedding index
statement ok
OPTIMIZE idx_embedding ON optimize_embedding_table WITH (compress_to_lvq);

# Test optimization with different compression options
statement ok
OPTIMIZE idx_embedding ON optimize_embedding_table WITH (lvq_avg);

# Test optimization on sparse table
statement ok
DROP TABLE IF EXISTS optimize_sparse_table;

statement ok
CREATE TABLE optimize_sparse_table (
    id INTEGER PRIMARY KEY,
    sparse_col SPARSE(FLOAT)
);

statement ok
INSERT INTO optimize_sparse_table VALUES 
    (1, [0:1.0, 10:2.0, 50:3.0]),
    (2, [5:1.5, 15:2.5, 55:3.5]),
    (3, [10:2.0, 20:3.0, 60:4.0]);

statement ok
CREATE INDEX idx_sparse ON optimize_sparse_table (sparse_col) USING Sparse WITH (metric = ip);

# Test optimization on sparse index
statement ok
OPTIMIZE idx_sparse ON optimize_sparse_table WITH (topk = 3);

statement ok
OPTIMIZE idx_sparse ON optimize_sparse_table WITH (bp_reorder, topk = 3);

# Test optimization on large table
statement ok
DROP TABLE IF EXISTS optimize_large_table;

statement ok
CREATE TABLE optimize_large_table (
    id INTEGER PRIMARY KEY,
    data VARCHAR(100),
    timestamp TIMESTAMP
);

# Insert more data for large table optimization test
statement ok
INSERT INTO optimize_large_table SELECT 
    generate_series(1, 1000) as id,
    'data_' || generate_series(1, 1000) as data,
    '2023-01-01 00:00:00'::TIMESTAMP + (generate_series(1, 1000) * INTERVAL '1 hour') as timestamp;

# Test optimization on large table
statement ok
OPTIMIZE optimize_large_table;

# Verify large table data integrity
query I
SELECT COUNT(*) FROM optimize_large_table;
----
1000

query I
SELECT MIN(id), MAX(id) FROM optimize_large_table;
----
1 1000

# Test optimization with invalid table (should error)
statement error
OPTIMIZE non_existent_table;

# Test optimization on table with constraints
statement ok
DROP TABLE IF EXISTS optimize_constraint_table;

statement ok
CREATE TABLE optimize_constraint_table (
    id INTEGER PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    value FLOAT CHECK (value > 0),
    unique_col INTEGER UNIQUE
);

statement ok
INSERT INTO optimize_constraint_table VALUES 
    (1, 'constraint1', 10.5, 100),
    (2, 'constraint2', 20.3, 200),
    (3, 'constraint3', 15.7, 300);

# Test optimization on table with constraints
statement ok
OPTIMIZE optimize_constraint_table;

# Verify constraint table data integrity
query I
SELECT COUNT(*) FROM optimize_constraint_table;
----
3

# Test optimization on partitioned table (if supported)
statement ok
DROP TABLE IF EXISTS optimize_partitioned_table;

statement ok
CREATE TABLE optimize_partitioned_table (
    id INTEGER,
    name VARCHAR(50),
    partition_date DATE
) PARTITION BY RANGE (partition_date);

statement ok
CREATE TABLE optimize_partitioned_table_2023 PARTITION OF optimize_partitioned_table
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

statement ok
INSERT INTO optimize_partitioned_table VALUES 
    (1, 'partition1', '2023-06-01'),
    (2, 'partition2', '2023-07-01'),
    (3, 'partition3', '2023-08-01');

# Test optimization on partitioned table
statement ok
OPTIMIZE optimize_partitioned_table;

# Verify partitioned table data integrity
query I
SELECT COUNT(*) FROM optimize_partitioned_table;
----
3

# Clean up all test tables
statement ok
DROP TABLE IF EXISTS optimize_test_table;

statement ok
DROP TABLE IF EXISTS optimize_embedding_table;

statement ok
DROP TABLE IF EXISTS optimize_sparse_table;

statement ok
DROP TABLE IF EXISTS optimize_large_table;

statement ok
DROP TABLE IF EXISTS optimize_constraint_table;

statement ok
DROP TABLE IF EXISTS optimize_partitioned_table;