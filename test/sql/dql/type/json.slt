# ============================================================================
# Infinity JSON Type Test Suite
# ============================================================================
# - Exception handling
# ============================================================================

statement ok
DROP TABLE IF EXISTS test_json_filter;

statement ok
CREATE TABLE test_json_filter (c1 int, c2 varchar, c3 json);

# ============================================================================
# Part 1: Basic JSON Operations
# ============================================================================

statement ok
INSERT INTO test_json_filter VALUES (1, 'b', '{"1":123}'), (2, 'c', '{"2":123}'), (3, 'd', '{"1":null}'), (4, 'e', '{"1":0.123}'), (5, 'f', '{"2":true}')

# json_extract_string
query I
SELECT json_extract_string(c3, '$.1') FROM test_json_filter;
----
123
null
null
0.123
null

# json_extract_int
query I
SELECT json_extract_int(c3, '$.1') FROM test_json_filter;
----
123
null
null
null
null

# json_extract_double
query F
SELECT json_extract_double(c3, '$.1') FROM test_json_filter;
----
123.000000
null
null
0.123000
null

# json_extract_bool
query B
SELECT json_extract_bool(c3, '$.2') FROM test_json_filter;
----
null
null
null
null
true

# json_extract_isnull
query B
SELECT json_extract_isnull(c3, '$.1') FROM test_json_filter;
----
false
null
true
false
null

# ============================================================================
# Part 2: JSON Path Extraction with WHERE clause
# ============================================================================

query ITT
SELECT * FROM test_json_filter where json_extract_string(c3, '$.1') = '123';
----
1 b {"1":123}

query ITT
SELECT * FROM test_json_filter where json_extract_int(c3, '$.1') = 123;
----
1 b {"1":123}

# ============================================================================
# Part 3: JSON Array Operations
# ============================================================================

statement ok
INSERT INTO test_json_filter VALUES (6, 'g', '[1,2.3,null,"i am string",true]')

statement ok
INSERT INTO test_json_filter VALUES (7, 'h', '["电商", "美妆", "母婴"]')

statement ok
INSERT INTO test_json_filter VALUES (8, 'i', '[{"name":"张三", "age":25}, {"name":"李四", "age":30}]')

# json_contains on arrays
query B
SELECT json_contains(c3, '"美妆"') FROM test_json_filter WHERE c1 = 7;
----
true

query B
SELECT json_contains(c3, '"不存在的商品"') FROM test_json_filter WHERE c1 = 7;
----
false

query B
SELECT json_contains(c3, '1') FROM test_json_filter WHERE c1 = 6;
----
true

# json_extract on arrays
query IT
SELECT c1, json_extract(c3, '$[0]') FROM test_json_filter;
----
1 null
2 null
3 null
4 null
5 null
6 1
7 "电商"
8 {"age":25,"name":"张三"}

# ============================================================================
# Part 4: Nested JSON Structures
# ============================================================================

statement ok
INSERT INTO test_json_filter VALUES (9, 'j', '{"a":[{"aa":111,"bb":222},null,"zpf"]}')

# nested path extraction


# ============================================================================
# Part 5: Complex Nested JSON Objects
# ============================================================================

statement ok
INSERT INTO test_json_filter VALUES (10, 'k', '{"name": "测试", "value": 42.5, "active": false, "tags": ["tag1", "tag2"], "nested": {"key1": "val1", "key2": 999}}')

statement ok
INSERT INTO test_json_filter VALUES (11, 'l', '{"empty_array": [], "empty_object": {}, "special_chars": "a\nb\tc", "unicode": "\u4e2d\u6587"}')

statement ok
INSERT INTO test_json_filter VALUES (12, 'm', '{"level1": {"level2": {"level3": {"level4": "deep_value"}}}}')

statement ok
INSERT INTO test_json_filter VALUES (13, 'n', '{"bool_true": true, "bool_false": false, "zero": 0, "negative": -100}')

# ============================================================================
# Part 6: JSON Path Existence (json_exists_path)
# ============================================================================

query B
SELECT json_exists_path(c3, '$.1') FROM test_json_filter WHERE c1 <= 13;
----
true
false
true
true
false
false
false
false
false
false
false
false
false

query B
SELECT json_exists_path(c3, '$.a') FROM test_json_filter WHERE c1 = 9;
----
true

query B
SELECT json_exists_path(c3, '$.nonexistent') FROM test_json_filter WHERE c1 <= 13;
----
false
false
false
false
false
false
false
false
false
false
false
false
false

query B
SELECT json_exists_path(c3, '$.level1.level2.level3') FROM test_json_filter WHERE c1 = 12;
----
true

query B
SELECT json_exists_path(c3, '$.level1.level2.level3.level4.level5') FROM test_json_filter WHERE c1 = 12;
----
false

# ============================================================================
# Part 7: Array of Objects
# ============================================================================

statement ok
INSERT INTO test_json_filter VALUES (14, 'o', '[{"product": "laptop", "price": 999.99, "in_stock": true}, {"product": "mouse", "price": 29.99, "in_stock": false}]')


# ============================================================================
# Part 8: Array of Arrays and Mixed Type Arrays
# ============================================================================

statement ok
INSERT INTO test_json_filter VALUES (15, 'p', '{"array_of_arrays": [[1, 2], [3, 4], [5, 6]], "mixed_array": [1, "two", 3.0, true, null]}')

query T
SELECT json_extract(c3, '$.array_of_arrays[0]') FROM test_json_filter WHERE c1 = 15;
----
[1,2]

query T
SELECT json_extract(c3, '$.mixed_array[0]') FROM test_json_filter WHERE c1 = 15;
----
1

query T
SELECT json_extract(c3, '$.mixed_array[1]') FROM test_json_filter WHERE c1 = 15;
----
"two"

query T
SELECT json_extract(c3, '$.mixed_array[4]') FROM test_json_filter WHERE c1 = 15;
----
null

query B
SELECT json_extract_isnull(c3, '$.mixed_array[4]') FROM test_json_filter WHERE c1 = 15;
----
true

query I
SELECT json_extract_int(c3, '$.mixed_array[0]') FROM test_json_filter WHERE c1 = 15;
----
1

query F
SELECT json_extract_double(c3, '$.mixed_array[2]') FROM test_json_filter WHERE c1 = 15;
----
3.000000

query B
SELECT json_extract_bool(c3, '$.mixed_array[3]') FROM test_json_filter WHERE c1 = 15;
----
true

# ============================================================================
# Part 9: Edge Cases and Special Values
# ============================================================================

statement ok
INSERT INTO test_json_filter VALUES (16, 'q', '{"string_number": "123", "string_float": "45.67", "string_bool": "true"}')

query T
SELECT json_extract_string(c3, '$.string_number') FROM test_json_filter WHERE c1 = 16;
----
"123"

query T
SELECT json_extract_string(c3, '$.string_float') FROM test_json_filter WHERE c1 = 16;
----
"45.67"

query T
SELECT json_extract_string(c3, '$.string_bool') FROM test_json_filter WHERE c1 = 16;
----
"true"

statement ok
INSERT INTO test_json_filter VALUES (17, 'r', '{"a": [1, 2, 3], "b": [[4, 5], [6, 7]], "c": {"d": {"e": 8}}}')

query I
SELECT json_extract_int(c3, '$.a[2]') FROM test_json_filter WHERE c1 = 17;
----
3

query I
SELECT json_extract_int(c3, '$.b[1][1]') FROM test_json_filter WHERE c1 = 17;
----
7

query I
SELECT json_extract_int(c3, '$.c.d.e') FROM test_json_filter WHERE c1 = 17;
----
8

query T
SELECT json_extract(c3, '$.b[0]') FROM test_json_filter WHERE c1 = 17;
----
[4,5]

statement ok
INSERT INTO test_json_filter VALUES (18, 's', '{"arr": [1, 2, 3], "obj": {"x": 10}}')

# array index out of bounds
query T
SELECT json_extract(c3, '$.arr[10]') FROM test_json_filter WHERE c1 = 18;
----
null

query T
SELECT json_extract_string(c3, '$.arr[100]') FROM test_json_filter WHERE c1 = 18;
----
null

# Negative index causes error (not supported), skip this test
query T
SELECT json_extract(c3, '$.nonexistent') FROM test_json_filter WHERE c1 = 18;
----
null

query T
SELECT json_extract_string(c3, '$.obj.nonexistent') FROM test_json_filter WHERE c1 = 18;
----
null

query I
SELECT json_extract_int(c3, '$.obj.nonexistent.nested') FROM test_json_filter WHERE c1 = 18;
----
null

# accessing array on object (should return null)
query T
SELECT json_extract(c3, '$.obj[0]') FROM test_json_filter WHERE c1 = 18;
----
null

# accessing object property on array element
query T
SELECT json_extract(c3, '$.arr[0].x') FROM test_json_filter WHERE c1 = 18;
----
null

# Empty path causes error, skip this test
# root path access
query T
SELECT json_extract(c3, '$') FROM test_json_filter WHERE c1 = 18;
----
{"arr":[1,2,3],"obj":{"x":10}}

# deeply nested path that doesn't exist
query T
SELECT json_extract(c3, '$.a.b.c.d.e.f.g') FROM test_json_filter WHERE c1 = 18;
----
null

# path with array index on non-array
query T
SELECT json_extract(c3, '$.obj.x[0]') FROM test_json_filter WHERE c1 = 18;
----
null

statement ok
INSERT INTO test_json_filter VALUES (19, 't', '{"deep": {"level1": {"level2": {"level3": {"level4": {"level5": "final_value"}}}}}}')

# ============================================================================
# Part 10: Root-Level Nested Object Access
# ============================================================================

query T
SELECT json_extract(c3, '$.deep') FROM test_json_filter WHERE c1 = 19;
----
{"level1":{"level2":{"level3":{"level4":{"level5":"final_value"}}}}}

query T
SELECT json_extract(c3, '$.deep.level1') FROM test_json_filter WHERE c1 = 19;
----
{"level2":{"level3":{"level4":{"level5":"final_value"}}}}

# ============================================================================
# Part 11: json_exists_path with Various Scenarios
# ============================================================================

query B
SELECT json_exists_path(c3, '$.arr') FROM test_json_filter WHERE c1 = 18;
----
true

query B
SELECT json_exists_path(c3, '$.arr[0]') FROM test_json_filter WHERE c1 = 18;
----
true

query B
SELECT json_exists_path(c3, '$.arr[10]') FROM test_json_filter WHERE c1 = 18;
----
false

query B
SELECT json_exists_path(c3, '$.obj.x') FROM test_json_filter WHERE c1 = 18;
----
true

query B
SELECT json_exists_path(c3, '$.obj.y') FROM test_json_filter WHERE c1 = 18;
----
false

# ============================================================================
# Part 12: Root-Level Arrays
# ============================================================================

statement ok
INSERT INTO test_json_filter VALUES (24, 'y', '[100, 200, 300]')


query B
SELECT json_exists_path(c3, '$[0]') FROM test_json_filter WHERE c1 = 24;
----
true

query B
SELECT json_exists_path(c3, '$[3]') FROM test_json_filter WHERE c1 = 24;
----
false

# ============================================================================
# Part 13: CAST and parse_json Functions
# ============================================================================

query T
SELECT parse_json('{"k1": "100"}');
----
{"k1":"100"}

query T
SELECT CAST(json_extract(c3, '$.1') AS INT) FROM test_json_filter WHERE c1 <= 13;
----
123
null
null
0
null
null
null
null
null
null
null
null
null

statement ok
DROP TABLE test_json_filter;

# ============================================================================
# Part 14: JSON Type Casting Tests
# ============================================================================

statement ok
DROP TABLE IF EXISTS test_json_cast;

statement ok
CREATE TABLE test_json_cast (c1 int, c2 varchar, c3 json);

statement ok
INSERT INTO test_json_cast VALUES (1, 'test', '{"k1": "100", "k2": 200, "k3": 3.14, "k4": true, "k5": null}');

# CAST string to JSON
query T
SELECT CAST('{"k1": "100"}' AS JSON);
----
{"k1":"100"}

query T
SELECT CAST('["a", "b", "c"]' AS JSON);
----
["a","b","c"]

query T
SELECT CAST('null' AS JSON);
----
null

query T
SELECT CAST('true' AS JSON);
----
true

query T
SELECT CAST('123' AS JSON);
----
123

query T
SELECT CAST('3.14' AS JSON);
----
3.14

# Note: CAST invalid JSON strings should error
# Note: CAST JSON to VARCHAR is not supported in current version
# Note: CAST json_extract to SQL types is not supported, use typed extract functions instead

statement ok
DROP TABLE test_json_cast;

# ============================================================================
# Part 15: JSON Array Comprehensive Tests
# ============================================================================

statement ok
DROP TABLE IF EXISTS user_tags;

statement ok
CREATE TABLE user_tags (id int, tags JSON);

# Insert various JSON array types
statement ok
INSERT INTO user_tags VALUES (1, '["电商", "美妆", "母婴"]'), (2, '[100, 200, 300]'), (3, '[true, false, true]')

statement ok
INSERT INTO user_tags VALUES (4, '[[1,2,3], [4,5,6]]'), (5, '["a", ["b", "c"]]')

statement ok
INSERT INTO user_tags VALUES (6, '[{"name":"张三", "age":25}, {"name":"李四", "age":30}]')

# json_contains on different array types
query ITT
SELECT * FROM user_tags WHERE json_contains(tags, '"美妆"');
----
1 ["电商","美妆","母婴"]

# json_extract on arrays
query IT
SELECT id, json_extract(tags, '$[0]') AS first_element FROM user_tags WHERE id = 1;
----
1 "电商"

query IT
SELECT id, json_extract(tags, '$[2]') AS third_element FROM user_tags WHERE id = 1;
----
1 "母婴"

query IT
SELECT id, json_extract(tags, '$[10]') AS out_of_bounds FROM user_tags WHERE id = 1;
----
1 null

# json_extract entire array
query IT
SELECT id, json_extract(tags, '$') AS full_array FROM user_tags WHERE id = 1;
----
1 ["电商","美妆","母婴"]

# nested arrays
query IT
SELECT id, json_extract(tags, '$[0]') AS first_sub_array FROM user_tags WHERE id = 4;
----
4 [1,2,3]

query IT
SELECT id, json_extract(tags, '$[0][0]') AS nested_element FROM user_tags WHERE id = 4;
----
4 1

query IT
SELECT id, json_extract(tags, '$[1][2]') AS nested_element FROM user_tags WHERE id = 4;
----
4 6

query IT
SELECT id, json_extract(tags, '$[1]') AS second_element FROM user_tags WHERE id = 5;
----
5 ["b","c"]

query IT
SELECT id, json_extract(tags, '$[1][0]') AS nested_string FROM user_tags WHERE id = 5;
----
5 "b"

# array of objects
query IT
SELECT id, json_extract(tags, '$[0]') AS first_object FROM user_tags WHERE id = 6;
----
6 {"age":25,"name":"张三"}

query IT
SELECT id, json_extract_string(tags, '$[0].name') AS first_name FROM user_tags WHERE id = 6;
----
6 "张三"

query II
SELECT id, json_extract_int(tags, '$[0].age') AS first_age FROM user_tags WHERE id = 6;
----
6 25

query IT
SELECT id, json_extract_string(tags, '$[1].name') AS second_name FROM user_tags WHERE id = 6;
----
6 "李四"

query II
SELECT id, json_extract_int(tags, '$[1].age') AS second_age FROM user_tags WHERE id = 6;
----
6 30

query IT
SELECT id, json_extract(tags, '$[2]') AS out_of_bounds FROM user_tags WHERE id = 6;
----
6 null

query IT
SELECT id, json_extract(tags, '$[0].nonexistent') AS missing_field FROM user_tags WHERE id = 6;
----
6 null

# typed extract functions on arrays
query II
SELECT id, json_extract_int(tags, '$[1]') AS second_element FROM user_tags WHERE id = 2;
----
2 200

query IF
SELECT id, json_extract_double(tags, '$[1]') AS second_element FROM user_tags WHERE id = 2;
----
2 200.000000

query IB
SELECT id, json_extract_bool(tags, '$[1]') AS second_element FROM user_tags WHERE id = 3;
----
3 false

query IT
SELECT id, json_extract_string(tags, '$[0]') AS first_element FROM user_tags WHERE id = 1;
----
1 "电商"

# json_extract_bool on non-boolean elements
query IB
SELECT id, json_extract_bool(tags, '$[0]') FROM user_tags WHERE id = 1;
----
1 null

# json_exists_path on arrays
query IB
SELECT id, json_exists_path(tags, '$[0]') FROM user_tags;
----
1 true
2 true
3 true
4 true
5 true
6 true

query IB
SELECT id, json_exists_path(tags, '$[10]') FROM user_tags;
----
1 false
2 false
3 false
4 false
5 false
6 false

query IB
SELECT id, json_exists_path(tags, '$[0].name') FROM user_tags WHERE id = 6;
----
6 true

query IB
SELECT id, json_exists_path(tags, '$[0].nonexistent') FROM user_tags WHERE id = 6;
----
6 false

# empty arrays
statement ok
INSERT INTO user_tags VALUES (7, '[]'), (8, '[[]]'), (9, '[null]')

query IT
SELECT id, json_extract(tags, '$') FROM user_tags WHERE id = 7;
----
7 []

query IT
SELECT id, json_extract(tags, '$[0]') FROM user_tags WHERE id = 7;
----
7 null

query IT
SELECT id, json_extract(tags, '$[0]') FROM user_tags WHERE id = 8;
----
8 []

query IT
SELECT id, json_extract(tags, '$[0][0]') FROM user_tags WHERE id = 8;
----
8 null

query IB
SELECT id, json_extract_isnull(tags, '$[0]') FROM user_tags WHERE id = 9;
----
9 true

# mixed type arrays
statement ok
INSERT INTO user_tags VALUES (10, '[1, "two", 3.0, true, null, {"key": "value"}]')

query II
SELECT id, json_extract_int(tags, '$[0]') FROM user_tags WHERE id = 10;
----
10 1

query IT
SELECT id, json_extract_string(tags, '$[1]') FROM user_tags WHERE id = 10;
----
10 "two"

query IF
SELECT id, json_extract_double(tags, '$[2]') FROM user_tags WHERE id = 10;
----
10 3.000000

query IB
SELECT id, json_extract_bool(tags, '$[3]') FROM user_tags WHERE id = 10;
----
10 true

query IB
SELECT id, json_extract_isnull(tags, '$[4]') FROM user_tags WHERE id = 10;
----
10 true

query IT
SELECT id, json_extract(tags, '$[5]') FROM user_tags WHERE id = 10;
----
10 {"key":"value"}

query IT
SELECT id, json_extract_string(tags, '$[5].key') FROM user_tags WHERE id = 10;
----
10 "value"

# large arrays
statement ok
INSERT INTO user_tags VALUES (11, '[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]')

query II
SELECT id, json_extract_int(tags, '$[9]') FROM user_tags WHERE id = 11;
----
11 9

query II
SELECT id, json_extract_int(tags, '$[10]') FROM user_tags WHERE id = 11;
----
11 null

query IB
SELECT id, json_exists_path(tags, '$[9]') FROM user_tags WHERE id = 11;
----
11 true

query IB
SELECT id, json_exists_path(tags, '$[10]') FROM user_tags WHERE id = 11;
----
11 false

# json_contains on non-array JSON
statement ok
INSERT INTO user_tags VALUES (12, '{"key": "value"}')

query IB
SELECT id, json_contains(tags, '"value"') FROM user_tags WHERE id = 12;
----
12 false

statement ok
DROP TABLE user_tags;

# ============================================================================
# Part 16: JSON Functions with Arithmetic Operations
# ============================================================================

statement ok
DROP TABLE IF EXISTS test_json_arithmetic;

statement ok
CREATE TABLE test_json_arithmetic (c1 int, c2 json);

# Insert test data with numeric JSON values
statement ok
INSERT INTO test_json_arithmetic VALUES 
(1, '{"value": 100}'),
(2, '{"score": 95.5}'),
(3, '{"age": 25}'),
(4, '{"price": 19.99}'),
(5, '{"quantity": 42}'),
(6, '{"negative": -10}'),
(7, '{"zero": 0}'),
(8, '{"decimal": 3.14159}'),
(9, '{"large": 999999}'),
(10, '{"small": 0.001}')

# ============================================================================
# 7.1: JSON Extract with Addition
# ============================================================================

query II
SELECT c1, json_extract_int(c2, '$.value') + 50 FROM test_json_arithmetic WHERE c1 = 1;
----
1 150

# Test: adding two JSON-extracted values
query II
SELECT c1, json_extract_int(c2, '$.quantity') + json_extract_int(c2, '$.value') 
FROM test_json_arithmetic 
WHERE c1 = 1;
----
1 null

# ============================================================================
# 7.2: JSON Extract with Subtraction
# ============================================================================

query II
SELECT c1, json_extract_int(c2, '$.value') - 20 FROM test_json_arithmetic WHERE c1 = 1;
----
1 80

query II
SELECT c1, json_extract_int(c2, '$.value') - json_extract_int(c2, '$.value')
FROM test_json_arithmetic WHERE c1 = 1;
----
1 0

# ============================================================================
# 7.3: JSON Extract with Multiplication
# ============================================================================


query II
SELECT c1, json_extract_int(c2, '$.quantity') * json_extract_int(c2, '$.quantity')
FROM test_json_arithmetic WHERE c1 = 5;
----
5 1764

# ============================================================================
# 7.4: JSON Extract with Division
# ============================================================================

query II
SELECT c1, json_extract_int(c2, '$.value') / 2 FROM test_json_arithmetic WHERE c1 = 1;
----
1 50.000000

# ============================================================================
# 7.5: JSON Extract with ROUND
# ============================================================================


# ============================================================================
# 7.6: JSON Extract with SQRT
# ============================================================================

statement ok
INSERT INTO test_json_arithmetic VALUES (11, '{"area": 144}')


# ============================================================================
# 7.7: JSON Extract with ABS
# ============================================================================


# ============================================================================
# 7.8: JSON Extract with CEIL/FLOOR
# ============================================================================


# ============================================================================
# 7.9: Complex Expressions with JSON Extract
# ============================================================================

query IF
SELECT c1, ROUND(json_extract_double(c2, '$.score') + json_extract_int(c2, '$.age'))
FROM test_json_arithmetic WHERE c1 = 2;
----
2 null

statement ok
INSERT INTO test_json_arithmetic VALUES (12, '{"score": 95.5, "bonus": 5, "age": 25}')

query IF
SELECT c1, ROUND(json_extract_double(c2, '$.score') + json_extract_int(c2, '$.bonus'))
FROM test_json_arithmetic WHERE c1 = 12;
----
12 101.000000

query II
SELECT c1, (json_extract_int(c2, '$.value') * 2) + json_extract_int(c2, '$.age')
FROM test_json_arithmetic WHERE c1 = 1;
----
1 null

statement ok
INSERT INTO test_json_arithmetic VALUES (13, '{"base": 100, "multiplier": 3}')

query II
SELECT c1, json_extract_int(c2, '$.base') * json_extract_int(c2, '$.multiplier') + json_extract_int(c2, '$.base') 
FROM test_json_arithmetic WHERE c1 = 13;
----
13 400

# ============================================================================
# 7.10: JSON Extract String in Arithmetic
# ============================================================================

statement ok
INSERT INTO test_json_arithmetic VALUES (14, '{"text_value": "123"}')

# This should either work or return 0/null, not crash

# ============================================================================
# 7.11: Nested JSON with Arithmetic
# ============================================================================

statement ok
INSERT INTO test_json_arithmetic VALUES (15, '{"data": {"inner": 50, "outer": 100}}')

query II
SELECT c1, json_extract_int(c2, '$.data.outer') / 2 FROM test_json_arithmetic WHERE c1 = 15;
----
15 50.000000

query II
SELECT c1, json_extract_int(c2, '$.data.inner') + json_extract_int(c2, '$.data.outer') 
FROM test_json_arithmetic WHERE c1 = 15;
----
15 150

# ============================================================================
# 7.12: JSON Extract with Modulo
# ============================================================================

query II
SELECT c1, json_extract_int(c2, '$.value') % 3 FROM test_json_arithmetic WHERE c1 = 1;
----
1 1


# ============================================================================
# Part 17: JSON Functions with CAST
# ============================================================================

statement ok
DROP TABLE IF EXISTS test_json_cast;

statement ok
CREATE TABLE test_json_cast (c1 int, c2 json);

statement ok
INSERT INTO test_json_cast VALUES 
(1, '{"int_val": "42"}'),
(2, '{"float_val": "3.14"}'),
(3, '{"bool_val": "true"}'),
(4, '{"name": "Alice"}')

# CAST from JSON-extracted string
query II
SELECT c1, CAST(json_extract_string(c2, '$.int_val') AS INTEGER)
FROM test_json_cast WHERE c1 = 1;
----
1 null

query IT
SELECT c1, CAST(json_extract_string(c2, '$.float_val') AS DOUBLE)
FROM test_json_cast WHERE c1 = 2;
----
2 null

query IB
SELECT c1, CAST(json_extract_string(c2, '$.bool_val') AS BOOLEAN)
FROM test_json_cast WHERE c1 = 3;
----
3 null

query IT
SELECT c1, CAST(json_extract_string(c2, '$.name') AS VARCHAR)
FROM test_json_cast WHERE c1 = 4;
----
4 "Alice"

# ============================================================================
# Part 18: Edge Cases and Error Handling
# ============================================================================

statement ok
DROP TABLE IF EXISTS test_json_edge_cases;

statement ok
CREATE TABLE test_json_edge_cases (c1 int, c2 json);

# NULL handling
statement ok
INSERT INTO test_json_edge_cases VALUES (1, '{"missing": null}')

query II
SELECT c1, json_extract_int(c2, '$.missing') + 10 FROM test_json_edge_cases WHERE c1 = 1;
----
1 null

# missing path
query II
SELECT c1, json_extract_int(c2, '$.nonexistent') * 2 FROM test_json_edge_cases WHERE c1 = 1;
----
1 null

# division by zero (should not crash)
query II
SELECT c1, json_extract_int(c2, '$.missing') / 0 FROM test_json_edge_cases WHERE c1 = 1;
----
1 null

# SQRT of negative number
statement ok
INSERT INTO test_json_edge_cases VALUES (2, '{"negative": -16}')

# ROUND with NULL
statement ok
INSERT INTO test_json_edge_cases VALUES (3, '{"null_val": null}')


# ============================================================================
# Part 19: JSON Array with Arithmetic
# ============================================================================

statement ok
DROP TABLE IF EXISTS test_json_array_arithmetic;

statement ok
CREATE TABLE test_json_array_arithmetic (c1 int, c2 json);

statement ok
INSERT INTO test_json_array_arithmetic VALUES 
(1, '[10, 20, 30]'),
(2, '[1.5, 2.5, 3.5]'),
(3, '[100, 200, 300]')

# Extract array element and perform arithmetic
query IT
SELECT c1, json_extract(c2, '$[0]') + 100 FROM test_json_array_arithmetic WHERE c1 = 1;
----
1 110

query IT
SELECT c1, json_extract(c2, '$[1]') * 2 FROM test_json_array_arithmetic WHERE c1 = 1;
----
1 40

statement ok
DROP TABLE test_json_arithmetic;

statement ok
DROP TABLE test_json_cast;

statement ok
DROP TABLE test_json_edge_cases;

statement ok
DROP TABLE test_json_array_arithmetic;

# ============================================================================
# Part 20: JSON NULL and Empty Value Handling with Arithmetic/Functions
# ============================================================================

statement ok
DROP TABLE IF EXISTS test_json_null_handling;

statement ok
CREATE TABLE test_json_null_handling (c1 int, c2 json);

# Insert various NULL and empty value scenarios
statement ok
INSERT INTO test_json_null_handling VALUES 
(1, '{"val": null}'),
(2, '{"val": 0}'),
(3, '{"val": []}'),
(4, '{"val": {}}'),
(5, '{"val": ""}'),
(6, '{"nested": {"inner": null}}'),
(7, '{"arr": [null, 10, null]}'),
(8, '{"mixed": [null, {"k": null}, []]}')

# json_extract_int with NULL
query II
SELECT c1, json_extract_int(c2, '$.val') FROM test_json_null_handling WHERE c1 = 1;
----
1 null

# json_extract_double with NULL
query IF
SELECT c1, json_extract_double(c2, '$.val') FROM test_json_null_handling WHERE c1 = 1;
----
1 null

# json_extract_bool with NULL
query IB
SELECT c1, json_extract_bool(c2, '$.val') FROM test_json_null_handling WHERE c1 = 1;
----
1 null

# json_extract_isnull with actual NULL value
query IB
SELECT c1, json_extract_isnull(c2, '$.val') FROM test_json_null_handling WHERE c1 = 1;
----
1 true

# json_extract_isnull with non-NULL value
# Arithmetic with NULL value
query II
SELECT c1, json_extract_int(c2, '$.val') + 10 FROM test_json_null_handling WHERE c1 = 1;
----
1 null

# Scalar functions with NULL
query IF
SELECT c1, ROUND(json_extract_double(c2, '$.val')) FROM test_json_null_handling WHERE c1 = 1;
----
1 null

query II
SELECT c1, json_extract_int(c2, '$.val') > 5 FROM test_json_null_handling WHERE c1 = 1;
----
1 null

query II
SELECT c1, json_extract_int(c2, '$.val') = 0 FROM test_json_null_handling WHERE c1 = 1;
----
1 null

query II
SELECT c1, json_extract_int(c2, '$.val') < 10 FROM test_json_null_handling WHERE c1 = 1;
----
1 null

# CAST with NULL values
query II
SELECT c1, CAST(json_extract_string(c2, '$.val') AS INTEGER) FROM test_json_null_handling WHERE c1 = 1;
----
1 null

query IT
SELECT c1, CAST(json_extract_int(c2, '$.val') AS VARCHAR) FROM test_json_null_handling WHERE c1 = 1;
----
1 null

# mixed NULL and valid values in arithmetic

statement ok
DROP TABLE test_json_null_handling;

# ============================================================================
# Part 21: UNNEST(JSON) Function Tests
# ============================================================================

statement ok
DROP TABLE IF EXISTS test_unnest_json;

statement ok
CREATE TABLE test_unnest_json (c1 int, c2 json);

# 1: Basic integer array
statement ok
INSERT INTO test_unnest_json VALUES (1, '[1, 2, 3]')

query I
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 1;
----
1
2
3

# 2: String array  
statement ok
INSERT INTO test_unnest_json VALUES (2, '["apple", "banana", "cherry"]')

query T
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 2;
----
"apple"
"banana"
"cherry"

# 3: Mixed types with NULL
statement ok
INSERT INTO test_unnest_json VALUES (3, '[1, null, 3.14, true, "text"]')

query T
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 3;
----
1
null
3.14
true
"text"

# 4: All NULL array
statement ok
INSERT INTO test_unnest_json VALUES (4, '[null, null, null]')

query T
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 4;
----
null
null
null

# 5: Empty array
statement ok
INSERT INTO test_unnest_json VALUES (5, '[]')

query T
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 5;
----

# 6: Array of objects
statement ok
INSERT INTO test_unnest_json VALUES (6, '[{"name": "Alice", "age": 30}, {"name": "Bob", "age": 25}]')

query T rowsort
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 6;
----
{"age":25,"name":"Bob"}
{"age":30,"name":"Alice"}

# 7: Nested arrays
statement ok
INSERT INTO test_unnest_json VALUES (7, '[[1, 2], [3, 4], [5, 6]]')

query T rowsort
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 7;
----
[1,2]
[3,4]
[5,6]

# 8: Single element
statement ok
INSERT INTO test_unnest_json VALUES (8, '[42]')

query I
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 8;
----
42

# 9: Boolean values
statement ok
INSERT INTO test_unnest_json VALUES (9, '[true, false, true]')

query T rowsort
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 9;
----
false
true
true

# 10: Negative numbers and zeros
statement ok
INSERT INTO test_unnest_json VALUES (10, '[-100, -0.5, 0, 100]')

query F
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 10;
----
-100
-0.5
0
100

# 11: Non-array JSON (object)
statement ok
INSERT INTO test_unnest_json VALUES (11, '{"key": "value", "number": 123}')

query T
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 11;
----
{"key":"value","number":123}

# 12: Scalar string
statement ok
INSERT INTO test_unnest_json VALUES (12, '"just a string"')

query T
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 12;
----
"just a string"

# 13: Scalar number
statement ok
INSERT INTO test_unnest_json VALUES (13, '42')

query I
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 13;
----
42

# 14: Scalar null
statement ok
INSERT INTO test_unnest_json VALUES (14, 'null')

query T
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 14;
----
null

# 15: 3D arrays
statement ok
INSERT INTO test_unnest_json VALUES (15, '[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]')

query T rowsort
SELECT UNNEST(c2) FROM test_unnest_json WHERE c1 = 15;
----
[[1,2],[3,4]]
[[5,6],[7,8]]

statement ok
DROP TABLE test_unnest_json;
