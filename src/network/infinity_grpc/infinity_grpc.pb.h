// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: infinity_grpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_infinity_5fgrpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_infinity_5fgrpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_infinity_5fgrpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_infinity_5fgrpc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_infinity_5fgrpc_2eproto;
namespace infinity_grpc_proto {
class BetweenExpr;
struct BetweenExprDefaultTypeInternal;
extern BetweenExprDefaultTypeInternal _BetweenExpr_default_instance_;
class ColumnConstraint;
struct ColumnConstraintDefaultTypeInternal;
extern ColumnConstraintDefaultTypeInternal _ColumnConstraint_default_instance_;
class ColumnDef;
struct ColumnDefDefaultTypeInternal;
extern ColumnDefDefaultTypeInternal _ColumnDef_default_instance_;
class ColumnExpr;
struct ColumnExprDefaultTypeInternal;
extern ColumnExprDefaultTypeInternal _ColumnExpr_default_instance_;
class ColumnField;
struct ColumnFieldDefaultTypeInternal;
extern ColumnFieldDefaultTypeInternal _ColumnField_default_instance_;
class CommonResponse;
struct CommonResponseDefaultTypeInternal;
extern CommonResponseDefaultTypeInternal _CommonResponse_default_instance_;
class ConstantExpr;
struct ConstantExprDefaultTypeInternal;
extern ConstantExprDefaultTypeInternal _ConstantExpr_default_instance_;
class CreateDatabaseRequest;
struct CreateDatabaseRequestDefaultTypeInternal;
extern CreateDatabaseRequestDefaultTypeInternal _CreateDatabaseRequest_default_instance_;
class CreateIndexRequest;
struct CreateIndexRequestDefaultTypeInternal;
extern CreateIndexRequestDefaultTypeInternal _CreateIndexRequest_default_instance_;
class CreateTableRequest;
struct CreateTableRequestDefaultTypeInternal;
extern CreateTableRequestDefaultTypeInternal _CreateTableRequest_default_instance_;
class DataBlock;
struct DataBlockDefaultTypeInternal;
extern DataBlockDefaultTypeInternal _DataBlock_default_instance_;
class DataBlock_ColumnVector;
struct DataBlock_ColumnVectorDefaultTypeInternal;
extern DataBlock_ColumnVectorDefaultTypeInternal _DataBlock_ColumnVector_default_instance_;
class DataType;
struct DataTypeDefaultTypeInternal;
extern DataTypeDefaultTypeInternal _DataType_default_instance_;
class DescribeDatabaseRequest;
struct DescribeDatabaseRequestDefaultTypeInternal;
extern DescribeDatabaseRequestDefaultTypeInternal _DescribeDatabaseRequest_default_instance_;
class DescribeDatabaseResponse;
struct DescribeDatabaseResponseDefaultTypeInternal;
extern DescribeDatabaseResponseDefaultTypeInternal _DescribeDatabaseResponse_default_instance_;
class DescribeTableRequest;
struct DescribeTableRequestDefaultTypeInternal;
extern DescribeTableRequestDefaultTypeInternal _DescribeTableRequest_default_instance_;
class DescribeTableResponse;
struct DescribeTableResponseDefaultTypeInternal;
extern DescribeTableResponseDefaultTypeInternal _DescribeTableResponse_default_instance_;
class DisConnectRequest;
struct DisConnectRequestDefaultTypeInternal;
extern DisConnectRequestDefaultTypeInternal _DisConnectRequest_default_instance_;
class DropDatabaseRequest;
struct DropDatabaseRequestDefaultTypeInternal;
extern DropDatabaseRequestDefaultTypeInternal _DropDatabaseRequest_default_instance_;
class DropIndexRequest;
struct DropIndexRequestDefaultTypeInternal;
extern DropIndexRequestDefaultTypeInternal _DropIndexRequest_default_instance_;
class DropTableRequest;
struct DropTableRequestDefaultTypeInternal;
extern DropTableRequestDefaultTypeInternal _DropTableRequest_default_instance_;
class EmbeddingType;
struct EmbeddingTypeDefaultTypeInternal;
extern EmbeddingTypeDefaultTypeInternal _EmbeddingType_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class Field;
struct FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class FunctionExpr;
struct FunctionExprDefaultTypeInternal;
extern FunctionExprDefaultTypeInternal _FunctionExpr_default_instance_;
class GetDatabaseRequest;
struct GetDatabaseRequestDefaultTypeInternal;
extern GetDatabaseRequestDefaultTypeInternal _GetDatabaseRequest_default_instance_;
class GetTableRequest;
struct GetTableRequestDefaultTypeInternal;
extern GetTableRequestDefaultTypeInternal _GetTableRequest_default_instance_;
class ImportRequest;
struct ImportRequestDefaultTypeInternal;
extern ImportRequestDefaultTypeInternal _ImportRequest_default_instance_;
class ImportRequest_ImportOptions;
struct ImportRequest_ImportOptionsDefaultTypeInternal;
extern ImportRequest_ImportOptionsDefaultTypeInternal _ImportRequest_ImportOptions_default_instance_;
class InExpr;
struct InExprDefaultTypeInternal;
extern InExprDefaultTypeInternal _InExpr_default_instance_;
class InitParameter;
struct InitParameterDefaultTypeInternal;
extern InitParameterDefaultTypeInternal _InitParameter_default_instance_;
class InsertRequest;
struct InsertRequestDefaultTypeInternal;
extern InsertRequestDefaultTypeInternal _InsertRequest_default_instance_;
class KnnExpr;
struct KnnExprDefaultTypeInternal;
extern KnnExprDefaultTypeInternal _KnnExpr_default_instance_;
class ListDatabaseRequest;
struct ListDatabaseRequestDefaultTypeInternal;
extern ListDatabaseRequestDefaultTypeInternal _ListDatabaseRequest_default_instance_;
class ListDatabaseResponse;
struct ListDatabaseResponseDefaultTypeInternal;
extern ListDatabaseResponseDefaultTypeInternal _ListDatabaseResponse_default_instance_;
class ListTableRequest;
struct ListTableRequestDefaultTypeInternal;
extern ListTableRequestDefaultTypeInternal _ListTableRequest_default_instance_;
class ListTableResponse;
struct ListTableResponseDefaultTypeInternal;
extern ListTableResponseDefaultTypeInternal _ListTableResponse_default_instance_;
class NumberType;
struct NumberTypeDefaultTypeInternal;
extern NumberTypeDefaultTypeInternal _NumberType_default_instance_;
class Options;
struct OptionsDefaultTypeInternal;
extern OptionsDefaultTypeInternal _Options_default_instance_;
class ParsedExpr;
struct ParsedExprDefaultTypeInternal;
extern ParsedExprDefaultTypeInternal _ParsedExpr_default_instance_;
class SelectResponse;
struct SelectResponseDefaultTypeInternal;
extern SelectResponseDefaultTypeInternal _SelectResponse_default_instance_;
class SelectStatement;
struct SelectStatementDefaultTypeInternal;
extern SelectStatementDefaultTypeInternal _SelectStatement_default_instance_;
class VarcharType;
struct VarcharTypeDefaultTypeInternal;
extern VarcharTypeDefaultTypeInternal _VarcharType_default_instance_;
}  // namespace infinity_grpc_proto
PROTOBUF_NAMESPACE_OPEN
template<> ::infinity_grpc_proto::BetweenExpr* Arena::CreateMaybeMessage<::infinity_grpc_proto::BetweenExpr>(Arena*);
template<> ::infinity_grpc_proto::ColumnConstraint* Arena::CreateMaybeMessage<::infinity_grpc_proto::ColumnConstraint>(Arena*);
template<> ::infinity_grpc_proto::ColumnDef* Arena::CreateMaybeMessage<::infinity_grpc_proto::ColumnDef>(Arena*);
template<> ::infinity_grpc_proto::ColumnExpr* Arena::CreateMaybeMessage<::infinity_grpc_proto::ColumnExpr>(Arena*);
template<> ::infinity_grpc_proto::ColumnField* Arena::CreateMaybeMessage<::infinity_grpc_proto::ColumnField>(Arena*);
template<> ::infinity_grpc_proto::CommonResponse* Arena::CreateMaybeMessage<::infinity_grpc_proto::CommonResponse>(Arena*);
template<> ::infinity_grpc_proto::ConstantExpr* Arena::CreateMaybeMessage<::infinity_grpc_proto::ConstantExpr>(Arena*);
template<> ::infinity_grpc_proto::CreateDatabaseRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::CreateDatabaseRequest>(Arena*);
template<> ::infinity_grpc_proto::CreateIndexRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::CreateIndexRequest>(Arena*);
template<> ::infinity_grpc_proto::CreateTableRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::CreateTableRequest>(Arena*);
template<> ::infinity_grpc_proto::DataBlock* Arena::CreateMaybeMessage<::infinity_grpc_proto::DataBlock>(Arena*);
template<> ::infinity_grpc_proto::DataBlock_ColumnVector* Arena::CreateMaybeMessage<::infinity_grpc_proto::DataBlock_ColumnVector>(Arena*);
template<> ::infinity_grpc_proto::DataType* Arena::CreateMaybeMessage<::infinity_grpc_proto::DataType>(Arena*);
template<> ::infinity_grpc_proto::DescribeDatabaseRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::DescribeDatabaseRequest>(Arena*);
template<> ::infinity_grpc_proto::DescribeDatabaseResponse* Arena::CreateMaybeMessage<::infinity_grpc_proto::DescribeDatabaseResponse>(Arena*);
template<> ::infinity_grpc_proto::DescribeTableRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::DescribeTableRequest>(Arena*);
template<> ::infinity_grpc_proto::DescribeTableResponse* Arena::CreateMaybeMessage<::infinity_grpc_proto::DescribeTableResponse>(Arena*);
template<> ::infinity_grpc_proto::DisConnectRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::DisConnectRequest>(Arena*);
template<> ::infinity_grpc_proto::DropDatabaseRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::DropDatabaseRequest>(Arena*);
template<> ::infinity_grpc_proto::DropIndexRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::DropIndexRequest>(Arena*);
template<> ::infinity_grpc_proto::DropTableRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::DropTableRequest>(Arena*);
template<> ::infinity_grpc_proto::EmbeddingType* Arena::CreateMaybeMessage<::infinity_grpc_proto::EmbeddingType>(Arena*);
template<> ::infinity_grpc_proto::Empty* Arena::CreateMaybeMessage<::infinity_grpc_proto::Empty>(Arena*);
template<> ::infinity_grpc_proto::Field* Arena::CreateMaybeMessage<::infinity_grpc_proto::Field>(Arena*);
template<> ::infinity_grpc_proto::FunctionExpr* Arena::CreateMaybeMessage<::infinity_grpc_proto::FunctionExpr>(Arena*);
template<> ::infinity_grpc_proto::GetDatabaseRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::GetDatabaseRequest>(Arena*);
template<> ::infinity_grpc_proto::GetTableRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::GetTableRequest>(Arena*);
template<> ::infinity_grpc_proto::ImportRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::ImportRequest>(Arena*);
template<> ::infinity_grpc_proto::ImportRequest_ImportOptions* Arena::CreateMaybeMessage<::infinity_grpc_proto::ImportRequest_ImportOptions>(Arena*);
template<> ::infinity_grpc_proto::InExpr* Arena::CreateMaybeMessage<::infinity_grpc_proto::InExpr>(Arena*);
template<> ::infinity_grpc_proto::InitParameter* Arena::CreateMaybeMessage<::infinity_grpc_proto::InitParameter>(Arena*);
template<> ::infinity_grpc_proto::InsertRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::InsertRequest>(Arena*);
template<> ::infinity_grpc_proto::KnnExpr* Arena::CreateMaybeMessage<::infinity_grpc_proto::KnnExpr>(Arena*);
template<> ::infinity_grpc_proto::ListDatabaseRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::ListDatabaseRequest>(Arena*);
template<> ::infinity_grpc_proto::ListDatabaseResponse* Arena::CreateMaybeMessage<::infinity_grpc_proto::ListDatabaseResponse>(Arena*);
template<> ::infinity_grpc_proto::ListTableRequest* Arena::CreateMaybeMessage<::infinity_grpc_proto::ListTableRequest>(Arena*);
template<> ::infinity_grpc_proto::ListTableResponse* Arena::CreateMaybeMessage<::infinity_grpc_proto::ListTableResponse>(Arena*);
template<> ::infinity_grpc_proto::NumberType* Arena::CreateMaybeMessage<::infinity_grpc_proto::NumberType>(Arena*);
template<> ::infinity_grpc_proto::Options* Arena::CreateMaybeMessage<::infinity_grpc_proto::Options>(Arena*);
template<> ::infinity_grpc_proto::ParsedExpr* Arena::CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(Arena*);
template<> ::infinity_grpc_proto::SelectResponse* Arena::CreateMaybeMessage<::infinity_grpc_proto::SelectResponse>(Arena*);
template<> ::infinity_grpc_proto::SelectStatement* Arena::CreateMaybeMessage<::infinity_grpc_proto::SelectStatement>(Arena*);
template<> ::infinity_grpc_proto::VarcharType* Arena::CreateMaybeMessage<::infinity_grpc_proto::VarcharType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace infinity_grpc_proto {

enum ImportRequest_ImportOptions_CopyFileType : int {
  ImportRequest_ImportOptions_CopyFileType_kCSV = 0,
  ImportRequest_ImportOptions_CopyFileType_kJSON = 1,
  ImportRequest_ImportOptions_CopyFileType_kFVECS = 2,
  ImportRequest_ImportOptions_CopyFileType_ImportRequest_ImportOptions_CopyFileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ImportRequest_ImportOptions_CopyFileType_ImportRequest_ImportOptions_CopyFileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ImportRequest_ImportOptions_CopyFileType_IsValid(int value);
constexpr ImportRequest_ImportOptions_CopyFileType ImportRequest_ImportOptions_CopyFileType_CopyFileType_MIN = ImportRequest_ImportOptions_CopyFileType_kCSV;
constexpr ImportRequest_ImportOptions_CopyFileType ImportRequest_ImportOptions_CopyFileType_CopyFileType_MAX = ImportRequest_ImportOptions_CopyFileType_kFVECS;
constexpr int ImportRequest_ImportOptions_CopyFileType_CopyFileType_ARRAYSIZE = ImportRequest_ImportOptions_CopyFileType_CopyFileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImportRequest_ImportOptions_CopyFileType_descriptor();
template<typename T>
inline const std::string& ImportRequest_ImportOptions_CopyFileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImportRequest_ImportOptions_CopyFileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImportRequest_ImportOptions_CopyFileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImportRequest_ImportOptions_CopyFileType_descriptor(), enum_t_value);
}
inline bool ImportRequest_ImportOptions_CopyFileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImportRequest_ImportOptions_CopyFileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImportRequest_ImportOptions_CopyFileType>(
    ImportRequest_ImportOptions_CopyFileType_descriptor(), name, value);
}
enum ConstantExpr_LiteralType : int {
  ConstantExpr_LiteralType_kBoolean = 0,
  ConstantExpr_LiteralType_kDouble = 1,
  ConstantExpr_LiteralType_kString = 2,
  ConstantExpr_LiteralType_kInt64 = 3,
  ConstantExpr_LiteralType_kNull = 4,
  ConstantExpr_LiteralType_kIntegerArray = 5,
  ConstantExpr_LiteralType_kDoubleArray = 6,
  ConstantExpr_LiteralType_ConstantExpr_LiteralType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConstantExpr_LiteralType_ConstantExpr_LiteralType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConstantExpr_LiteralType_IsValid(int value);
constexpr ConstantExpr_LiteralType ConstantExpr_LiteralType_LiteralType_MIN = ConstantExpr_LiteralType_kBoolean;
constexpr ConstantExpr_LiteralType ConstantExpr_LiteralType_LiteralType_MAX = ConstantExpr_LiteralType_kDoubleArray;
constexpr int ConstantExpr_LiteralType_LiteralType_ARRAYSIZE = ConstantExpr_LiteralType_LiteralType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConstantExpr_LiteralType_descriptor();
template<typename T>
inline const std::string& ConstantExpr_LiteralType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConstantExpr_LiteralType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConstantExpr_LiteralType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConstantExpr_LiteralType_descriptor(), enum_t_value);
}
inline bool ConstantExpr_LiteralType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConstantExpr_LiteralType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConstantExpr_LiteralType>(
    ConstantExpr_LiteralType_descriptor(), name, value);
}
enum KnnExpr_KnnDistanceType : int {
  KnnExpr_KnnDistanceType_L2 = 0,
  KnnExpr_KnnDistanceType_Cosine = 1,
  KnnExpr_KnnDistanceType_InnerProduct = 2,
  KnnExpr_KnnDistanceType_Hamming = 3,
  KnnExpr_KnnDistanceType_KnnExpr_KnnDistanceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KnnExpr_KnnDistanceType_KnnExpr_KnnDistanceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KnnExpr_KnnDistanceType_IsValid(int value);
constexpr KnnExpr_KnnDistanceType KnnExpr_KnnDistanceType_KnnDistanceType_MIN = KnnExpr_KnnDistanceType_L2;
constexpr KnnExpr_KnnDistanceType KnnExpr_KnnDistanceType_KnnDistanceType_MAX = KnnExpr_KnnDistanceType_Hamming;
constexpr int KnnExpr_KnnDistanceType_KnnDistanceType_ARRAYSIZE = KnnExpr_KnnDistanceType_KnnDistanceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KnnExpr_KnnDistanceType_descriptor();
template<typename T>
inline const std::string& KnnExpr_KnnDistanceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KnnExpr_KnnDistanceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KnnExpr_KnnDistanceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KnnExpr_KnnDistanceType_descriptor(), enum_t_value);
}
inline bool KnnExpr_KnnDistanceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KnnExpr_KnnDistanceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KnnExpr_KnnDistanceType>(
    KnnExpr_KnnDistanceType_descriptor(), name, value);
}
enum KnnExpr_EmbeddingDataType : int {
  KnnExpr_EmbeddingDataType_ElemBool = 0,
  KnnExpr_EmbeddingDataType_ElemTinyInt = 1,
  KnnExpr_EmbeddingDataType_ElemSmallInt = 2,
  KnnExpr_EmbeddingDataType_ElemInteger = 3,
  KnnExpr_EmbeddingDataType_ElemBigInt = 4,
  KnnExpr_EmbeddingDataType_ElemFloat = 7,
  KnnExpr_EmbeddingDataType_ElemDouble = 8,
  KnnExpr_EmbeddingDataType_KnnExpr_EmbeddingDataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KnnExpr_EmbeddingDataType_KnnExpr_EmbeddingDataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KnnExpr_EmbeddingDataType_IsValid(int value);
constexpr KnnExpr_EmbeddingDataType KnnExpr_EmbeddingDataType_EmbeddingDataType_MIN = KnnExpr_EmbeddingDataType_ElemBool;
constexpr KnnExpr_EmbeddingDataType KnnExpr_EmbeddingDataType_EmbeddingDataType_MAX = KnnExpr_EmbeddingDataType_ElemDouble;
constexpr int KnnExpr_EmbeddingDataType_EmbeddingDataType_ARRAYSIZE = KnnExpr_EmbeddingDataType_EmbeddingDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KnnExpr_EmbeddingDataType_descriptor();
template<typename T>
inline const std::string& KnnExpr_EmbeddingDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KnnExpr_EmbeddingDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KnnExpr_EmbeddingDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KnnExpr_EmbeddingDataType_descriptor(), enum_t_value);
}
inline bool KnnExpr_EmbeddingDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KnnExpr_EmbeddingDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KnnExpr_EmbeddingDataType>(
    KnnExpr_EmbeddingDataType_descriptor(), name, value);
}
enum LogicType : int {
  Boolean = 0,
  TinyInt = 1,
  SmallInt = 2,
  Integer = 3,
  BigInt = 4,
  HugeInt = 5,
  Decimal = 6,
  Float = 7,
  Double = 8,
  Varchar = 9,
  Embedding = 10,
  Invalid = 11,
  LogicType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LogicType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LogicType_IsValid(int value);
constexpr LogicType LogicType_MIN = Boolean;
constexpr LogicType LogicType_MAX = Invalid;
constexpr int LogicType_ARRAYSIZE = LogicType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogicType_descriptor();
template<typename T>
inline const std::string& LogicType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogicType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogicType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogicType_descriptor(), enum_t_value);
}
inline bool LogicType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogicType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogicType>(
    LogicType_descriptor(), name, value);
}
enum Constraint : int {
  kNull = 0,
  kNotNull = 1,
  kPrimaryKey = 2,
  kUnique = 3,
  Constraint_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Constraint_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Constraint_IsValid(int value);
constexpr Constraint Constraint_MIN = kNull;
constexpr Constraint Constraint_MAX = kUnique;
constexpr int Constraint_ARRAYSIZE = Constraint_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Constraint_descriptor();
template<typename T>
inline const std::string& Constraint_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Constraint>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Constraint_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Constraint_descriptor(), enum_t_value);
}
inline bool Constraint_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Constraint* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Constraint>(
    Constraint_descriptor(), name, value);
}
enum ElementType : int {
  kElemBit = 0,
  kElemInt8 = 2,
  kElemInt16 = 3,
  kElemInt32 = 4,
  kElemInt64 = 7,
  kElemFloat = 8,
  kElemDouble = 9,
  ElementType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ElementType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ElementType_IsValid(int value);
constexpr ElementType ElementType_MIN = kElemBit;
constexpr ElementType ElementType_MAX = kElemDouble;
constexpr int ElementType_ARRAYSIZE = ElementType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ElementType_descriptor();
template<typename T>
inline const std::string& ElementType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ElementType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ElementType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ElementType_descriptor(), enum_t_value);
}
inline bool ElementType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ElementType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ElementType>(
    ElementType_descriptor(), name, value);
}
enum ColumnType : int {
  kColumnBool = 0,
  kColumnInt8 = 1,
  kColumnInt16 = 2,
  kColumnInt32 = 3,
  kColumnInt64 = 4,
  kColumnFloat = 5,
  kColumnDouble = 6,
  kColumnVarchar = 10,
  kColumnEmbedding = 11,
  kColumnInvalid = 12,
  ColumnType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ColumnType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ColumnType_IsValid(int value);
constexpr ColumnType ColumnType_MIN = kColumnBool;
constexpr ColumnType ColumnType_MAX = kColumnInvalid;
constexpr int ColumnType_ARRAYSIZE = ColumnType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColumnType_descriptor();
template<typename T>
inline const std::string& ColumnType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColumnType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColumnType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColumnType_descriptor(), enum_t_value);
}
inline bool ColumnType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColumnType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColumnType>(
    ColumnType_descriptor(), name, value);
}
// ===================================================================

class Options final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.Options) */ {
 public:
  inline Options() : Options(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Options(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Options(const Options& from);
  Options(Options&& from) noexcept
    : Options() {
    *this = ::std::move(from);
  }

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }
  inline Options& operator=(Options&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Options& default_instance() {
    return *internal_default_instance();
  }
  static inline const Options* internal_default_instance() {
    return reinterpret_cast<const Options*>(
               &_Options_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Options& a, Options& b) {
    a.Swap(&b);
  }
  inline void Swap(Options* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Options* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Options* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Options>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Options& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Options& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.Options";
  }
  protected:
  explicit Options(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.Options)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class CreateDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.CreateDatabaseRequest) */ {
 public:
  inline CreateDatabaseRequest() : CreateDatabaseRequest(nullptr) {}
  ~CreateDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDatabaseRequest(const CreateDatabaseRequest& from);
  CreateDatabaseRequest(CreateDatabaseRequest&& from) noexcept
    : CreateDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline CreateDatabaseRequest& operator=(const CreateDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDatabaseRequest& operator=(CreateDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDatabaseRequest*>(
               &_CreateDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateDatabaseRequest& a, CreateDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateDatabaseRequest& from) {
    CreateDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.CreateDatabaseRequest";
  }
  protected:
  explicit CreateDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kOptionsFieldNumber = 2,
    kSessionIdFieldNumber = 3,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // .infinity_grpc_proto.Options options = 2;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::infinity_grpc_proto::Options& options() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::Options* release_options();
  ::infinity_grpc_proto::Options* mutable_options();
  void set_allocated_options(::infinity_grpc_proto::Options* options);
  private:
  const ::infinity_grpc_proto::Options& _internal_options() const;
  ::infinity_grpc_proto::Options* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::infinity_grpc_proto::Options* options);
  ::infinity_grpc_proto::Options* unsafe_arena_release_options();

  // uint64 session_id = 3;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.CreateDatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::infinity_grpc_proto::Options* options_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DropDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DropDatabaseRequest) */ {
 public:
  inline DropDatabaseRequest() : DropDatabaseRequest(nullptr) {}
  ~DropDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR DropDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropDatabaseRequest(const DropDatabaseRequest& from);
  DropDatabaseRequest(DropDatabaseRequest&& from) noexcept
    : DropDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline DropDatabaseRequest& operator=(const DropDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropDatabaseRequest& operator=(DropDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const DropDatabaseRequest*>(
               &_DropDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DropDatabaseRequest& a, DropDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropDatabaseRequest& from) {
    DropDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DropDatabaseRequest";
  }
  protected:
  explicit DropDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kOptionsFieldNumber = 2,
    kSessionIdFieldNumber = 3,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // .infinity_grpc_proto.Options options = 2;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::infinity_grpc_proto::Options& options() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::Options* release_options();
  ::infinity_grpc_proto::Options* mutable_options();
  void set_allocated_options(::infinity_grpc_proto::Options* options);
  private:
  const ::infinity_grpc_proto::Options& _internal_options() const;
  ::infinity_grpc_proto::Options* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::infinity_grpc_proto::Options* options);
  ::infinity_grpc_proto::Options* unsafe_arena_release_options();

  // uint64 session_id = 3;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DropDatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::infinity_grpc_proto::Options* options_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class CreateTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.CreateTableRequest) */ {
 public:
  inline CreateTableRequest() : CreateTableRequest(nullptr) {}
  ~CreateTableRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableRequest(const CreateTableRequest& from);
  CreateTableRequest(CreateTableRequest&& from) noexcept
    : CreateTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableRequest& operator=(CreateTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTableRequest*>(
               &_CreateTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateTableRequest& a, CreateTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableRequest& from) {
    CreateTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.CreateTableRequest";
  }
  protected:
  explicit CreateTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefsFieldNumber = 3,
    kDbNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kOptionsFieldNumber = 5,
    kSessionIdFieldNumber = 6,
  };
  // repeated .infinity_grpc_proto.ColumnDef column_defs = 3;
  int column_defs_size() const;
  private:
  int _internal_column_defs_size() const;
  public:
  void clear_column_defs();
  ::infinity_grpc_proto::ColumnDef* mutable_column_defs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef >*
      mutable_column_defs();
  private:
  const ::infinity_grpc_proto::ColumnDef& _internal_column_defs(int index) const;
  ::infinity_grpc_proto::ColumnDef* _internal_add_column_defs();
  public:
  const ::infinity_grpc_proto::ColumnDef& column_defs(int index) const;
  ::infinity_grpc_proto::ColumnDef* add_column_defs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef >&
      column_defs() const;

  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .infinity_grpc_proto.Options options = 5;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::infinity_grpc_proto::Options& options() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::Options* release_options();
  ::infinity_grpc_proto::Options* mutable_options();
  void set_allocated_options(::infinity_grpc_proto::Options* options);
  private:
  const ::infinity_grpc_proto::Options& _internal_options() const;
  ::infinity_grpc_proto::Options* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::infinity_grpc_proto::Options* options);
  ::infinity_grpc_proto::Options* unsafe_arena_release_options();

  // uint64 session_id = 6;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.CreateTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef > column_defs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::infinity_grpc_proto::Options* options_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ColumnConstraint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ColumnConstraint) */ {
 public:
  inline ColumnConstraint() : ColumnConstraint(nullptr) {}
  ~ColumnConstraint() override;
  explicit PROTOBUF_CONSTEXPR ColumnConstraint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnConstraint(const ColumnConstraint& from);
  ColumnConstraint(ColumnConstraint&& from) noexcept
    : ColumnConstraint() {
    *this = ::std::move(from);
  }

  inline ColumnConstraint& operator=(const ColumnConstraint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnConstraint& operator=(ColumnConstraint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnConstraint& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnConstraint* internal_default_instance() {
    return reinterpret_cast<const ColumnConstraint*>(
               &_ColumnConstraint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ColumnConstraint& a, ColumnConstraint& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnConstraint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnConstraint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnConstraint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnConstraint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnConstraint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnConstraint& from) {
    ColumnConstraint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnConstraint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ColumnConstraint";
  }
  protected:
  explicit ColumnConstraint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstraintFieldNumber = 2,
    kColumnNameFieldNumber = 1,
  };
  // repeated .infinity_grpc_proto.Constraint constraint = 2;
  int constraint_size() const;
  private:
  int _internal_constraint_size() const;
  public:
  void clear_constraint();
  private:
  ::infinity_grpc_proto::Constraint _internal_constraint(int index) const;
  void _internal_add_constraint(::infinity_grpc_proto::Constraint value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_constraint();
  public:
  ::infinity_grpc_proto::Constraint constraint(int index) const;
  void set_constraint(int index, ::infinity_grpc_proto::Constraint value);
  void add_constraint(::infinity_grpc_proto::Constraint value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& constraint() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_constraint();

  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ColumnConstraint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> constraint_;
    mutable std::atomic<int> _constraint_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ColumnDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ColumnDef) */ {
 public:
  inline ColumnDef() : ColumnDef(nullptr) {}
  ~ColumnDef() override;
  explicit PROTOBUF_CONSTEXPR ColumnDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnDef(const ColumnDef& from);
  ColumnDef(ColumnDef&& from) noexcept
    : ColumnDef() {
    *this = ::std::move(from);
  }

  inline ColumnDef& operator=(const ColumnDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnDef& operator=(ColumnDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnDef* internal_default_instance() {
    return reinterpret_cast<const ColumnDef*>(
               &_ColumnDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ColumnDef& a, ColumnDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnDef& from) {
    ColumnDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ColumnDef";
  }
  protected:
  explicit ColumnDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstraintsFieldNumber = 4,
    kNameFieldNumber = 2,
    kColumnTypeFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated .infinity_grpc_proto.Constraint constraints = 4;
  int constraints_size() const;
  private:
  int _internal_constraints_size() const;
  public:
  void clear_constraints();
  private:
  ::infinity_grpc_proto::Constraint _internal_constraints(int index) const;
  void _internal_add_constraints(::infinity_grpc_proto::Constraint value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_constraints();
  public:
  ::infinity_grpc_proto::Constraint constraints(int index) const;
  void set_constraints(int index, ::infinity_grpc_proto::Constraint value);
  void add_constraints(::infinity_grpc_proto::Constraint value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& constraints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_constraints();

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .infinity_grpc_proto.DataType column_type = 3;
  bool has_column_type() const;
  private:
  bool _internal_has_column_type() const;
  public:
  void clear_column_type();
  const ::infinity_grpc_proto::DataType& column_type() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::DataType* release_column_type();
  ::infinity_grpc_proto::DataType* mutable_column_type();
  void set_allocated_column_type(::infinity_grpc_proto::DataType* column_type);
  private:
  const ::infinity_grpc_proto::DataType& _internal_column_type() const;
  ::infinity_grpc_proto::DataType* _internal_mutable_column_type();
  public:
  void unsafe_arena_set_allocated_column_type(
      ::infinity_grpc_proto::DataType* column_type);
  ::infinity_grpc_proto::DataType* unsafe_arena_release_column_type();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ColumnDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> constraints_;
    mutable std::atomic<int> _constraints_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::infinity_grpc_proto::DataType* column_type_;
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DataType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DataType) */ {
 public:
  inline DataType() : DataType(nullptr) {}
  ~DataType() override;
  explicit PROTOBUF_CONSTEXPR DataType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataType(const DataType& from);
  DataType(DataType&& from) noexcept
    : DataType() {
    *this = ::std::move(from);
  }

  inline DataType& operator=(const DataType& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataType& operator=(DataType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataType& default_instance() {
    return *internal_default_instance();
  }
  enum PhysicalTypeCase {
    kNumberType = 2,
    kVarcharType = 3,
    kEmbeddingType = 4,
    PHYSICALTYPE_NOT_SET = 0,
  };

  static inline const DataType* internal_default_instance() {
    return reinterpret_cast<const DataType*>(
               &_DataType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DataType& a, DataType& b) {
    a.Swap(&b);
  }
  inline void Swap(DataType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataType& from) {
    DataType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DataType";
  }
  protected:
  explicit DataType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogicTypeFieldNumber = 1,
    kNumberTypeFieldNumber = 2,
    kVarcharTypeFieldNumber = 3,
    kEmbeddingTypeFieldNumber = 4,
  };
  // .infinity_grpc_proto.LogicType logic_type = 1;
  void clear_logic_type();
  ::infinity_grpc_proto::LogicType logic_type() const;
  void set_logic_type(::infinity_grpc_proto::LogicType value);
  private:
  ::infinity_grpc_proto::LogicType _internal_logic_type() const;
  void _internal_set_logic_type(::infinity_grpc_proto::LogicType value);
  public:

  // .infinity_grpc_proto.NumberType number_type = 2;
  bool has_number_type() const;
  private:
  bool _internal_has_number_type() const;
  public:
  void clear_number_type();
  const ::infinity_grpc_proto::NumberType& number_type() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::NumberType* release_number_type();
  ::infinity_grpc_proto::NumberType* mutable_number_type();
  void set_allocated_number_type(::infinity_grpc_proto::NumberType* number_type);
  private:
  const ::infinity_grpc_proto::NumberType& _internal_number_type() const;
  ::infinity_grpc_proto::NumberType* _internal_mutable_number_type();
  public:
  void unsafe_arena_set_allocated_number_type(
      ::infinity_grpc_proto::NumberType* number_type);
  ::infinity_grpc_proto::NumberType* unsafe_arena_release_number_type();

  // .infinity_grpc_proto.VarcharType varchar_type = 3;
  bool has_varchar_type() const;
  private:
  bool _internal_has_varchar_type() const;
  public:
  void clear_varchar_type();
  const ::infinity_grpc_proto::VarcharType& varchar_type() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::VarcharType* release_varchar_type();
  ::infinity_grpc_proto::VarcharType* mutable_varchar_type();
  void set_allocated_varchar_type(::infinity_grpc_proto::VarcharType* varchar_type);
  private:
  const ::infinity_grpc_proto::VarcharType& _internal_varchar_type() const;
  ::infinity_grpc_proto::VarcharType* _internal_mutable_varchar_type();
  public:
  void unsafe_arena_set_allocated_varchar_type(
      ::infinity_grpc_proto::VarcharType* varchar_type);
  ::infinity_grpc_proto::VarcharType* unsafe_arena_release_varchar_type();

  // .infinity_grpc_proto.EmbeddingType embedding_type = 4;
  bool has_embedding_type() const;
  private:
  bool _internal_has_embedding_type() const;
  public:
  void clear_embedding_type();
  const ::infinity_grpc_proto::EmbeddingType& embedding_type() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::EmbeddingType* release_embedding_type();
  ::infinity_grpc_proto::EmbeddingType* mutable_embedding_type();
  void set_allocated_embedding_type(::infinity_grpc_proto::EmbeddingType* embedding_type);
  private:
  const ::infinity_grpc_proto::EmbeddingType& _internal_embedding_type() const;
  ::infinity_grpc_proto::EmbeddingType* _internal_mutable_embedding_type();
  public:
  void unsafe_arena_set_allocated_embedding_type(
      ::infinity_grpc_proto::EmbeddingType* embedding_type);
  ::infinity_grpc_proto::EmbeddingType* unsafe_arena_release_embedding_type();

  void clear_PhysicalType();
  PhysicalTypeCase PhysicalType_case() const;
  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DataType)
 private:
  class _Internal;
  void set_has_number_type();
  void set_has_varchar_type();
  void set_has_embedding_type();

  inline bool has_PhysicalType() const;
  inline void clear_has_PhysicalType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int logic_type_;
    union PhysicalTypeUnion {
      constexpr PhysicalTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::infinity_grpc_proto::NumberType* number_type_;
      ::infinity_grpc_proto::VarcharType* varchar_type_;
      ::infinity_grpc_proto::EmbeddingType* embedding_type_;
    } PhysicalType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class EmbeddingType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.EmbeddingType) */ {
 public:
  inline EmbeddingType() : EmbeddingType(nullptr) {}
  ~EmbeddingType() override;
  explicit PROTOBUF_CONSTEXPR EmbeddingType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmbeddingType(const EmbeddingType& from);
  EmbeddingType(EmbeddingType&& from) noexcept
    : EmbeddingType() {
    *this = ::std::move(from);
  }

  inline EmbeddingType& operator=(const EmbeddingType& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmbeddingType& operator=(EmbeddingType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmbeddingType& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmbeddingType* internal_default_instance() {
    return reinterpret_cast<const EmbeddingType*>(
               &_EmbeddingType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EmbeddingType& a, EmbeddingType& b) {
    a.Swap(&b);
  }
  inline void Swap(EmbeddingType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmbeddingType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmbeddingType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmbeddingType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmbeddingType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EmbeddingType& from) {
    EmbeddingType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmbeddingType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.EmbeddingType";
  }
  protected:
  explicit EmbeddingType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmbeddingDataTypeFieldNumber = 1,
    kDimensionFieldNumber = 2,
  };
  // .infinity_grpc_proto.ElementType embedding_data_type = 1;
  void clear_embedding_data_type();
  ::infinity_grpc_proto::ElementType embedding_data_type() const;
  void set_embedding_data_type(::infinity_grpc_proto::ElementType value);
  private:
  ::infinity_grpc_proto::ElementType _internal_embedding_data_type() const;
  void _internal_set_embedding_data_type(::infinity_grpc_proto::ElementType value);
  public:

  // int32 dimension = 2;
  void clear_dimension();
  int32_t dimension() const;
  void set_dimension(int32_t value);
  private:
  int32_t _internal_dimension() const;
  void _internal_set_dimension(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.EmbeddingType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int embedding_data_type_;
    int32_t dimension_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class VarcharType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.VarcharType) */ {
 public:
  inline VarcharType() : VarcharType(nullptr) {}
  ~VarcharType() override;
  explicit PROTOBUF_CONSTEXPR VarcharType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VarcharType(const VarcharType& from);
  VarcharType(VarcharType&& from) noexcept
    : VarcharType() {
    *this = ::std::move(from);
  }

  inline VarcharType& operator=(const VarcharType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VarcharType& operator=(VarcharType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VarcharType& default_instance() {
    return *internal_default_instance();
  }
  static inline const VarcharType* internal_default_instance() {
    return reinterpret_cast<const VarcharType*>(
               &_VarcharType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(VarcharType& a, VarcharType& b) {
    a.Swap(&b);
  }
  inline void Swap(VarcharType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VarcharType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VarcharType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VarcharType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VarcharType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VarcharType& from) {
    VarcharType::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarcharType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.VarcharType";
  }
  protected:
  explicit VarcharType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
  };
  // int32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.VarcharType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class NumberType final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.NumberType) */ {
 public:
  inline NumberType() : NumberType(nullptr) {}
  explicit PROTOBUF_CONSTEXPR NumberType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NumberType(const NumberType& from);
  NumberType(NumberType&& from) noexcept
    : NumberType() {
    *this = ::std::move(from);
  }

  inline NumberType& operator=(const NumberType& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumberType& operator=(NumberType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumberType& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumberType* internal_default_instance() {
    return reinterpret_cast<const NumberType*>(
               &_NumberType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NumberType& a, NumberType& b) {
    a.Swap(&b);
  }
  inline void Swap(NumberType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumberType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NumberType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NumberType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NumberType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NumberType& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.NumberType";
  }
  protected:
  explicit NumberType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.NumberType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DropTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DropTableRequest) */ {
 public:
  inline DropTableRequest() : DropTableRequest(nullptr) {}
  ~DropTableRequest() override;
  explicit PROTOBUF_CONSTEXPR DropTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropTableRequest(const DropTableRequest& from);
  DropTableRequest(DropTableRequest&& from) noexcept
    : DropTableRequest() {
    *this = ::std::move(from);
  }

  inline DropTableRequest& operator=(const DropTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropTableRequest& operator=(DropTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropTableRequest* internal_default_instance() {
    return reinterpret_cast<const DropTableRequest*>(
               &_DropTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DropTableRequest& a, DropTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropTableRequest& from) {
    DropTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DropTableRequest";
  }
  protected:
  explicit DropTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kOptionsFieldNumber = 3,
    kSessionIdFieldNumber = 4,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .infinity_grpc_proto.Options options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::infinity_grpc_proto::Options& options() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::Options* release_options();
  ::infinity_grpc_proto::Options* mutable_options();
  void set_allocated_options(::infinity_grpc_proto::Options* options);
  private:
  const ::infinity_grpc_proto::Options& _internal_options() const;
  ::infinity_grpc_proto::Options* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::infinity_grpc_proto::Options* options);
  ::infinity_grpc_proto::Options* unsafe_arena_release_options();

  // uint64 session_id = 4;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DropTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::infinity_grpc_proto::Options* options_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class InsertRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.InsertRequest) */ {
 public:
  inline InsertRequest() : InsertRequest(nullptr) {}
  ~InsertRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRequest(const InsertRequest& from);
  InsertRequest(InsertRequest&& from) noexcept
    : InsertRequest() {
    *this = ::std::move(from);
  }

  inline InsertRequest& operator=(const InsertRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRequest& operator=(InsertRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRequest*>(
               &_InsertRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(InsertRequest& a, InsertRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRequest& from) {
    InsertRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.InsertRequest";
  }
  protected:
  explicit InsertRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 3,
    kFieldsFieldNumber = 4,
    kDbNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kSessionIdFieldNumber = 5,
  };
  // repeated string column_names = 3;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // repeated .infinity_grpc_proto.Field fields = 4;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::infinity_grpc_proto::Field* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::Field >*
      mutable_fields();
  private:
  const ::infinity_grpc_proto::Field& _internal_fields(int index) const;
  ::infinity_grpc_proto::Field* _internal_add_fields();
  public:
  const ::infinity_grpc_proto::Field& fields(int index) const;
  ::infinity_grpc_proto::Field* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::Field >&
      fields() const;

  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // uint64 session_id = 5;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.InsertRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::Field > fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class Field final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.Field) */ {
 public:
  inline Field() : Field(nullptr) {}
  ~Field() override;
  explicit PROTOBUF_CONSTEXPR Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Field(const Field& from);
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Field& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Field& from) {
    Field::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.Field";
  }
  protected:
  explicit Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParseExprsFieldNumber = 1,
  };
  // repeated .infinity_grpc_proto.ParsedExpr parse_exprs = 1;
  int parse_exprs_size() const;
  private:
  int _internal_parse_exprs_size() const;
  public:
  void clear_parse_exprs();
  ::infinity_grpc_proto::ParsedExpr* mutable_parse_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
      mutable_parse_exprs();
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_parse_exprs(int index) const;
  ::infinity_grpc_proto::ParsedExpr* _internal_add_parse_exprs();
  public:
  const ::infinity_grpc_proto::ParsedExpr& parse_exprs(int index) const;
  ::infinity_grpc_proto::ParsedExpr* add_parse_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
      parse_exprs() const;

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr > parse_exprs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ImportRequest_ImportOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ImportRequest.ImportOptions) */ {
 public:
  inline ImportRequest_ImportOptions() : ImportRequest_ImportOptions(nullptr) {}
  ~ImportRequest_ImportOptions() override;
  explicit PROTOBUF_CONSTEXPR ImportRequest_ImportOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImportRequest_ImportOptions(const ImportRequest_ImportOptions& from);
  ImportRequest_ImportOptions(ImportRequest_ImportOptions&& from) noexcept
    : ImportRequest_ImportOptions() {
    *this = ::std::move(from);
  }

  inline ImportRequest_ImportOptions& operator=(const ImportRequest_ImportOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportRequest_ImportOptions& operator=(ImportRequest_ImportOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportRequest_ImportOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportRequest_ImportOptions* internal_default_instance() {
    return reinterpret_cast<const ImportRequest_ImportOptions*>(
               &_ImportRequest_ImportOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ImportRequest_ImportOptions& a, ImportRequest_ImportOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportRequest_ImportOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportRequest_ImportOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImportRequest_ImportOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImportRequest_ImportOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImportRequest_ImportOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImportRequest_ImportOptions& from) {
    ImportRequest_ImportOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportRequest_ImportOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ImportRequest.ImportOptions";
  }
  protected:
  explicit ImportRequest_ImportOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImportRequest_ImportOptions_CopyFileType CopyFileType;
  static constexpr CopyFileType kCSV =
    ImportRequest_ImportOptions_CopyFileType_kCSV;
  static constexpr CopyFileType kJSON =
    ImportRequest_ImportOptions_CopyFileType_kJSON;
  static constexpr CopyFileType kFVECS =
    ImportRequest_ImportOptions_CopyFileType_kFVECS;
  static inline bool CopyFileType_IsValid(int value) {
    return ImportRequest_ImportOptions_CopyFileType_IsValid(value);
  }
  static constexpr CopyFileType CopyFileType_MIN =
    ImportRequest_ImportOptions_CopyFileType_CopyFileType_MIN;
  static constexpr CopyFileType CopyFileType_MAX =
    ImportRequest_ImportOptions_CopyFileType_CopyFileType_MAX;
  static constexpr int CopyFileType_ARRAYSIZE =
    ImportRequest_ImportOptions_CopyFileType_CopyFileType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CopyFileType_descriptor() {
    return ImportRequest_ImportOptions_CopyFileType_descriptor();
  }
  template<typename T>
  static inline const std::string& CopyFileType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CopyFileType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CopyFileType_Name.");
    return ImportRequest_ImportOptions_CopyFileType_Name(enum_t_value);
  }
  static inline bool CopyFileType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CopyFileType* value) {
    return ImportRequest_ImportOptions_CopyFileType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDelimiterFieldNumber = 1,
    kFileTypeFieldNumber = 2,
    kTableNameFieldNumber = 3,
    kSchemaNameFieldNumber = 4,
    kCopyFromFieldNumber = 5,
    kHasHeaderFieldNumber = 6,
  };
  // string delimiter = 1;
  void clear_delimiter();
  const std::string& delimiter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delimiter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delimiter();
  PROTOBUF_NODISCARD std::string* release_delimiter();
  void set_allocated_delimiter(std::string* delimiter);
  private:
  const std::string& _internal_delimiter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delimiter(const std::string& value);
  std::string* _internal_mutable_delimiter();
  public:

  // string file_type = 2;
  void clear_file_type();
  const std::string& file_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_type();
  PROTOBUF_NODISCARD std::string* release_file_type();
  void set_allocated_file_type(std::string* file_type);
  private:
  const std::string& _internal_file_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_type(const std::string& value);
  std::string* _internal_mutable_file_type();
  public:

  // string table_name = 3;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string schema_name = 4;
  void clear_schema_name();
  const std::string& schema_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_name();
  PROTOBUF_NODISCARD std::string* release_schema_name();
  void set_allocated_schema_name(std::string* schema_name);
  private:
  const std::string& _internal_schema_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_name(const std::string& value);
  std::string* _internal_mutable_schema_name();
  public:

  // bool copy_from = 5;
  void clear_copy_from();
  bool copy_from() const;
  void set_copy_from(bool value);
  private:
  bool _internal_copy_from() const;
  void _internal_set_copy_from(bool value);
  public:

  // bool has_header = 6;
  void clear_has_header();
  bool has_header() const;
  void set_has_header(bool value);
  private:
  bool _internal_has_header() const;
  void _internal_set_has_header(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ImportRequest.ImportOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delimiter_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_name_;
    bool copy_from_;
    bool has_header_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ImportRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ImportRequest) */ {
 public:
  inline ImportRequest() : ImportRequest(nullptr) {}
  ~ImportRequest() override;
  explicit PROTOBUF_CONSTEXPR ImportRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ImportRequest(const ImportRequest& from);
  ImportRequest(ImportRequest&& from) noexcept
    : ImportRequest() {
    *this = ::std::move(from);
  }

  inline ImportRequest& operator=(const ImportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImportRequest& operator=(ImportRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImportRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImportRequest* internal_default_instance() {
    return reinterpret_cast<const ImportRequest*>(
               &_ImportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ImportRequest& a, ImportRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ImportRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImportRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImportRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ImportRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ImportRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ImportRequest& from) {
    ImportRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ImportRequest";
  }
  protected:
  explicit ImportRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ImportRequest_ImportOptions ImportOptions;

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kFilePathFieldNumber = 3,
    kImportOptionsFieldNumber = 4,
    kSessionIdFieldNumber = 5,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string file_path = 3;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // .infinity_grpc_proto.ImportRequest.ImportOptions import_options = 4;
  bool has_import_options() const;
  private:
  bool _internal_has_import_options() const;
  public:
  void clear_import_options();
  const ::infinity_grpc_proto::ImportRequest_ImportOptions& import_options() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ImportRequest_ImportOptions* release_import_options();
  ::infinity_grpc_proto::ImportRequest_ImportOptions* mutable_import_options();
  void set_allocated_import_options(::infinity_grpc_proto::ImportRequest_ImportOptions* import_options);
  private:
  const ::infinity_grpc_proto::ImportRequest_ImportOptions& _internal_import_options() const;
  ::infinity_grpc_proto::ImportRequest_ImportOptions* _internal_mutable_import_options();
  public:
  void unsafe_arena_set_allocated_import_options(
      ::infinity_grpc_proto::ImportRequest_ImportOptions* import_options);
  ::infinity_grpc_proto::ImportRequest_ImportOptions* unsafe_arena_release_import_options();

  // uint64 session_id = 5;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ImportRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
    ::infinity_grpc_proto::ImportRequest_ImportOptions* import_options_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ParsedExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ParsedExpr) */ {
 public:
  inline ParsedExpr() : ParsedExpr(nullptr) {}
  ~ParsedExpr() override;
  explicit PROTOBUF_CONSTEXPR ParsedExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParsedExpr(const ParsedExpr& from);
  ParsedExpr(ParsedExpr&& from) noexcept
    : ParsedExpr() {
    *this = ::std::move(from);
  }

  inline ParsedExpr& operator=(const ParsedExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParsedExpr& operator=(ParsedExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParsedExpr& default_instance() {
    return *internal_default_instance();
  }
  enum ParsedExprTypeCase {
    kConstantExpr = 2,
    kColumnExpr = 4,
    kFunctionExpr = 5,
    kKnnExpr = 12,
    PARSEDEXPRTYPE_NOT_SET = 0,
  };

  static inline const ParsedExpr* internal_default_instance() {
    return reinterpret_cast<const ParsedExpr*>(
               &_ParsedExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ParsedExpr& a, ParsedExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(ParsedExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParsedExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParsedExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParsedExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParsedExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParsedExpr& from) {
    ParsedExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParsedExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ParsedExpr";
  }
  protected:
  explicit ParsedExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliasFieldNumber = 1,
    kConstantExprFieldNumber = 2,
    kColumnExprFieldNumber = 4,
    kFunctionExprFieldNumber = 5,
    kKnnExprFieldNumber = 12,
  };
  // string alias = 1;
  void clear_alias();
  const std::string& alias() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_alias(ArgT0&& arg0, ArgT... args);
  std::string* mutable_alias();
  PROTOBUF_NODISCARD std::string* release_alias();
  void set_allocated_alias(std::string* alias);
  private:
  const std::string& _internal_alias() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_alias(const std::string& value);
  std::string* _internal_mutable_alias();
  public:

  // .infinity_grpc_proto.ConstantExpr constant_expr = 2;
  bool has_constant_expr() const;
  private:
  bool _internal_has_constant_expr() const;
  public:
  void clear_constant_expr();
  const ::infinity_grpc_proto::ConstantExpr& constant_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ConstantExpr* release_constant_expr();
  ::infinity_grpc_proto::ConstantExpr* mutable_constant_expr();
  void set_allocated_constant_expr(::infinity_grpc_proto::ConstantExpr* constant_expr);
  private:
  const ::infinity_grpc_proto::ConstantExpr& _internal_constant_expr() const;
  ::infinity_grpc_proto::ConstantExpr* _internal_mutable_constant_expr();
  public:
  void unsafe_arena_set_allocated_constant_expr(
      ::infinity_grpc_proto::ConstantExpr* constant_expr);
  ::infinity_grpc_proto::ConstantExpr* unsafe_arena_release_constant_expr();

  // .infinity_grpc_proto.ColumnExpr column_expr = 4;
  bool has_column_expr() const;
  private:
  bool _internal_has_column_expr() const;
  public:
  void clear_column_expr();
  const ::infinity_grpc_proto::ColumnExpr& column_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ColumnExpr* release_column_expr();
  ::infinity_grpc_proto::ColumnExpr* mutable_column_expr();
  void set_allocated_column_expr(::infinity_grpc_proto::ColumnExpr* column_expr);
  private:
  const ::infinity_grpc_proto::ColumnExpr& _internal_column_expr() const;
  ::infinity_grpc_proto::ColumnExpr* _internal_mutable_column_expr();
  public:
  void unsafe_arena_set_allocated_column_expr(
      ::infinity_grpc_proto::ColumnExpr* column_expr);
  ::infinity_grpc_proto::ColumnExpr* unsafe_arena_release_column_expr();

  // .infinity_grpc_proto.FunctionExpr function_expr = 5;
  bool has_function_expr() const;
  private:
  bool _internal_has_function_expr() const;
  public:
  void clear_function_expr();
  const ::infinity_grpc_proto::FunctionExpr& function_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::FunctionExpr* release_function_expr();
  ::infinity_grpc_proto::FunctionExpr* mutable_function_expr();
  void set_allocated_function_expr(::infinity_grpc_proto::FunctionExpr* function_expr);
  private:
  const ::infinity_grpc_proto::FunctionExpr& _internal_function_expr() const;
  ::infinity_grpc_proto::FunctionExpr* _internal_mutable_function_expr();
  public:
  void unsafe_arena_set_allocated_function_expr(
      ::infinity_grpc_proto::FunctionExpr* function_expr);
  ::infinity_grpc_proto::FunctionExpr* unsafe_arena_release_function_expr();

  // .infinity_grpc_proto.KnnExpr knn_expr = 12;
  bool has_knn_expr() const;
  private:
  bool _internal_has_knn_expr() const;
  public:
  void clear_knn_expr();
  const ::infinity_grpc_proto::KnnExpr& knn_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::KnnExpr* release_knn_expr();
  ::infinity_grpc_proto::KnnExpr* mutable_knn_expr();
  void set_allocated_knn_expr(::infinity_grpc_proto::KnnExpr* knn_expr);
  private:
  const ::infinity_grpc_proto::KnnExpr& _internal_knn_expr() const;
  ::infinity_grpc_proto::KnnExpr* _internal_mutable_knn_expr();
  public:
  void unsafe_arena_set_allocated_knn_expr(
      ::infinity_grpc_proto::KnnExpr* knn_expr);
  ::infinity_grpc_proto::KnnExpr* unsafe_arena_release_knn_expr();

  void clear_ParsedExprType();
  ParsedExprTypeCase ParsedExprType_case() const;
  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ParsedExpr)
 private:
  class _Internal;
  void set_has_constant_expr();
  void set_has_column_expr();
  void set_has_function_expr();
  void set_has_knn_expr();

  inline bool has_ParsedExprType() const;
  inline void clear_has_ParsedExprType();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr alias_;
    union ParsedExprTypeUnion {
      constexpr ParsedExprTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::infinity_grpc_proto::ConstantExpr* constant_expr_;
      ::infinity_grpc_proto::ColumnExpr* column_expr_;
      ::infinity_grpc_proto::FunctionExpr* function_expr_;
      ::infinity_grpc_proto::KnnExpr* knn_expr_;
    } ParsedExprType_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ConstantExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ConstantExpr) */ {
 public:
  inline ConstantExpr() : ConstantExpr(nullptr) {}
  ~ConstantExpr() override;
  explicit PROTOBUF_CONSTEXPR ConstantExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstantExpr(const ConstantExpr& from);
  ConstantExpr(ConstantExpr&& from) noexcept
    : ConstantExpr() {
    *this = ::std::move(from);
  }

  inline ConstantExpr& operator=(const ConstantExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstantExpr& operator=(ConstantExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstantExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstantExpr* internal_default_instance() {
    return reinterpret_cast<const ConstantExpr*>(
               &_ConstantExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ConstantExpr& a, ConstantExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstantExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstantExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstantExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstantExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstantExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConstantExpr& from) {
    ConstantExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstantExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ConstantExpr";
  }
  protected:
  explicit ConstantExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ConstantExpr_LiteralType LiteralType;
  static constexpr LiteralType kBoolean =
    ConstantExpr_LiteralType_kBoolean;
  static constexpr LiteralType kDouble =
    ConstantExpr_LiteralType_kDouble;
  static constexpr LiteralType kString =
    ConstantExpr_LiteralType_kString;
  static constexpr LiteralType kInt64 =
    ConstantExpr_LiteralType_kInt64;
  static constexpr LiteralType kNull =
    ConstantExpr_LiteralType_kNull;
  static constexpr LiteralType kIntegerArray =
    ConstantExpr_LiteralType_kIntegerArray;
  static constexpr LiteralType kDoubleArray =
    ConstantExpr_LiteralType_kDoubleArray;
  static inline bool LiteralType_IsValid(int value) {
    return ConstantExpr_LiteralType_IsValid(value);
  }
  static constexpr LiteralType LiteralType_MIN =
    ConstantExpr_LiteralType_LiteralType_MIN;
  static constexpr LiteralType LiteralType_MAX =
    ConstantExpr_LiteralType_LiteralType_MAX;
  static constexpr int LiteralType_ARRAYSIZE =
    ConstantExpr_LiteralType_LiteralType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LiteralType_descriptor() {
    return ConstantExpr_LiteralType_descriptor();
  }
  template<typename T>
  static inline const std::string& LiteralType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LiteralType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LiteralType_Name.");
    return ConstantExpr_LiteralType_Name(enum_t_value);
  }
  static inline bool LiteralType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LiteralType* value) {
    return ConstantExpr_LiteralType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLongArrayFieldNumber = 7,
    kDoubleArrayFieldNumber = 8,
    kStrValueFieldNumber = 5,
    kDateValueFieldNumber = 6,
    kLiteralTypeFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kI64ValueFieldNumber = 3,
    kF64ValueFieldNumber = 4,
  };
  // repeated int64 long_array = 7;
  int long_array_size() const;
  private:
  int _internal_long_array_size() const;
  public:
  void clear_long_array();
  private:
  int64_t _internal_long_array(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_long_array() const;
  void _internal_add_long_array(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_long_array();
  public:
  int64_t long_array(int index) const;
  void set_long_array(int index, int64_t value);
  void add_long_array(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      long_array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_long_array();

  // repeated double double_array = 8;
  int double_array_size() const;
  private:
  int _internal_double_array_size() const;
  public:
  void clear_double_array();
  private:
  double _internal_double_array(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_double_array() const;
  void _internal_add_double_array(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_double_array();
  public:
  double double_array(int index) const;
  void set_double_array(int index, double value);
  void add_double_array(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      double_array() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_double_array();

  // string str_value = 5;
  void clear_str_value();
  const std::string& str_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_value();
  PROTOBUF_NODISCARD std::string* release_str_value();
  void set_allocated_str_value(std::string* str_value);
  private:
  const std::string& _internal_str_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_value(const std::string& value);
  std::string* _internal_mutable_str_value();
  public:

  // string date_value = 6;
  void clear_date_value();
  const std::string& date_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_date_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_date_value();
  PROTOBUF_NODISCARD std::string* release_date_value();
  void set_allocated_date_value(std::string* date_value);
  private:
  const std::string& _internal_date_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_date_value(const std::string& value);
  std::string* _internal_mutable_date_value();
  public:

  // .infinity_grpc_proto.ConstantExpr.LiteralType literal_type = 1;
  void clear_literal_type();
  ::infinity_grpc_proto::ConstantExpr_LiteralType literal_type() const;
  void set_literal_type(::infinity_grpc_proto::ConstantExpr_LiteralType value);
  private:
  ::infinity_grpc_proto::ConstantExpr_LiteralType _internal_literal_type() const;
  void _internal_set_literal_type(::infinity_grpc_proto::ConstantExpr_LiteralType value);
  public:

  // bool bool_value = 2;
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // int64 i64_value = 3;
  void clear_i64_value();
  int64_t i64_value() const;
  void set_i64_value(int64_t value);
  private:
  int64_t _internal_i64_value() const;
  void _internal_set_i64_value(int64_t value);
  public:

  // double f64_value = 4;
  void clear_f64_value();
  double f64_value() const;
  void set_f64_value(double value);
  private:
  double _internal_f64_value() const;
  void _internal_set_f64_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ConstantExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > long_array_;
    mutable std::atomic<int> _long_array_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > double_array_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_value_;
    int literal_type_;
    bool bool_value_;
    int64_t i64_value_;
    double f64_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class FunctionExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.FunctionExpr) */ {
 public:
  inline FunctionExpr() : FunctionExpr(nullptr) {}
  ~FunctionExpr() override;
  explicit PROTOBUF_CONSTEXPR FunctionExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FunctionExpr(const FunctionExpr& from);
  FunctionExpr(FunctionExpr&& from) noexcept
    : FunctionExpr() {
    *this = ::std::move(from);
  }

  inline FunctionExpr& operator=(const FunctionExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline FunctionExpr& operator=(FunctionExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FunctionExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const FunctionExpr* internal_default_instance() {
    return reinterpret_cast<const FunctionExpr*>(
               &_FunctionExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(FunctionExpr& a, FunctionExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(FunctionExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FunctionExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FunctionExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FunctionExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FunctionExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FunctionExpr& from) {
    FunctionExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.FunctionExpr";
  }
  protected:
  explicit FunctionExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 2,
    kFunctionNameFieldNumber = 1,
  };
  // repeated .infinity_grpc_proto.ParsedExpr arguments = 2;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  ::infinity_grpc_proto::ParsedExpr* mutable_arguments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
      mutable_arguments();
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_arguments(int index) const;
  ::infinity_grpc_proto::ParsedExpr* _internal_add_arguments();
  public:
  const ::infinity_grpc_proto::ParsedExpr& arguments(int index) const;
  ::infinity_grpc_proto::ParsedExpr* add_arguments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
      arguments() const;

  // string function_name = 1;
  void clear_function_name();
  const std::string& function_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_function_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_function_name();
  PROTOBUF_NODISCARD std::string* release_function_name();
  void set_allocated_function_name(std::string* function_name);
  private:
  const std::string& _internal_function_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_function_name(const std::string& value);
  std::string* _internal_mutable_function_name();
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.FunctionExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr > arguments_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr function_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ColumnExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ColumnExpr) */ {
 public:
  inline ColumnExpr() : ColumnExpr(nullptr) {}
  ~ColumnExpr() override;
  explicit PROTOBUF_CONSTEXPR ColumnExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnExpr(const ColumnExpr& from);
  ColumnExpr(ColumnExpr&& from) noexcept
    : ColumnExpr() {
    *this = ::std::move(from);
  }

  inline ColumnExpr& operator=(const ColumnExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnExpr& operator=(ColumnExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnExpr* internal_default_instance() {
    return reinterpret_cast<const ColumnExpr*>(
               &_ColumnExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ColumnExpr& a, ColumnExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnExpr& from) {
    ColumnExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ColumnExpr";
  }
  protected:
  explicit ColumnExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kStarFieldNumber = 2,
  };
  // repeated string column_name = 1;
  int column_name_size() const;
  private:
  int _internal_column_name_size() const;
  public:
  void clear_column_name();
  const std::string& column_name(int index) const;
  std::string* mutable_column_name(int index);
  void set_column_name(int index, const std::string& value);
  void set_column_name(int index, std::string&& value);
  void set_column_name(int index, const char* value);
  void set_column_name(int index, const char* value, size_t size);
  std::string* add_column_name();
  void add_column_name(const std::string& value);
  void add_column_name(std::string&& value);
  void add_column_name(const char* value);
  void add_column_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_name();
  private:
  const std::string& _internal_column_name(int index) const;
  std::string* _internal_add_column_name();
  public:

  // bool star = 2;
  void clear_star();
  bool star() const;
  void set_star(bool value);
  private:
  bool _internal_star() const;
  void _internal_set_star(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ColumnExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_name_;
    bool star_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class BetweenExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.BetweenExpr) */ {
 public:
  inline BetweenExpr() : BetweenExpr(nullptr) {}
  ~BetweenExpr() override;
  explicit PROTOBUF_CONSTEXPR BetweenExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BetweenExpr(const BetweenExpr& from);
  BetweenExpr(BetweenExpr&& from) noexcept
    : BetweenExpr() {
    *this = ::std::move(from);
  }

  inline BetweenExpr& operator=(const BetweenExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline BetweenExpr& operator=(BetweenExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BetweenExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const BetweenExpr* internal_default_instance() {
    return reinterpret_cast<const BetweenExpr*>(
               &_BetweenExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BetweenExpr& a, BetweenExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(BetweenExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BetweenExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BetweenExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BetweenExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BetweenExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BetweenExpr& from) {
    BetweenExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BetweenExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.BetweenExpr";
  }
  protected:
  explicit BetweenExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kUpperBoundFieldNumber = 2,
    kLowerBoundFieldNumber = 3,
  };
  // .infinity_grpc_proto.ParsedExpr value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::infinity_grpc_proto::ParsedExpr& value() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_value();
  ::infinity_grpc_proto::ParsedExpr* mutable_value();
  void set_allocated_value(::infinity_grpc_proto::ParsedExpr* value);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_value() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::infinity_grpc_proto::ParsedExpr* value);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_value();

  // .infinity_grpc_proto.ParsedExpr upper_bound = 2;
  bool has_upper_bound() const;
  private:
  bool _internal_has_upper_bound() const;
  public:
  void clear_upper_bound();
  const ::infinity_grpc_proto::ParsedExpr& upper_bound() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_upper_bound();
  ::infinity_grpc_proto::ParsedExpr* mutable_upper_bound();
  void set_allocated_upper_bound(::infinity_grpc_proto::ParsedExpr* upper_bound);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_upper_bound() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_upper_bound();
  public:
  void unsafe_arena_set_allocated_upper_bound(
      ::infinity_grpc_proto::ParsedExpr* upper_bound);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_upper_bound();

  // .infinity_grpc_proto.ParsedExpr lower_bound = 3;
  bool has_lower_bound() const;
  private:
  bool _internal_has_lower_bound() const;
  public:
  void clear_lower_bound();
  const ::infinity_grpc_proto::ParsedExpr& lower_bound() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_lower_bound();
  ::infinity_grpc_proto::ParsedExpr* mutable_lower_bound();
  void set_allocated_lower_bound(::infinity_grpc_proto::ParsedExpr* lower_bound);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_lower_bound() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_lower_bound();
  public:
  void unsafe_arena_set_allocated_lower_bound(
      ::infinity_grpc_proto::ParsedExpr* lower_bound);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_lower_bound();

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.BetweenExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::infinity_grpc_proto::ParsedExpr* value_;
    ::infinity_grpc_proto::ParsedExpr* upper_bound_;
    ::infinity_grpc_proto::ParsedExpr* lower_bound_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class InExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.InExpr) */ {
 public:
  inline InExpr() : InExpr(nullptr) {}
  ~InExpr() override;
  explicit PROTOBUF_CONSTEXPR InExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InExpr(const InExpr& from);
  InExpr(InExpr&& from) noexcept
    : InExpr() {
    *this = ::std::move(from);
  }

  inline InExpr& operator=(const InExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline InExpr& operator=(InExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const InExpr* internal_default_instance() {
    return reinterpret_cast<const InExpr*>(
               &_InExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(InExpr& a, InExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(InExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InExpr& from) {
    InExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.InExpr";
  }
  protected:
  explicit InExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 2,
    kLeftFieldNumber = 1,
    kNotInFieldNumber = 3,
  };
  // repeated .infinity_grpc_proto.ParsedExpr arguments = 2;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  ::infinity_grpc_proto::ParsedExpr* mutable_arguments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
      mutable_arguments();
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_arguments(int index) const;
  ::infinity_grpc_proto::ParsedExpr* _internal_add_arguments();
  public:
  const ::infinity_grpc_proto::ParsedExpr& arguments(int index) const;
  ::infinity_grpc_proto::ParsedExpr* add_arguments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
      arguments() const;

  // .infinity_grpc_proto.ParsedExpr left = 1;
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  const ::infinity_grpc_proto::ParsedExpr& left() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_left();
  ::infinity_grpc_proto::ParsedExpr* mutable_left();
  void set_allocated_left(::infinity_grpc_proto::ParsedExpr* left);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_left() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_left();
  public:
  void unsafe_arena_set_allocated_left(
      ::infinity_grpc_proto::ParsedExpr* left);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_left();

  // bool not_in = 3;
  void clear_not_in();
  bool not_in() const;
  void set_not_in(bool value);
  private:
  bool _internal_not_in() const;
  void _internal_set_not_in(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.InExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr > arguments_;
    ::infinity_grpc_proto::ParsedExpr* left_;
    bool not_in_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class KnnExpr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.KnnExpr) */ {
 public:
  inline KnnExpr() : KnnExpr(nullptr) {}
  ~KnnExpr() override;
  explicit PROTOBUF_CONSTEXPR KnnExpr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KnnExpr(const KnnExpr& from);
  KnnExpr(KnnExpr&& from) noexcept
    : KnnExpr() {
    *this = ::std::move(from);
  }

  inline KnnExpr& operator=(const KnnExpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline KnnExpr& operator=(KnnExpr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KnnExpr& default_instance() {
    return *internal_default_instance();
  }
  static inline const KnnExpr* internal_default_instance() {
    return reinterpret_cast<const KnnExpr*>(
               &_KnnExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(KnnExpr& a, KnnExpr& b) {
    a.Swap(&b);
  }
  inline void Swap(KnnExpr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KnnExpr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KnnExpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KnnExpr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KnnExpr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KnnExpr& from) {
    KnnExpr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KnnExpr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.KnnExpr";
  }
  protected:
  explicit KnnExpr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KnnExpr_KnnDistanceType KnnDistanceType;
  static constexpr KnnDistanceType L2 =
    KnnExpr_KnnDistanceType_L2;
  static constexpr KnnDistanceType Cosine =
    KnnExpr_KnnDistanceType_Cosine;
  static constexpr KnnDistanceType InnerProduct =
    KnnExpr_KnnDistanceType_InnerProduct;
  static constexpr KnnDistanceType Hamming =
    KnnExpr_KnnDistanceType_Hamming;
  static inline bool KnnDistanceType_IsValid(int value) {
    return KnnExpr_KnnDistanceType_IsValid(value);
  }
  static constexpr KnnDistanceType KnnDistanceType_MIN =
    KnnExpr_KnnDistanceType_KnnDistanceType_MIN;
  static constexpr KnnDistanceType KnnDistanceType_MAX =
    KnnExpr_KnnDistanceType_KnnDistanceType_MAX;
  static constexpr int KnnDistanceType_ARRAYSIZE =
    KnnExpr_KnnDistanceType_KnnDistanceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  KnnDistanceType_descriptor() {
    return KnnExpr_KnnDistanceType_descriptor();
  }
  template<typename T>
  static inline const std::string& KnnDistanceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KnnDistanceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KnnDistanceType_Name.");
    return KnnExpr_KnnDistanceType_Name(enum_t_value);
  }
  static inline bool KnnDistanceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      KnnDistanceType* value) {
    return KnnExpr_KnnDistanceType_Parse(name, value);
  }

  typedef KnnExpr_EmbeddingDataType EmbeddingDataType;
  static constexpr EmbeddingDataType ElemBool =
    KnnExpr_EmbeddingDataType_ElemBool;
  static constexpr EmbeddingDataType ElemTinyInt =
    KnnExpr_EmbeddingDataType_ElemTinyInt;
  static constexpr EmbeddingDataType ElemSmallInt =
    KnnExpr_EmbeddingDataType_ElemSmallInt;
  static constexpr EmbeddingDataType ElemInteger =
    KnnExpr_EmbeddingDataType_ElemInteger;
  static constexpr EmbeddingDataType ElemBigInt =
    KnnExpr_EmbeddingDataType_ElemBigInt;
  static constexpr EmbeddingDataType ElemFloat =
    KnnExpr_EmbeddingDataType_ElemFloat;
  static constexpr EmbeddingDataType ElemDouble =
    KnnExpr_EmbeddingDataType_ElemDouble;
  static inline bool EmbeddingDataType_IsValid(int value) {
    return KnnExpr_EmbeddingDataType_IsValid(value);
  }
  static constexpr EmbeddingDataType EmbeddingDataType_MIN =
    KnnExpr_EmbeddingDataType_EmbeddingDataType_MIN;
  static constexpr EmbeddingDataType EmbeddingDataType_MAX =
    KnnExpr_EmbeddingDataType_EmbeddingDataType_MAX;
  static constexpr int EmbeddingDataType_ARRAYSIZE =
    KnnExpr_EmbeddingDataType_EmbeddingDataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EmbeddingDataType_descriptor() {
    return KnnExpr_EmbeddingDataType_descriptor();
  }
  template<typename T>
  static inline const std::string& EmbeddingDataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EmbeddingDataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EmbeddingDataType_Name.");
    return KnnExpr_EmbeddingDataType_Name(enum_t_value);
  }
  static inline bool EmbeddingDataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EmbeddingDataType* value) {
    return KnnExpr_EmbeddingDataType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEmbeddingDataFieldNumber = 2,
    kColumnExprFieldNumber = 1,
    kDimensionFieldNumber = 3,
    kEmbeddingDataTypeFieldNumber = 4,
    kDistanceTypeFieldNumber = 5,
  };
  // repeated string embedding_data = 2;
  int embedding_data_size() const;
  private:
  int _internal_embedding_data_size() const;
  public:
  void clear_embedding_data();
  const std::string& embedding_data(int index) const;
  std::string* mutable_embedding_data(int index);
  void set_embedding_data(int index, const std::string& value);
  void set_embedding_data(int index, std::string&& value);
  void set_embedding_data(int index, const char* value);
  void set_embedding_data(int index, const char* value, size_t size);
  std::string* add_embedding_data();
  void add_embedding_data(const std::string& value);
  void add_embedding_data(std::string&& value);
  void add_embedding_data(const char* value);
  void add_embedding_data(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& embedding_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_embedding_data();
  private:
  const std::string& _internal_embedding_data(int index) const;
  std::string* _internal_add_embedding_data();
  public:

  // .infinity_grpc_proto.ParsedExpr column_expr = 1;
  bool has_column_expr() const;
  private:
  bool _internal_has_column_expr() const;
  public:
  void clear_column_expr();
  const ::infinity_grpc_proto::ParsedExpr& column_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_column_expr();
  ::infinity_grpc_proto::ParsedExpr* mutable_column_expr();
  void set_allocated_column_expr(::infinity_grpc_proto::ParsedExpr* column_expr);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_column_expr() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_column_expr();
  public:
  void unsafe_arena_set_allocated_column_expr(
      ::infinity_grpc_proto::ParsedExpr* column_expr);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_column_expr();

  // int64 dimension = 3;
  void clear_dimension();
  int64_t dimension() const;
  void set_dimension(int64_t value);
  private:
  int64_t _internal_dimension() const;
  void _internal_set_dimension(int64_t value);
  public:

  // .infinity_grpc_proto.KnnExpr.EmbeddingDataType embedding_data_type = 4;
  void clear_embedding_data_type();
  ::infinity_grpc_proto::KnnExpr_EmbeddingDataType embedding_data_type() const;
  void set_embedding_data_type(::infinity_grpc_proto::KnnExpr_EmbeddingDataType value);
  private:
  ::infinity_grpc_proto::KnnExpr_EmbeddingDataType _internal_embedding_data_type() const;
  void _internal_set_embedding_data_type(::infinity_grpc_proto::KnnExpr_EmbeddingDataType value);
  public:

  // .infinity_grpc_proto.KnnExpr.KnnDistanceType distance_type = 5;
  void clear_distance_type();
  ::infinity_grpc_proto::KnnExpr_KnnDistanceType distance_type() const;
  void set_distance_type(::infinity_grpc_proto::KnnExpr_KnnDistanceType value);
  private:
  ::infinity_grpc_proto::KnnExpr_KnnDistanceType _internal_distance_type() const;
  void _internal_set_distance_type(::infinity_grpc_proto::KnnExpr_KnnDistanceType value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.KnnExpr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> embedding_data_;
    ::infinity_grpc_proto::ParsedExpr* column_expr_;
    int64_t dimension_;
    int embedding_data_type_;
    int distance_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class SelectStatement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.SelectStatement) */ {
 public:
  inline SelectStatement() : SelectStatement(nullptr) {}
  ~SelectStatement() override;
  explicit PROTOBUF_CONSTEXPR SelectStatement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectStatement(const SelectStatement& from);
  SelectStatement(SelectStatement&& from) noexcept
    : SelectStatement() {
    *this = ::std::move(from);
  }

  inline SelectStatement& operator=(const SelectStatement& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectStatement& operator=(SelectStatement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectStatement& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectStatement* internal_default_instance() {
    return reinterpret_cast<const SelectStatement*>(
               &_SelectStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SelectStatement& a, SelectStatement& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectStatement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectStatement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectStatement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectStatement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectStatement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectStatement& from) {
    SelectStatement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectStatement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.SelectStatement";
  }
  protected:
  explicit SelectStatement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSelectListFieldNumber = 3,
    kGroupByListFieldNumber = 5,
    kDbNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kWhereExprFieldNumber = 4,
    kLimitExprFieldNumber = 6,
    kOffsetExprFieldNumber = 7,
    kSearchExprFieldNumber = 8,
    kSessionIdFieldNumber = 9,
  };
  // repeated .infinity_grpc_proto.ParsedExpr select_list = 3;
  int select_list_size() const;
  private:
  int _internal_select_list_size() const;
  public:
  void clear_select_list();
  ::infinity_grpc_proto::ParsedExpr* mutable_select_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
      mutable_select_list();
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_select_list(int index) const;
  ::infinity_grpc_proto::ParsedExpr* _internal_add_select_list();
  public:
  const ::infinity_grpc_proto::ParsedExpr& select_list(int index) const;
  ::infinity_grpc_proto::ParsedExpr* add_select_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
      select_list() const;

  // repeated .infinity_grpc_proto.ParsedExpr group_by_list = 5;
  int group_by_list_size() const;
  private:
  int _internal_group_by_list_size() const;
  public:
  void clear_group_by_list();
  ::infinity_grpc_proto::ParsedExpr* mutable_group_by_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
      mutable_group_by_list();
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_group_by_list(int index) const;
  ::infinity_grpc_proto::ParsedExpr* _internal_add_group_by_list();
  public:
  const ::infinity_grpc_proto::ParsedExpr& group_by_list(int index) const;
  ::infinity_grpc_proto::ParsedExpr* add_group_by_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
      group_by_list() const;

  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // .infinity_grpc_proto.ParsedExpr where_expr = 4;
  bool has_where_expr() const;
  private:
  bool _internal_has_where_expr() const;
  public:
  void clear_where_expr();
  const ::infinity_grpc_proto::ParsedExpr& where_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_where_expr();
  ::infinity_grpc_proto::ParsedExpr* mutable_where_expr();
  void set_allocated_where_expr(::infinity_grpc_proto::ParsedExpr* where_expr);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_where_expr() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_where_expr();
  public:
  void unsafe_arena_set_allocated_where_expr(
      ::infinity_grpc_proto::ParsedExpr* where_expr);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_where_expr();

  // .infinity_grpc_proto.ParsedExpr limit_expr = 6;
  bool has_limit_expr() const;
  private:
  bool _internal_has_limit_expr() const;
  public:
  void clear_limit_expr();
  const ::infinity_grpc_proto::ParsedExpr& limit_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_limit_expr();
  ::infinity_grpc_proto::ParsedExpr* mutable_limit_expr();
  void set_allocated_limit_expr(::infinity_grpc_proto::ParsedExpr* limit_expr);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_limit_expr() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_limit_expr();
  public:
  void unsafe_arena_set_allocated_limit_expr(
      ::infinity_grpc_proto::ParsedExpr* limit_expr);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_limit_expr();

  // .infinity_grpc_proto.ParsedExpr offset_expr = 7;
  bool has_offset_expr() const;
  private:
  bool _internal_has_offset_expr() const;
  public:
  void clear_offset_expr();
  const ::infinity_grpc_proto::ParsedExpr& offset_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_offset_expr();
  ::infinity_grpc_proto::ParsedExpr* mutable_offset_expr();
  void set_allocated_offset_expr(::infinity_grpc_proto::ParsedExpr* offset_expr);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_offset_expr() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_offset_expr();
  public:
  void unsafe_arena_set_allocated_offset_expr(
      ::infinity_grpc_proto::ParsedExpr* offset_expr);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_offset_expr();

  // .infinity_grpc_proto.ParsedExpr search_expr = 8;
  bool has_search_expr() const;
  private:
  bool _internal_has_search_expr() const;
  public:
  void clear_search_expr();
  const ::infinity_grpc_proto::ParsedExpr& search_expr() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::ParsedExpr* release_search_expr();
  ::infinity_grpc_proto::ParsedExpr* mutable_search_expr();
  void set_allocated_search_expr(::infinity_grpc_proto::ParsedExpr* search_expr);
  private:
  const ::infinity_grpc_proto::ParsedExpr& _internal_search_expr() const;
  ::infinity_grpc_proto::ParsedExpr* _internal_mutable_search_expr();
  public:
  void unsafe_arena_set_allocated_search_expr(
      ::infinity_grpc_proto::ParsedExpr* search_expr);
  ::infinity_grpc_proto::ParsedExpr* unsafe_arena_release_search_expr();

  // uint64 session_id = 9;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.SelectStatement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr > select_list_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr > group_by_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::infinity_grpc_proto::ParsedExpr* where_expr_;
    ::infinity_grpc_proto::ParsedExpr* limit_expr_;
    ::infinity_grpc_proto::ParsedExpr* offset_expr_;
    ::infinity_grpc_proto::ParsedExpr* search_expr_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DisConnectRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DisConnectRequest) */ {
 public:
  inline DisConnectRequest() : DisConnectRequest(nullptr) {}
  ~DisConnectRequest() override;
  explicit PROTOBUF_CONSTEXPR DisConnectRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DisConnectRequest(const DisConnectRequest& from);
  DisConnectRequest(DisConnectRequest&& from) noexcept
    : DisConnectRequest() {
    *this = ::std::move(from);
  }

  inline DisConnectRequest& operator=(const DisConnectRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisConnectRequest& operator=(DisConnectRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisConnectRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisConnectRequest* internal_default_instance() {
    return reinterpret_cast<const DisConnectRequest*>(
               &_DisConnectRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(DisConnectRequest& a, DisConnectRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DisConnectRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisConnectRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisConnectRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisConnectRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DisConnectRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DisConnectRequest& from) {
    DisConnectRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DisConnectRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DisConnectRequest";
  }
  protected:
  explicit DisConnectRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DisConnectRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class CommonResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.CommonResponse) */ {
 public:
  inline CommonResponse() : CommonResponse(nullptr) {}
  ~CommonResponse() override;
  explicit PROTOBUF_CONSTEXPR CommonResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommonResponse(const CommonResponse& from);
  CommonResponse(CommonResponse&& from) noexcept
    : CommonResponse() {
    *this = ::std::move(from);
  }

  inline CommonResponse& operator=(const CommonResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommonResponse& operator=(CommonResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommonResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommonResponse* internal_default_instance() {
    return reinterpret_cast<const CommonResponse*>(
               &_CommonResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CommonResponse& a, CommonResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommonResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommonResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommonResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommonResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommonResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CommonResponse& from) {
    CommonResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommonResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.CommonResponse";
  }
  protected:
  explicit CommonResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kSessionIdFieldNumber = 3,
    kSuccessFieldNumber = 1,
  };
  // string error_msg = 2;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // uint64 session_id = 3;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.CommonResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    uint64_t session_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class SelectResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.SelectResponse) */ {
 public:
  inline SelectResponse() : SelectResponse(nullptr) {}
  ~SelectResponse() override;
  explicit PROTOBUF_CONSTEXPR SelectResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectResponse(const SelectResponse& from);
  SelectResponse(SelectResponse&& from) noexcept
    : SelectResponse() {
    *this = ::std::move(from);
  }

  inline SelectResponse& operator=(const SelectResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectResponse& operator=(SelectResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectResponse* internal_default_instance() {
    return reinterpret_cast<const SelectResponse*>(
               &_SelectResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SelectResponse& a, SelectResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SelectResponse& from) {
    SelectResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.SelectResponse";
  }
  protected:
  explicit SelectResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnDefsFieldNumber = 3,
    kColumnFieldsFieldNumber = 4,
    kErrorMsgFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // repeated .infinity_grpc_proto.ColumnDef column_defs = 3;
  int column_defs_size() const;
  private:
  int _internal_column_defs_size() const;
  public:
  void clear_column_defs();
  ::infinity_grpc_proto::ColumnDef* mutable_column_defs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef >*
      mutable_column_defs();
  private:
  const ::infinity_grpc_proto::ColumnDef& _internal_column_defs(int index) const;
  ::infinity_grpc_proto::ColumnDef* _internal_add_column_defs();
  public:
  const ::infinity_grpc_proto::ColumnDef& column_defs(int index) const;
  ::infinity_grpc_proto::ColumnDef* add_column_defs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef >&
      column_defs() const;

  // repeated .infinity_grpc_proto.ColumnField column_fields = 4;
  int column_fields_size() const;
  private:
  int _internal_column_fields_size() const;
  public:
  void clear_column_fields();
  ::infinity_grpc_proto::ColumnField* mutable_column_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnField >*
      mutable_column_fields();
  private:
  const ::infinity_grpc_proto::ColumnField& _internal_column_fields(int index) const;
  ::infinity_grpc_proto::ColumnField* _internal_add_column_fields();
  public:
  const ::infinity_grpc_proto::ColumnField& column_fields(int index) const;
  ::infinity_grpc_proto::ColumnField* add_column_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnField >&
      column_fields() const;

  // string error_msg = 2;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.SelectResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef > column_defs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnField > column_fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ColumnField final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ColumnField) */ {
 public:
  inline ColumnField() : ColumnField(nullptr) {}
  ~ColumnField() override;
  explicit PROTOBUF_CONSTEXPR ColumnField(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnField(const ColumnField& from);
  ColumnField(ColumnField&& from) noexcept
    : ColumnField() {
    *this = ::std::move(from);
  }

  inline ColumnField& operator=(const ColumnField& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnField& operator=(ColumnField&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnField& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnField* internal_default_instance() {
    return reinterpret_cast<const ColumnField*>(
               &_ColumnField_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ColumnField& a, ColumnField& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnField* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnField* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnField* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnField>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnField& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnField& from) {
    ColumnField::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnField* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ColumnField";
  }
  protected:
  explicit ColumnField(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnVectorFieldNumber = 2,
    kColumnTypeFieldNumber = 1,
  };
  // bytes column_vector = 2;
  void clear_column_vector();
  const std::string& column_vector() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_vector(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_vector();
  PROTOBUF_NODISCARD std::string* release_column_vector();
  void set_allocated_column_vector(std::string* column_vector);
  private:
  const std::string& _internal_column_vector() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_vector(const std::string& value);
  std::string* _internal_mutable_column_vector();
  public:

  // .infinity_grpc_proto.ColumnType column_type = 1;
  void clear_column_type();
  ::infinity_grpc_proto::ColumnType column_type() const;
  void set_column_type(::infinity_grpc_proto::ColumnType value);
  private:
  ::infinity_grpc_proto::ColumnType _internal_column_type() const;
  void _internal_set_column_type(::infinity_grpc_proto::ColumnType value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ColumnField)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_vector_;
    int column_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DataBlock_ColumnVector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DataBlock.ColumnVector) */ {
 public:
  inline DataBlock_ColumnVector() : DataBlock_ColumnVector(nullptr) {}
  ~DataBlock_ColumnVector() override;
  explicit PROTOBUF_CONSTEXPR DataBlock_ColumnVector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataBlock_ColumnVector(const DataBlock_ColumnVector& from);
  DataBlock_ColumnVector(DataBlock_ColumnVector&& from) noexcept
    : DataBlock_ColumnVector() {
    *this = ::std::move(from);
  }

  inline DataBlock_ColumnVector& operator=(const DataBlock_ColumnVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataBlock_ColumnVector& operator=(DataBlock_ColumnVector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataBlock_ColumnVector& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataBlock_ColumnVector* internal_default_instance() {
    return reinterpret_cast<const DataBlock_ColumnVector*>(
               &_DataBlock_ColumnVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DataBlock_ColumnVector& a, DataBlock_ColumnVector& b) {
    a.Swap(&b);
  }
  inline void Swap(DataBlock_ColumnVector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataBlock_ColumnVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataBlock_ColumnVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataBlock_ColumnVector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataBlock_ColumnVector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataBlock_ColumnVector& from) {
    DataBlock_ColumnVector::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataBlock_ColumnVector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DataBlock.ColumnVector";
  }
  protected:
  explicit DataBlock_ColumnVector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnVectorsFieldNumber = 1,
  };
  // repeated .infinity_grpc_proto.DataBlock.ColumnVector column_vectors = 1;
  int column_vectors_size() const;
  private:
  int _internal_column_vectors_size() const;
  public:
  void clear_column_vectors();
  ::infinity_grpc_proto::DataBlock_ColumnVector* mutable_column_vectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector >*
      mutable_column_vectors();
  private:
  const ::infinity_grpc_proto::DataBlock_ColumnVector& _internal_column_vectors(int index) const;
  ::infinity_grpc_proto::DataBlock_ColumnVector* _internal_add_column_vectors();
  public:
  const ::infinity_grpc_proto::DataBlock_ColumnVector& column_vectors(int index) const;
  ::infinity_grpc_proto::DataBlock_ColumnVector* add_column_vectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector >&
      column_vectors() const;

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DataBlock.ColumnVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector > column_vectors_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DataBlock final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DataBlock) */ {
 public:
  inline DataBlock() : DataBlock(nullptr) {}
  ~DataBlock() override;
  explicit PROTOBUF_CONSTEXPR DataBlock(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataBlock(const DataBlock& from);
  DataBlock(DataBlock&& from) noexcept
    : DataBlock() {
    *this = ::std::move(from);
  }

  inline DataBlock& operator=(const DataBlock& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataBlock& operator=(DataBlock&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataBlock& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataBlock* internal_default_instance() {
    return reinterpret_cast<const DataBlock*>(
               &_DataBlock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DataBlock& a, DataBlock& b) {
    a.Swap(&b);
  }
  inline void Swap(DataBlock* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataBlock* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataBlock* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataBlock>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataBlock& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataBlock& from) {
    DataBlock::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataBlock* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DataBlock";
  }
  protected:
  explicit DataBlock(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DataBlock_ColumnVector ColumnVector;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnVectorsFieldNumber = 4,
    kRowCountFieldNumber = 1,
    kColumnCountFieldNumber = 2,
    kCapacityFieldNumber = 3,
  };
  // repeated .infinity_grpc_proto.DataBlock.ColumnVector column_vectors = 4;
  int column_vectors_size() const;
  private:
  int _internal_column_vectors_size() const;
  public:
  void clear_column_vectors();
  ::infinity_grpc_proto::DataBlock_ColumnVector* mutable_column_vectors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector >*
      mutable_column_vectors();
  private:
  const ::infinity_grpc_proto::DataBlock_ColumnVector& _internal_column_vectors(int index) const;
  ::infinity_grpc_proto::DataBlock_ColumnVector* _internal_add_column_vectors();
  public:
  const ::infinity_grpc_proto::DataBlock_ColumnVector& column_vectors(int index) const;
  ::infinity_grpc_proto::DataBlock_ColumnVector* add_column_vectors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector >&
      column_vectors() const;

  // int32 row_count = 1;
  void clear_row_count();
  int32_t row_count() const;
  void set_row_count(int32_t value);
  private:
  int32_t _internal_row_count() const;
  void _internal_set_row_count(int32_t value);
  public:

  // int32 column_count = 2;
  void clear_column_count();
  int32_t column_count() const;
  void set_column_count(int32_t value);
  private:
  int32_t _internal_column_count() const;
  void _internal_set_column_count(int32_t value);
  public:

  // int32 capacity = 3;
  void clear_capacity();
  int32_t capacity() const;
  void set_capacity(int32_t value);
  private:
  int32_t _internal_capacity() const;
  void _internal_set_capacity(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DataBlock)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector > column_vectors_;
    int32_t row_count_;
    int32_t column_count_;
    int32_t capacity_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ListDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ListDatabaseRequest) */ {
 public:
  inline ListDatabaseRequest() : ListDatabaseRequest(nullptr) {}
  ~ListDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR ListDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatabaseRequest(const ListDatabaseRequest& from);
  ListDatabaseRequest(ListDatabaseRequest&& from) noexcept
    : ListDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline ListDatabaseRequest& operator=(const ListDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatabaseRequest& operator=(ListDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const ListDatabaseRequest*>(
               &_ListDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ListDatabaseRequest& a, ListDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDatabaseRequest& from) {
    ListDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ListDatabaseRequest";
  }
  protected:
  explicit ListDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // uint64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ListDatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ListDatabaseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ListDatabaseResponse) */ {
 public:
  inline ListDatabaseResponse() : ListDatabaseResponse(nullptr) {}
  ~ListDatabaseResponse() override;
  explicit PROTOBUF_CONSTEXPR ListDatabaseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListDatabaseResponse(const ListDatabaseResponse& from);
  ListDatabaseResponse(ListDatabaseResponse&& from) noexcept
    : ListDatabaseResponse() {
    *this = ::std::move(from);
  }

  inline ListDatabaseResponse& operator=(const ListDatabaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListDatabaseResponse& operator=(ListDatabaseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListDatabaseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListDatabaseResponse* internal_default_instance() {
    return reinterpret_cast<const ListDatabaseResponse*>(
               &_ListDatabaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ListDatabaseResponse& a, ListDatabaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListDatabaseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListDatabaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListDatabaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListDatabaseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListDatabaseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListDatabaseResponse& from) {
    ListDatabaseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListDatabaseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ListDatabaseResponse";
  }
  protected:
  explicit ListDatabaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNamesFieldNumber = 1,
    kErrorMsgFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // repeated string db_names = 1;
  int db_names_size() const;
  private:
  int _internal_db_names_size() const;
  public:
  void clear_db_names();
  const std::string& db_names(int index) const;
  std::string* mutable_db_names(int index);
  void set_db_names(int index, const std::string& value);
  void set_db_names(int index, std::string&& value);
  void set_db_names(int index, const char* value);
  void set_db_names(int index, const char* value, size_t size);
  std::string* add_db_names();
  void add_db_names(const std::string& value);
  void add_db_names(std::string&& value);
  void add_db_names(const char* value);
  void add_db_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& db_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_db_names();
  private:
  const std::string& _internal_db_names(int index) const;
  std::string* _internal_add_db_names();
  public:

  // string error_msg = 3;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ListDatabaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> db_names_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DescribeDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DescribeDatabaseRequest) */ {
 public:
  inline DescribeDatabaseRequest() : DescribeDatabaseRequest(nullptr) {}
  ~DescribeDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR DescribeDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DescribeDatabaseRequest(const DescribeDatabaseRequest& from);
  DescribeDatabaseRequest(DescribeDatabaseRequest&& from) noexcept
    : DescribeDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline DescribeDatabaseRequest& operator=(const DescribeDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeDatabaseRequest& operator=(DescribeDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DescribeDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DescribeDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const DescribeDatabaseRequest*>(
               &_DescribeDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(DescribeDatabaseRequest& a, DescribeDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribeDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribeDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DescribeDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DescribeDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DescribeDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DescribeDatabaseRequest& from) {
    DescribeDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DescribeDatabaseRequest";
  }
  protected:
  explicit DescribeDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kSessionIdFieldNumber = 2,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // uint64 session_id = 2;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DescribeDatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DescribeDatabaseResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DescribeDatabaseResponse) */ {
 public:
  inline DescribeDatabaseResponse() : DescribeDatabaseResponse(nullptr) {}
  ~DescribeDatabaseResponse() override;
  explicit PROTOBUF_CONSTEXPR DescribeDatabaseResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DescribeDatabaseResponse(const DescribeDatabaseResponse& from);
  DescribeDatabaseResponse(DescribeDatabaseResponse&& from) noexcept
    : DescribeDatabaseResponse() {
    *this = ::std::move(from);
  }

  inline DescribeDatabaseResponse& operator=(const DescribeDatabaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeDatabaseResponse& operator=(DescribeDatabaseResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DescribeDatabaseResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DescribeDatabaseResponse* internal_default_instance() {
    return reinterpret_cast<const DescribeDatabaseResponse*>(
               &_DescribeDatabaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(DescribeDatabaseResponse& a, DescribeDatabaseResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribeDatabaseResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribeDatabaseResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DescribeDatabaseResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DescribeDatabaseResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DescribeDatabaseResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DescribeDatabaseResponse& from) {
    DescribeDatabaseResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeDatabaseResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DescribeDatabaseResponse";
  }
  protected:
  explicit DescribeDatabaseResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kDbIdFieldNumber = 2,
    kNumSegmentsFieldNumber = 3,
    kNumBlocksFieldNumber = 4,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // int32 db_id = 2;
  void clear_db_id();
  int32_t db_id() const;
  void set_db_id(int32_t value);
  private:
  int32_t _internal_db_id() const;
  void _internal_set_db_id(int32_t value);
  public:

  // int32 num_segments = 3;
  void clear_num_segments();
  int32_t num_segments() const;
  void set_num_segments(int32_t value);
  private:
  int32_t _internal_num_segments() const;
  void _internal_set_num_segments(int32_t value);
  public:

  // int32 num_blocks = 4;
  void clear_num_blocks();
  int32_t num_blocks() const;
  void set_num_blocks(int32_t value);
  private:
  int32_t _internal_num_blocks() const;
  void _internal_set_num_blocks(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DescribeDatabaseResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    int32_t db_id_;
    int32_t num_segments_;
    int32_t num_blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ListTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ListTableRequest) */ {
 public:
  inline ListTableRequest() : ListTableRequest(nullptr) {}
  ~ListTableRequest() override;
  explicit PROTOBUF_CONSTEXPR ListTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTableRequest(const ListTableRequest& from);
  ListTableRequest(ListTableRequest&& from) noexcept
    : ListTableRequest() {
    *this = ::std::move(from);
  }

  inline ListTableRequest& operator=(const ListTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTableRequest& operator=(ListTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTableRequest* internal_default_instance() {
    return reinterpret_cast<const ListTableRequest*>(
               &_ListTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ListTableRequest& a, ListTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTableRequest& from) {
    ListTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ListTableRequest";
  }
  protected:
  explicit ListTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kErrorMsgFieldNumber = 3,
    kSessionIdFieldNumber = 4,
    kSuccessFieldNumber = 2,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string error_msg = 3;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // uint64 session_id = 4;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ListTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    uint64_t session_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class ListTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.ListTableResponse) */ {
 public:
  inline ListTableResponse() : ListTableResponse(nullptr) {}
  ~ListTableResponse() override;
  explicit PROTOBUF_CONSTEXPR ListTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTableResponse(const ListTableResponse& from);
  ListTableResponse(ListTableResponse&& from) noexcept
    : ListTableResponse() {
    *this = ::std::move(from);
  }

  inline ListTableResponse& operator=(const ListTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTableResponse& operator=(ListTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTableResponse* internal_default_instance() {
    return reinterpret_cast<const ListTableResponse*>(
               &_ListTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ListTableResponse& a, ListTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTableResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ListTableResponse& from) {
    ListTableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.ListTableResponse";
  }
  protected:
  explicit ListTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kErrorMsgFieldNumber = 3,
    kSuccessFieldNumber = 2,
  };
  // repeated string table_name = 1;
  int table_name_size() const;
  private:
  int _internal_table_name_size() const;
  public:
  void clear_table_name();
  const std::string& table_name(int index) const;
  std::string* mutable_table_name(int index);
  void set_table_name(int index, const std::string& value);
  void set_table_name(int index, std::string&& value);
  void set_table_name(int index, const char* value);
  void set_table_name(int index, const char* value, size_t size);
  std::string* add_table_name();
  void add_table_name(const std::string& value);
  void add_table_name(std::string&& value);
  void add_table_name(const char* value);
  void add_table_name(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& table_name() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_table_name();
  private:
  const std::string& _internal_table_name(int index) const;
  std::string* _internal_add_table_name();
  public:

  // string error_msg = 3;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.ListTableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DescribeTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DescribeTableRequest) */ {
 public:
  inline DescribeTableRequest() : DescribeTableRequest(nullptr) {}
  ~DescribeTableRequest() override;
  explicit PROTOBUF_CONSTEXPR DescribeTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DescribeTableRequest(const DescribeTableRequest& from);
  DescribeTableRequest(DescribeTableRequest&& from) noexcept
    : DescribeTableRequest() {
    *this = ::std::move(from);
  }

  inline DescribeTableRequest& operator=(const DescribeTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeTableRequest& operator=(DescribeTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DescribeTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DescribeTableRequest* internal_default_instance() {
    return reinterpret_cast<const DescribeTableRequest*>(
               &_DescribeTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(DescribeTableRequest& a, DescribeTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribeTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribeTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DescribeTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DescribeTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DescribeTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DescribeTableRequest& from) {
    DescribeTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DescribeTableRequest";
  }
  protected:
  explicit DescribeTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kSessionIdFieldNumber = 2,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // uint64 session_id = 2;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DescribeTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DescribeTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DescribeTableResponse) */ {
 public:
  inline DescribeTableResponse() : DescribeTableResponse(nullptr) {}
  ~DescribeTableResponse() override;
  explicit PROTOBUF_CONSTEXPR DescribeTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DescribeTableResponse(const DescribeTableResponse& from);
  DescribeTableResponse(DescribeTableResponse&& from) noexcept
    : DescribeTableResponse() {
    *this = ::std::move(from);
  }

  inline DescribeTableResponse& operator=(const DescribeTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DescribeTableResponse& operator=(DescribeTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DescribeTableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DescribeTableResponse* internal_default_instance() {
    return reinterpret_cast<const DescribeTableResponse*>(
               &_DescribeTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DescribeTableResponse& a, DescribeTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DescribeTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DescribeTableResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DescribeTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DescribeTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DescribeTableResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DescribeTableResponse& from) {
    DescribeTableResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DescribeTableResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DescribeTableResponse";
  }
  protected:
  explicit DescribeTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kTableIdFieldNumber = 2,
    kNumSegmentsFieldNumber = 3,
    kNumBlocksFieldNumber = 4,
  };
  // string table_name = 1;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // int32 table_id = 2;
  void clear_table_id();
  int32_t table_id() const;
  void set_table_id(int32_t value);
  private:
  int32_t _internal_table_id() const;
  void _internal_set_table_id(int32_t value);
  public:

  // int32 num_segments = 3;
  void clear_num_segments();
  int32_t num_segments() const;
  void set_num_segments(int32_t value);
  private:
  int32_t _internal_num_segments() const;
  void _internal_set_num_segments(int32_t value);
  public:

  // int32 num_blocks = 4;
  void clear_num_blocks();
  int32_t num_blocks() const;
  void set_num_blocks(int32_t value);
  private:
  int32_t _internal_num_blocks() const;
  void _internal_set_num_blocks(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DescribeTableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    int32_t table_id_;
    int32_t num_segments_;
    int32_t num_blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class GetDatabaseRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.GetDatabaseRequest) */ {
 public:
  inline GetDatabaseRequest() : GetDatabaseRequest(nullptr) {}
  ~GetDatabaseRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDatabaseRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDatabaseRequest(const GetDatabaseRequest& from);
  GetDatabaseRequest(GetDatabaseRequest&& from) noexcept
    : GetDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline GetDatabaseRequest& operator=(const GetDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDatabaseRequest& operator=(GetDatabaseRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDatabaseRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const GetDatabaseRequest*>(
               &_GetDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetDatabaseRequest& a, GetDatabaseRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDatabaseRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDatabaseRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDatabaseRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDatabaseRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDatabaseRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDatabaseRequest& from) {
    GetDatabaseRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatabaseRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.GetDatabaseRequest";
  }
  protected:
  explicit GetDatabaseRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kSessionIdFieldNumber = 2,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // uint64 session_id = 2;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.GetDatabaseRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class GetTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.GetTableRequest) */ {
 public:
  inline GetTableRequest() : GetTableRequest(nullptr) {}
  ~GetTableRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTableRequest(const GetTableRequest& from);
  GetTableRequest(GetTableRequest&& from) noexcept
    : GetTableRequest() {
    *this = ::std::move(from);
  }

  inline GetTableRequest& operator=(const GetTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTableRequest& operator=(GetTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTableRequest* internal_default_instance() {
    return reinterpret_cast<const GetTableRequest*>(
               &_GetTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(GetTableRequest& a, GetTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTableRequest& from) {
    GetTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.GetTableRequest";
  }
  protected:
  explicit GetTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kSessionIdFieldNumber = 3,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // uint64 session_id = 3;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.GetTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class CreateIndexRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.CreateIndexRequest) */ {
 public:
  inline CreateIndexRequest() : CreateIndexRequest(nullptr) {}
  ~CreateIndexRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateIndexRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateIndexRequest(const CreateIndexRequest& from);
  CreateIndexRequest(CreateIndexRequest&& from) noexcept
    : CreateIndexRequest() {
    *this = ::std::move(from);
  }

  inline CreateIndexRequest& operator=(const CreateIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIndexRequest& operator=(CreateIndexRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIndexRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIndexRequest* internal_default_instance() {
    return reinterpret_cast<const CreateIndexRequest*>(
               &_CreateIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CreateIndexRequest& a, CreateIndexRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIndexRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIndexRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateIndexRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateIndexRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateIndexRequest& from) {
    CreateIndexRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIndexRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.CreateIndexRequest";
  }
  protected:
  explicit CreateIndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 5,
    kIndexParaListFieldNumber = 6,
    kDbNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kIndexNameFieldNumber = 3,
    kMethodTypeFieldNumber = 4,
    kOptionsFieldNumber = 7,
    kSessionIdFieldNumber = 8,
  };
  // repeated string column_names = 5;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // repeated .infinity_grpc_proto.InitParameter index_para_list = 6;
  int index_para_list_size() const;
  private:
  int _internal_index_para_list_size() const;
  public:
  void clear_index_para_list();
  ::infinity_grpc_proto::InitParameter* mutable_index_para_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::InitParameter >*
      mutable_index_para_list();
  private:
  const ::infinity_grpc_proto::InitParameter& _internal_index_para_list(int index) const;
  ::infinity_grpc_proto::InitParameter* _internal_add_index_para_list();
  public:
  const ::infinity_grpc_proto::InitParameter& index_para_list(int index) const;
  ::infinity_grpc_proto::InitParameter* add_index_para_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::InitParameter >&
      index_para_list() const;

  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string index_name = 3;
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_NODISCARD std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // string method_type = 4;
  void clear_method_type();
  const std::string& method_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method_type();
  PROTOBUF_NODISCARD std::string* release_method_type();
  void set_allocated_method_type(std::string* method_type);
  private:
  const std::string& _internal_method_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method_type(const std::string& value);
  std::string* _internal_mutable_method_type();
  public:

  // .infinity_grpc_proto.Options options = 7;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::infinity_grpc_proto::Options& options() const;
  PROTOBUF_NODISCARD ::infinity_grpc_proto::Options* release_options();
  ::infinity_grpc_proto::Options* mutable_options();
  void set_allocated_options(::infinity_grpc_proto::Options* options);
  private:
  const ::infinity_grpc_proto::Options& _internal_options() const;
  ::infinity_grpc_proto::Options* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::infinity_grpc_proto::Options* options);
  ::infinity_grpc_proto::Options* unsafe_arena_release_options();

  // uint64 session_id = 8;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.CreateIndexRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::InitParameter > index_para_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_type_;
    ::infinity_grpc_proto::Options* options_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class InitParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.InitParameter) */ {
 public:
  inline InitParameter() : InitParameter(nullptr) {}
  ~InitParameter() override;
  explicit PROTOBUF_CONSTEXPR InitParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitParameter(const InitParameter& from);
  InitParameter(InitParameter&& from) noexcept
    : InitParameter() {
    *this = ::std::move(from);
  }

  inline InitParameter& operator=(const InitParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitParameter& operator=(InitParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitParameter* internal_default_instance() {
    return reinterpret_cast<const InitParameter*>(
               &_InitParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(InitParameter& a, InitParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(InitParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InitParameter& from) {
    InitParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.InitParameter";
  }
  protected:
  explicit InitParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParaNameFieldNumber = 1,
    kParaValueFieldNumber = 2,
  };
  // string para_name = 1;
  void clear_para_name();
  const std::string& para_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_para_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_para_name();
  PROTOBUF_NODISCARD std::string* release_para_name();
  void set_allocated_para_name(std::string* para_name);
  private:
  const std::string& _internal_para_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_para_name(const std::string& value);
  std::string* _internal_mutable_para_name();
  public:

  // string para_value = 2;
  void clear_para_value();
  const std::string& para_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_para_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_para_value();
  PROTOBUF_NODISCARD std::string* release_para_value();
  void set_allocated_para_value(std::string* para_value);
  private:
  const std::string& _internal_para_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_para_value(const std::string& value);
  std::string* _internal_mutable_para_value();
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.InitParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr para_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr para_value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DropIndexRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:infinity_grpc_proto.DropIndexRequest) */ {
 public:
  inline DropIndexRequest() : DropIndexRequest(nullptr) {}
  ~DropIndexRequest() override;
  explicit PROTOBUF_CONSTEXPR DropIndexRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropIndexRequest(const DropIndexRequest& from);
  DropIndexRequest(DropIndexRequest&& from) noexcept
    : DropIndexRequest() {
    *this = ::std::move(from);
  }

  inline DropIndexRequest& operator=(const DropIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropIndexRequest& operator=(DropIndexRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropIndexRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropIndexRequest* internal_default_instance() {
    return reinterpret_cast<const DropIndexRequest*>(
               &_DropIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DropIndexRequest& a, DropIndexRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropIndexRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropIndexRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropIndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropIndexRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropIndexRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DropIndexRequest& from) {
    DropIndexRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropIndexRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "infinity_grpc_proto.DropIndexRequest";
  }
  protected:
  explicit DropIndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDbNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kIndexNameFieldNumber = 3,
    kSessionIdFieldNumber = 4,
  };
  // string db_name = 1;
  void clear_db_name();
  const std::string& db_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_db_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_db_name();
  PROTOBUF_NODISCARD std::string* release_db_name();
  void set_allocated_db_name(std::string* db_name);
  private:
  const std::string& _internal_db_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db_name(const std::string& value);
  std::string* _internal_mutable_db_name();
  public:

  // string table_name = 2;
  void clear_table_name();
  const std::string& table_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_table_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_table_name();
  PROTOBUF_NODISCARD std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);
  private:
  const std::string& _internal_table_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_table_name(const std::string& value);
  std::string* _internal_mutable_table_name();
  public:

  // string index_name = 3;
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_NODISCARD std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // uint64 session_id = 4;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:infinity_grpc_proto.DropIndexRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
    uint64_t session_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_infinity_5fgrpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Options

// -------------------------------------------------------------------

// CreateDatabaseRequest

// string db_name = 1;
inline void CreateDatabaseRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& CreateDatabaseRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateDatabaseRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDatabaseRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateDatabaseRequest.db_name)
}
inline std::string* CreateDatabaseRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateDatabaseRequest.db_name)
  return _s;
}
inline const std::string& CreateDatabaseRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void CreateDatabaseRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDatabaseRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDatabaseRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateDatabaseRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void CreateDatabaseRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateDatabaseRequest.db_name)
}

// .infinity_grpc_proto.Options options = 2;
inline bool CreateDatabaseRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool CreateDatabaseRequest::has_options() const {
  return _internal_has_options();
}
inline void CreateDatabaseRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::infinity_grpc_proto::Options& CreateDatabaseRequest::_internal_options() const {
  const ::infinity_grpc_proto::Options* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::Options&>(
      ::infinity_grpc_proto::_Options_default_instance_);
}
inline const ::infinity_grpc_proto::Options& CreateDatabaseRequest::options() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateDatabaseRequest.options)
  return _internal_options();
}
inline void CreateDatabaseRequest::unsafe_arena_set_allocated_options(
    ::infinity_grpc_proto::Options* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.CreateDatabaseRequest.options)
}
inline ::infinity_grpc_proto::Options* CreateDatabaseRequest::release_options() {
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::Options* CreateDatabaseRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateDatabaseRequest.options)
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::Options* CreateDatabaseRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::Options>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::infinity_grpc_proto::Options* CreateDatabaseRequest::mutable_options() {
  ::infinity_grpc_proto::Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateDatabaseRequest.options)
  return _msg;
}
inline void CreateDatabaseRequest::set_allocated_options(::infinity_grpc_proto::Options* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateDatabaseRequest.options)
}

// uint64 session_id = 3;
inline void CreateDatabaseRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t CreateDatabaseRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t CreateDatabaseRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateDatabaseRequest.session_id)
  return _internal_session_id();
}
inline void CreateDatabaseRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void CreateDatabaseRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateDatabaseRequest.session_id)
}

// -------------------------------------------------------------------

// DropDatabaseRequest

// string db_name = 1;
inline void DropDatabaseRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& DropDatabaseRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropDatabaseRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropDatabaseRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropDatabaseRequest.db_name)
}
inline std::string* DropDatabaseRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DropDatabaseRequest.db_name)
  return _s;
}
inline const std::string& DropDatabaseRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void DropDatabaseRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropDatabaseRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropDatabaseRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DropDatabaseRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void DropDatabaseRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DropDatabaseRequest.db_name)
}

// .infinity_grpc_proto.Options options = 2;
inline bool DropDatabaseRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool DropDatabaseRequest::has_options() const {
  return _internal_has_options();
}
inline void DropDatabaseRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::infinity_grpc_proto::Options& DropDatabaseRequest::_internal_options() const {
  const ::infinity_grpc_proto::Options* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::Options&>(
      ::infinity_grpc_proto::_Options_default_instance_);
}
inline const ::infinity_grpc_proto::Options& DropDatabaseRequest::options() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropDatabaseRequest.options)
  return _internal_options();
}
inline void DropDatabaseRequest::unsafe_arena_set_allocated_options(
    ::infinity_grpc_proto::Options* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.DropDatabaseRequest.options)
}
inline ::infinity_grpc_proto::Options* DropDatabaseRequest::release_options() {
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::Options* DropDatabaseRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DropDatabaseRequest.options)
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::Options* DropDatabaseRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::Options>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::infinity_grpc_proto::Options* DropDatabaseRequest::mutable_options() {
  ::infinity_grpc_proto::Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DropDatabaseRequest.options)
  return _msg;
}
inline void DropDatabaseRequest::set_allocated_options(::infinity_grpc_proto::Options* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DropDatabaseRequest.options)
}

// uint64 session_id = 3;
inline void DropDatabaseRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t DropDatabaseRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t DropDatabaseRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropDatabaseRequest.session_id)
  return _internal_session_id();
}
inline void DropDatabaseRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void DropDatabaseRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropDatabaseRequest.session_id)
}

// -------------------------------------------------------------------

// CreateTableRequest

// string db_name = 1;
inline void CreateTableRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& CreateTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateTableRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateTableRequest.db_name)
}
inline std::string* CreateTableRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateTableRequest.db_name)
  return _s;
}
inline const std::string& CreateTableRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void CreateTableRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateTableRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void CreateTableRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateTableRequest.db_name)
}

// string table_name = 2;
inline void CreateTableRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& CreateTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateTableRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateTableRequest.table_name)
}
inline std::string* CreateTableRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateTableRequest.table_name)
  return _s;
}
inline const std::string& CreateTableRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void CreateTableRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateTableRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void CreateTableRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateTableRequest.table_name)
}

// repeated .infinity_grpc_proto.ColumnDef column_defs = 3;
inline int CreateTableRequest::_internal_column_defs_size() const {
  return _impl_.column_defs_.size();
}
inline int CreateTableRequest::column_defs_size() const {
  return _internal_column_defs_size();
}
inline void CreateTableRequest::clear_column_defs() {
  _impl_.column_defs_.Clear();
}
inline ::infinity_grpc_proto::ColumnDef* CreateTableRequest::mutable_column_defs(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateTableRequest.column_defs)
  return _impl_.column_defs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef >*
CreateTableRequest::mutable_column_defs() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.CreateTableRequest.column_defs)
  return &_impl_.column_defs_;
}
inline const ::infinity_grpc_proto::ColumnDef& CreateTableRequest::_internal_column_defs(int index) const {
  return _impl_.column_defs_.Get(index);
}
inline const ::infinity_grpc_proto::ColumnDef& CreateTableRequest::column_defs(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateTableRequest.column_defs)
  return _internal_column_defs(index);
}
inline ::infinity_grpc_proto::ColumnDef* CreateTableRequest::_internal_add_column_defs() {
  return _impl_.column_defs_.Add();
}
inline ::infinity_grpc_proto::ColumnDef* CreateTableRequest::add_column_defs() {
  ::infinity_grpc_proto::ColumnDef* _add = _internal_add_column_defs();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.CreateTableRequest.column_defs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef >&
CreateTableRequest::column_defs() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.CreateTableRequest.column_defs)
  return _impl_.column_defs_;
}

// .infinity_grpc_proto.Options options = 5;
inline bool CreateTableRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool CreateTableRequest::has_options() const {
  return _internal_has_options();
}
inline void CreateTableRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::infinity_grpc_proto::Options& CreateTableRequest::_internal_options() const {
  const ::infinity_grpc_proto::Options* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::Options&>(
      ::infinity_grpc_proto::_Options_default_instance_);
}
inline const ::infinity_grpc_proto::Options& CreateTableRequest::options() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateTableRequest.options)
  return _internal_options();
}
inline void CreateTableRequest::unsafe_arena_set_allocated_options(
    ::infinity_grpc_proto::Options* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.CreateTableRequest.options)
}
inline ::infinity_grpc_proto::Options* CreateTableRequest::release_options() {
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::Options* CreateTableRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateTableRequest.options)
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::Options* CreateTableRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::Options>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::infinity_grpc_proto::Options* CreateTableRequest::mutable_options() {
  ::infinity_grpc_proto::Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateTableRequest.options)
  return _msg;
}
inline void CreateTableRequest::set_allocated_options(::infinity_grpc_proto::Options* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateTableRequest.options)
}

// uint64 session_id = 6;
inline void CreateTableRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t CreateTableRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t CreateTableRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateTableRequest.session_id)
  return _internal_session_id();
}
inline void CreateTableRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void CreateTableRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateTableRequest.session_id)
}

// -------------------------------------------------------------------

// ColumnConstraint

// string column_name = 1;
inline void ColumnConstraint::clear_column_name() {
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& ColumnConstraint::column_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnConstraint.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnConstraint::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnConstraint.column_name)
}
inline std::string* ColumnConstraint::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ColumnConstraint.column_name)
  return _s;
}
inline const std::string& ColumnConstraint::_internal_column_name() const {
  return _impl_.column_name_.Get();
}
inline void ColumnConstraint::_internal_set_column_name(const std::string& value) {
  
  _impl_.column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnConstraint::_internal_mutable_column_name() {
  
  return _impl_.column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnConstraint::release_column_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ColumnConstraint.column_name)
  return _impl_.column_name_.Release();
}
inline void ColumnConstraint::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  _impl_.column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_name_.IsDefault()) {
    _impl_.column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ColumnConstraint.column_name)
}

// repeated .infinity_grpc_proto.Constraint constraint = 2;
inline int ColumnConstraint::_internal_constraint_size() const {
  return _impl_.constraint_.size();
}
inline int ColumnConstraint::constraint_size() const {
  return _internal_constraint_size();
}
inline void ColumnConstraint::clear_constraint() {
  _impl_.constraint_.Clear();
}
inline ::infinity_grpc_proto::Constraint ColumnConstraint::_internal_constraint(int index) const {
  return static_cast< ::infinity_grpc_proto::Constraint >(_impl_.constraint_.Get(index));
}
inline ::infinity_grpc_proto::Constraint ColumnConstraint::constraint(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnConstraint.constraint)
  return _internal_constraint(index);
}
inline void ColumnConstraint::set_constraint(int index, ::infinity_grpc_proto::Constraint value) {
  _impl_.constraint_.Set(index, value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnConstraint.constraint)
}
inline void ColumnConstraint::_internal_add_constraint(::infinity_grpc_proto::Constraint value) {
  _impl_.constraint_.Add(value);
}
inline void ColumnConstraint::add_constraint(::infinity_grpc_proto::Constraint value) {
  _internal_add_constraint(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ColumnConstraint.constraint)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ColumnConstraint::constraint() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.ColumnConstraint.constraint)
  return _impl_.constraint_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ColumnConstraint::_internal_mutable_constraint() {
  return &_impl_.constraint_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ColumnConstraint::mutable_constraint() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.ColumnConstraint.constraint)
  return _internal_mutable_constraint();
}

// -------------------------------------------------------------------

// ColumnDef

// int32 id = 1;
inline void ColumnDef::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t ColumnDef::_internal_id() const {
  return _impl_.id_;
}
inline int32_t ColumnDef::id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnDef.id)
  return _internal_id();
}
inline void ColumnDef::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void ColumnDef::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnDef.id)
}

// string name = 2;
inline void ColumnDef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ColumnDef::name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnDef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnDef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnDef.name)
}
inline std::string* ColumnDef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ColumnDef.name)
  return _s;
}
inline const std::string& ColumnDef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ColumnDef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnDef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnDef::release_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ColumnDef.name)
  return _impl_.name_.Release();
}
inline void ColumnDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ColumnDef.name)
}

// .infinity_grpc_proto.DataType column_type = 3;
inline bool ColumnDef::_internal_has_column_type() const {
  return this != internal_default_instance() && _impl_.column_type_ != nullptr;
}
inline bool ColumnDef::has_column_type() const {
  return _internal_has_column_type();
}
inline void ColumnDef::clear_column_type() {
  if (GetArenaForAllocation() == nullptr && _impl_.column_type_ != nullptr) {
    delete _impl_.column_type_;
  }
  _impl_.column_type_ = nullptr;
}
inline const ::infinity_grpc_proto::DataType& ColumnDef::_internal_column_type() const {
  const ::infinity_grpc_proto::DataType* p = _impl_.column_type_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::DataType&>(
      ::infinity_grpc_proto::_DataType_default_instance_);
}
inline const ::infinity_grpc_proto::DataType& ColumnDef::column_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnDef.column_type)
  return _internal_column_type();
}
inline void ColumnDef::unsafe_arena_set_allocated_column_type(
    ::infinity_grpc_proto::DataType* column_type) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_type_);
  }
  _impl_.column_type_ = column_type;
  if (column_type) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.ColumnDef.column_type)
}
inline ::infinity_grpc_proto::DataType* ColumnDef::release_column_type() {
  
  ::infinity_grpc_proto::DataType* temp = _impl_.column_type_;
  _impl_.column_type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::DataType* ColumnDef::unsafe_arena_release_column_type() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ColumnDef.column_type)
  
  ::infinity_grpc_proto::DataType* temp = _impl_.column_type_;
  _impl_.column_type_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::DataType* ColumnDef::_internal_mutable_column_type() {
  
  if (_impl_.column_type_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::DataType>(GetArenaForAllocation());
    _impl_.column_type_ = p;
  }
  return _impl_.column_type_;
}
inline ::infinity_grpc_proto::DataType* ColumnDef::mutable_column_type() {
  ::infinity_grpc_proto::DataType* _msg = _internal_mutable_column_type();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ColumnDef.column_type)
  return _msg;
}
inline void ColumnDef::set_allocated_column_type(::infinity_grpc_proto::DataType* column_type) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.column_type_;
  }
  if (column_type) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(column_type);
    if (message_arena != submessage_arena) {
      column_type = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_type, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.column_type_ = column_type;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ColumnDef.column_type)
}

// repeated .infinity_grpc_proto.Constraint constraints = 4;
inline int ColumnDef::_internal_constraints_size() const {
  return _impl_.constraints_.size();
}
inline int ColumnDef::constraints_size() const {
  return _internal_constraints_size();
}
inline void ColumnDef::clear_constraints() {
  _impl_.constraints_.Clear();
}
inline ::infinity_grpc_proto::Constraint ColumnDef::_internal_constraints(int index) const {
  return static_cast< ::infinity_grpc_proto::Constraint >(_impl_.constraints_.Get(index));
}
inline ::infinity_grpc_proto::Constraint ColumnDef::constraints(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnDef.constraints)
  return _internal_constraints(index);
}
inline void ColumnDef::set_constraints(int index, ::infinity_grpc_proto::Constraint value) {
  _impl_.constraints_.Set(index, value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnDef.constraints)
}
inline void ColumnDef::_internal_add_constraints(::infinity_grpc_proto::Constraint value) {
  _impl_.constraints_.Add(value);
}
inline void ColumnDef::add_constraints(::infinity_grpc_proto::Constraint value) {
  _internal_add_constraints(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ColumnDef.constraints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ColumnDef::constraints() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.ColumnDef.constraints)
  return _impl_.constraints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ColumnDef::_internal_mutable_constraints() {
  return &_impl_.constraints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ColumnDef::mutable_constraints() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.ColumnDef.constraints)
  return _internal_mutable_constraints();
}

// -------------------------------------------------------------------

// DataType

// .infinity_grpc_proto.LogicType logic_type = 1;
inline void DataType::clear_logic_type() {
  _impl_.logic_type_ = 0;
}
inline ::infinity_grpc_proto::LogicType DataType::_internal_logic_type() const {
  return static_cast< ::infinity_grpc_proto::LogicType >(_impl_.logic_type_);
}
inline ::infinity_grpc_proto::LogicType DataType::logic_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataType.logic_type)
  return _internal_logic_type();
}
inline void DataType::_internal_set_logic_type(::infinity_grpc_proto::LogicType value) {
  
  _impl_.logic_type_ = value;
}
inline void DataType::set_logic_type(::infinity_grpc_proto::LogicType value) {
  _internal_set_logic_type(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DataType.logic_type)
}

// .infinity_grpc_proto.NumberType number_type = 2;
inline bool DataType::_internal_has_number_type() const {
  return PhysicalType_case() == kNumberType;
}
inline bool DataType::has_number_type() const {
  return _internal_has_number_type();
}
inline void DataType::set_has_number_type() {
  _impl_._oneof_case_[0] = kNumberType;
}
inline void DataType::clear_number_type() {
  if (_internal_has_number_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.PhysicalType_.number_type_;
    }
    clear_has_PhysicalType();
  }
}
inline ::infinity_grpc_proto::NumberType* DataType::release_number_type() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DataType.number_type)
  if (_internal_has_number_type()) {
    clear_has_PhysicalType();
    ::infinity_grpc_proto::NumberType* temp = _impl_.PhysicalType_.number_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.PhysicalType_.number_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::infinity_grpc_proto::NumberType& DataType::_internal_number_type() const {
  return _internal_has_number_type()
      ? *_impl_.PhysicalType_.number_type_
      : reinterpret_cast< ::infinity_grpc_proto::NumberType&>(::infinity_grpc_proto::_NumberType_default_instance_);
}
inline const ::infinity_grpc_proto::NumberType& DataType::number_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataType.number_type)
  return _internal_number_type();
}
inline ::infinity_grpc_proto::NumberType* DataType::unsafe_arena_release_number_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infinity_grpc_proto.DataType.number_type)
  if (_internal_has_number_type()) {
    clear_has_PhysicalType();
    ::infinity_grpc_proto::NumberType* temp = _impl_.PhysicalType_.number_type_;
    _impl_.PhysicalType_.number_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataType::unsafe_arena_set_allocated_number_type(::infinity_grpc_proto::NumberType* number_type) {
  clear_PhysicalType();
  if (number_type) {
    set_has_number_type();
    _impl_.PhysicalType_.number_type_ = number_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.DataType.number_type)
}
inline ::infinity_grpc_proto::NumberType* DataType::_internal_mutable_number_type() {
  if (!_internal_has_number_type()) {
    clear_PhysicalType();
    set_has_number_type();
    _impl_.PhysicalType_.number_type_ = CreateMaybeMessage< ::infinity_grpc_proto::NumberType >(GetArenaForAllocation());
  }
  return _impl_.PhysicalType_.number_type_;
}
inline ::infinity_grpc_proto::NumberType* DataType::mutable_number_type() {
  ::infinity_grpc_proto::NumberType* _msg = _internal_mutable_number_type();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DataType.number_type)
  return _msg;
}

// .infinity_grpc_proto.VarcharType varchar_type = 3;
inline bool DataType::_internal_has_varchar_type() const {
  return PhysicalType_case() == kVarcharType;
}
inline bool DataType::has_varchar_type() const {
  return _internal_has_varchar_type();
}
inline void DataType::set_has_varchar_type() {
  _impl_._oneof_case_[0] = kVarcharType;
}
inline void DataType::clear_varchar_type() {
  if (_internal_has_varchar_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.PhysicalType_.varchar_type_;
    }
    clear_has_PhysicalType();
  }
}
inline ::infinity_grpc_proto::VarcharType* DataType::release_varchar_type() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DataType.varchar_type)
  if (_internal_has_varchar_type()) {
    clear_has_PhysicalType();
    ::infinity_grpc_proto::VarcharType* temp = _impl_.PhysicalType_.varchar_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.PhysicalType_.varchar_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::infinity_grpc_proto::VarcharType& DataType::_internal_varchar_type() const {
  return _internal_has_varchar_type()
      ? *_impl_.PhysicalType_.varchar_type_
      : reinterpret_cast< ::infinity_grpc_proto::VarcharType&>(::infinity_grpc_proto::_VarcharType_default_instance_);
}
inline const ::infinity_grpc_proto::VarcharType& DataType::varchar_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataType.varchar_type)
  return _internal_varchar_type();
}
inline ::infinity_grpc_proto::VarcharType* DataType::unsafe_arena_release_varchar_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infinity_grpc_proto.DataType.varchar_type)
  if (_internal_has_varchar_type()) {
    clear_has_PhysicalType();
    ::infinity_grpc_proto::VarcharType* temp = _impl_.PhysicalType_.varchar_type_;
    _impl_.PhysicalType_.varchar_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataType::unsafe_arena_set_allocated_varchar_type(::infinity_grpc_proto::VarcharType* varchar_type) {
  clear_PhysicalType();
  if (varchar_type) {
    set_has_varchar_type();
    _impl_.PhysicalType_.varchar_type_ = varchar_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.DataType.varchar_type)
}
inline ::infinity_grpc_proto::VarcharType* DataType::_internal_mutable_varchar_type() {
  if (!_internal_has_varchar_type()) {
    clear_PhysicalType();
    set_has_varchar_type();
    _impl_.PhysicalType_.varchar_type_ = CreateMaybeMessage< ::infinity_grpc_proto::VarcharType >(GetArenaForAllocation());
  }
  return _impl_.PhysicalType_.varchar_type_;
}
inline ::infinity_grpc_proto::VarcharType* DataType::mutable_varchar_type() {
  ::infinity_grpc_proto::VarcharType* _msg = _internal_mutable_varchar_type();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DataType.varchar_type)
  return _msg;
}

// .infinity_grpc_proto.EmbeddingType embedding_type = 4;
inline bool DataType::_internal_has_embedding_type() const {
  return PhysicalType_case() == kEmbeddingType;
}
inline bool DataType::has_embedding_type() const {
  return _internal_has_embedding_type();
}
inline void DataType::set_has_embedding_type() {
  _impl_._oneof_case_[0] = kEmbeddingType;
}
inline void DataType::clear_embedding_type() {
  if (_internal_has_embedding_type()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.PhysicalType_.embedding_type_;
    }
    clear_has_PhysicalType();
  }
}
inline ::infinity_grpc_proto::EmbeddingType* DataType::release_embedding_type() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DataType.embedding_type)
  if (_internal_has_embedding_type()) {
    clear_has_PhysicalType();
    ::infinity_grpc_proto::EmbeddingType* temp = _impl_.PhysicalType_.embedding_type_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.PhysicalType_.embedding_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::infinity_grpc_proto::EmbeddingType& DataType::_internal_embedding_type() const {
  return _internal_has_embedding_type()
      ? *_impl_.PhysicalType_.embedding_type_
      : reinterpret_cast< ::infinity_grpc_proto::EmbeddingType&>(::infinity_grpc_proto::_EmbeddingType_default_instance_);
}
inline const ::infinity_grpc_proto::EmbeddingType& DataType::embedding_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataType.embedding_type)
  return _internal_embedding_type();
}
inline ::infinity_grpc_proto::EmbeddingType* DataType::unsafe_arena_release_embedding_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infinity_grpc_proto.DataType.embedding_type)
  if (_internal_has_embedding_type()) {
    clear_has_PhysicalType();
    ::infinity_grpc_proto::EmbeddingType* temp = _impl_.PhysicalType_.embedding_type_;
    _impl_.PhysicalType_.embedding_type_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DataType::unsafe_arena_set_allocated_embedding_type(::infinity_grpc_proto::EmbeddingType* embedding_type) {
  clear_PhysicalType();
  if (embedding_type) {
    set_has_embedding_type();
    _impl_.PhysicalType_.embedding_type_ = embedding_type;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.DataType.embedding_type)
}
inline ::infinity_grpc_proto::EmbeddingType* DataType::_internal_mutable_embedding_type() {
  if (!_internal_has_embedding_type()) {
    clear_PhysicalType();
    set_has_embedding_type();
    _impl_.PhysicalType_.embedding_type_ = CreateMaybeMessage< ::infinity_grpc_proto::EmbeddingType >(GetArenaForAllocation());
  }
  return _impl_.PhysicalType_.embedding_type_;
}
inline ::infinity_grpc_proto::EmbeddingType* DataType::mutable_embedding_type() {
  ::infinity_grpc_proto::EmbeddingType* _msg = _internal_mutable_embedding_type();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DataType.embedding_type)
  return _msg;
}

inline bool DataType::has_PhysicalType() const {
  return PhysicalType_case() != PHYSICALTYPE_NOT_SET;
}
inline void DataType::clear_has_PhysicalType() {
  _impl_._oneof_case_[0] = PHYSICALTYPE_NOT_SET;
}
inline DataType::PhysicalTypeCase DataType::PhysicalType_case() const {
  return DataType::PhysicalTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EmbeddingType

// .infinity_grpc_proto.ElementType embedding_data_type = 1;
inline void EmbeddingType::clear_embedding_data_type() {
  _impl_.embedding_data_type_ = 0;
}
inline ::infinity_grpc_proto::ElementType EmbeddingType::_internal_embedding_data_type() const {
  return static_cast< ::infinity_grpc_proto::ElementType >(_impl_.embedding_data_type_);
}
inline ::infinity_grpc_proto::ElementType EmbeddingType::embedding_data_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.EmbeddingType.embedding_data_type)
  return _internal_embedding_data_type();
}
inline void EmbeddingType::_internal_set_embedding_data_type(::infinity_grpc_proto::ElementType value) {
  
  _impl_.embedding_data_type_ = value;
}
inline void EmbeddingType::set_embedding_data_type(::infinity_grpc_proto::ElementType value) {
  _internal_set_embedding_data_type(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.EmbeddingType.embedding_data_type)
}

// int32 dimension = 2;
inline void EmbeddingType::clear_dimension() {
  _impl_.dimension_ = 0;
}
inline int32_t EmbeddingType::_internal_dimension() const {
  return _impl_.dimension_;
}
inline int32_t EmbeddingType::dimension() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.EmbeddingType.dimension)
  return _internal_dimension();
}
inline void EmbeddingType::_internal_set_dimension(int32_t value) {
  
  _impl_.dimension_ = value;
}
inline void EmbeddingType::set_dimension(int32_t value) {
  _internal_set_dimension(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.EmbeddingType.dimension)
}

// -------------------------------------------------------------------

// VarcharType

// int32 width = 1;
inline void VarcharType::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t VarcharType::_internal_width() const {
  return _impl_.width_;
}
inline int32_t VarcharType::width() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.VarcharType.width)
  return _internal_width();
}
inline void VarcharType::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void VarcharType::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.VarcharType.width)
}

// -------------------------------------------------------------------

// NumberType

// -------------------------------------------------------------------

// DropTableRequest

// string db_name = 1;
inline void DropTableRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& DropTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropTableRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropTableRequest.db_name)
}
inline std::string* DropTableRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DropTableRequest.db_name)
  return _s;
}
inline const std::string& DropTableRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void DropTableRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DropTableRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void DropTableRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DropTableRequest.db_name)
}

// string table_name = 2;
inline void DropTableRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DropTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropTableRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropTableRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropTableRequest.table_name)
}
inline std::string* DropTableRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DropTableRequest.table_name)
  return _s;
}
inline const std::string& DropTableRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DropTableRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropTableRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DropTableRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void DropTableRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DropTableRequest.table_name)
}

// .infinity_grpc_proto.Options options = 3;
inline bool DropTableRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool DropTableRequest::has_options() const {
  return _internal_has_options();
}
inline void DropTableRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::infinity_grpc_proto::Options& DropTableRequest::_internal_options() const {
  const ::infinity_grpc_proto::Options* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::Options&>(
      ::infinity_grpc_proto::_Options_default_instance_);
}
inline const ::infinity_grpc_proto::Options& DropTableRequest::options() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropTableRequest.options)
  return _internal_options();
}
inline void DropTableRequest::unsafe_arena_set_allocated_options(
    ::infinity_grpc_proto::Options* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.DropTableRequest.options)
}
inline ::infinity_grpc_proto::Options* DropTableRequest::release_options() {
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::Options* DropTableRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DropTableRequest.options)
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::Options* DropTableRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::Options>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::infinity_grpc_proto::Options* DropTableRequest::mutable_options() {
  ::infinity_grpc_proto::Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DropTableRequest.options)
  return _msg;
}
inline void DropTableRequest::set_allocated_options(::infinity_grpc_proto::Options* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DropTableRequest.options)
}

// uint64 session_id = 4;
inline void DropTableRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t DropTableRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t DropTableRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropTableRequest.session_id)
  return _internal_session_id();
}
inline void DropTableRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void DropTableRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropTableRequest.session_id)
}

// -------------------------------------------------------------------

// InsertRequest

// string db_name = 1;
inline void InsertRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& InsertRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InsertRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.InsertRequest.db_name)
}
inline std::string* InsertRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.InsertRequest.db_name)
  return _s;
}
inline const std::string& InsertRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void InsertRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.InsertRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void InsertRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.InsertRequest.db_name)
}

// string table_name = 2;
inline void InsertRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& InsertRequest::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InsertRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InsertRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.InsertRequest.table_name)
}
inline std::string* InsertRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.InsertRequest.table_name)
  return _s;
}
inline const std::string& InsertRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void InsertRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InsertRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InsertRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.InsertRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void InsertRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.InsertRequest.table_name)
}

// repeated string column_names = 3;
inline int InsertRequest::_internal_column_names_size() const {
  return _impl_.column_names_.size();
}
inline int InsertRequest::column_names_size() const {
  return _internal_column_names_size();
}
inline void InsertRequest::clear_column_names() {
  _impl_.column_names_.Clear();
}
inline std::string* InsertRequest::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:infinity_grpc_proto.InsertRequest.column_names)
  return _s;
}
inline const std::string& InsertRequest::_internal_column_names(int index) const {
  return _impl_.column_names_.Get(index);
}
inline const std::string& InsertRequest::column_names(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InsertRequest.column_names)
  return _internal_column_names(index);
}
inline std::string* InsertRequest::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.InsertRequest.column_names)
  return _impl_.column_names_.Mutable(index);
}
inline void InsertRequest::set_column_names(int index, const std::string& value) {
  _impl_.column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.InsertRequest.column_names)
}
inline void InsertRequest::set_column_names(int index, std::string&& value) {
  _impl_.column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.InsertRequest.column_names)
}
inline void InsertRequest::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:infinity_grpc_proto.InsertRequest.column_names)
}
inline void InsertRequest::set_column_names(int index, const char* value, size_t size) {
  _impl_.column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:infinity_grpc_proto.InsertRequest.column_names)
}
inline std::string* InsertRequest::_internal_add_column_names() {
  return _impl_.column_names_.Add();
}
inline void InsertRequest::add_column_names(const std::string& value) {
  _impl_.column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.InsertRequest.column_names)
}
inline void InsertRequest::add_column_names(std::string&& value) {
  _impl_.column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.InsertRequest.column_names)
}
inline void InsertRequest::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:infinity_grpc_proto.InsertRequest.column_names)
}
inline void InsertRequest::add_column_names(const char* value, size_t size) {
  _impl_.column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:infinity_grpc_proto.InsertRequest.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InsertRequest::column_names() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.InsertRequest.column_names)
  return _impl_.column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InsertRequest::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.InsertRequest.column_names)
  return &_impl_.column_names_;
}

// repeated .infinity_grpc_proto.Field fields = 4;
inline int InsertRequest::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int InsertRequest::fields_size() const {
  return _internal_fields_size();
}
inline void InsertRequest::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::infinity_grpc_proto::Field* InsertRequest::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.InsertRequest.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::Field >*
InsertRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.InsertRequest.fields)
  return &_impl_.fields_;
}
inline const ::infinity_grpc_proto::Field& InsertRequest::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::infinity_grpc_proto::Field& InsertRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InsertRequest.fields)
  return _internal_fields(index);
}
inline ::infinity_grpc_proto::Field* InsertRequest::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::infinity_grpc_proto::Field* InsertRequest::add_fields() {
  ::infinity_grpc_proto::Field* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.InsertRequest.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::Field >&
InsertRequest::fields() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.InsertRequest.fields)
  return _impl_.fields_;
}

// uint64 session_id = 5;
inline void InsertRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t InsertRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t InsertRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InsertRequest.session_id)
  return _internal_session_id();
}
inline void InsertRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void InsertRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.InsertRequest.session_id)
}

// -------------------------------------------------------------------

// Field

// repeated .infinity_grpc_proto.ParsedExpr parse_exprs = 1;
inline int Field::_internal_parse_exprs_size() const {
  return _impl_.parse_exprs_.size();
}
inline int Field::parse_exprs_size() const {
  return _internal_parse_exprs_size();
}
inline void Field::clear_parse_exprs() {
  _impl_.parse_exprs_.Clear();
}
inline ::infinity_grpc_proto::ParsedExpr* Field::mutable_parse_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.Field.parse_exprs)
  return _impl_.parse_exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
Field::mutable_parse_exprs() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.Field.parse_exprs)
  return &_impl_.parse_exprs_;
}
inline const ::infinity_grpc_proto::ParsedExpr& Field::_internal_parse_exprs(int index) const {
  return _impl_.parse_exprs_.Get(index);
}
inline const ::infinity_grpc_proto::ParsedExpr& Field::parse_exprs(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.Field.parse_exprs)
  return _internal_parse_exprs(index);
}
inline ::infinity_grpc_proto::ParsedExpr* Field::_internal_add_parse_exprs() {
  return _impl_.parse_exprs_.Add();
}
inline ::infinity_grpc_proto::ParsedExpr* Field::add_parse_exprs() {
  ::infinity_grpc_proto::ParsedExpr* _add = _internal_add_parse_exprs();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.Field.parse_exprs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
Field::parse_exprs() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.Field.parse_exprs)
  return _impl_.parse_exprs_;
}

// -------------------------------------------------------------------

// ImportRequest_ImportOptions

// string delimiter = 1;
inline void ImportRequest_ImportOptions::clear_delimiter() {
  _impl_.delimiter_.ClearToEmpty();
}
inline const std::string& ImportRequest_ImportOptions::delimiter() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.ImportOptions.delimiter)
  return _internal_delimiter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportRequest_ImportOptions::set_delimiter(ArgT0&& arg0, ArgT... args) {
 
 _impl_.delimiter_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.ImportOptions.delimiter)
}
inline std::string* ImportRequest_ImportOptions::mutable_delimiter() {
  std::string* _s = _internal_mutable_delimiter();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ImportRequest.ImportOptions.delimiter)
  return _s;
}
inline const std::string& ImportRequest_ImportOptions::_internal_delimiter() const {
  return _impl_.delimiter_.Get();
}
inline void ImportRequest_ImportOptions::_internal_set_delimiter(const std::string& value) {
  
  _impl_.delimiter_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportRequest_ImportOptions::_internal_mutable_delimiter() {
  
  return _impl_.delimiter_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportRequest_ImportOptions::release_delimiter() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ImportRequest.ImportOptions.delimiter)
  return _impl_.delimiter_.Release();
}
inline void ImportRequest_ImportOptions::set_allocated_delimiter(std::string* delimiter) {
  if (delimiter != nullptr) {
    
  } else {
    
  }
  _impl_.delimiter_.SetAllocated(delimiter, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.delimiter_.IsDefault()) {
    _impl_.delimiter_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ImportRequest.ImportOptions.delimiter)
}

// string file_type = 2;
inline void ImportRequest_ImportOptions::clear_file_type() {
  _impl_.file_type_.ClearToEmpty();
}
inline const std::string& ImportRequest_ImportOptions::file_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.ImportOptions.file_type)
  return _internal_file_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportRequest_ImportOptions::set_file_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.ImportOptions.file_type)
}
inline std::string* ImportRequest_ImportOptions::mutable_file_type() {
  std::string* _s = _internal_mutable_file_type();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ImportRequest.ImportOptions.file_type)
  return _s;
}
inline const std::string& ImportRequest_ImportOptions::_internal_file_type() const {
  return _impl_.file_type_.Get();
}
inline void ImportRequest_ImportOptions::_internal_set_file_type(const std::string& value) {
  
  _impl_.file_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportRequest_ImportOptions::_internal_mutable_file_type() {
  
  return _impl_.file_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportRequest_ImportOptions::release_file_type() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ImportRequest.ImportOptions.file_type)
  return _impl_.file_type_.Release();
}
inline void ImportRequest_ImportOptions::set_allocated_file_type(std::string* file_type) {
  if (file_type != nullptr) {
    
  } else {
    
  }
  _impl_.file_type_.SetAllocated(file_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_type_.IsDefault()) {
    _impl_.file_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ImportRequest.ImportOptions.file_type)
}

// string table_name = 3;
inline void ImportRequest_ImportOptions::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& ImportRequest_ImportOptions::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.ImportOptions.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportRequest_ImportOptions::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.ImportOptions.table_name)
}
inline std::string* ImportRequest_ImportOptions::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ImportRequest.ImportOptions.table_name)
  return _s;
}
inline const std::string& ImportRequest_ImportOptions::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void ImportRequest_ImportOptions::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportRequest_ImportOptions::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportRequest_ImportOptions::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ImportRequest.ImportOptions.table_name)
  return _impl_.table_name_.Release();
}
inline void ImportRequest_ImportOptions::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ImportRequest.ImportOptions.table_name)
}

// string schema_name = 4;
inline void ImportRequest_ImportOptions::clear_schema_name() {
  _impl_.schema_name_.ClearToEmpty();
}
inline const std::string& ImportRequest_ImportOptions::schema_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.ImportOptions.schema_name)
  return _internal_schema_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportRequest_ImportOptions::set_schema_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.schema_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.ImportOptions.schema_name)
}
inline std::string* ImportRequest_ImportOptions::mutable_schema_name() {
  std::string* _s = _internal_mutable_schema_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ImportRequest.ImportOptions.schema_name)
  return _s;
}
inline const std::string& ImportRequest_ImportOptions::_internal_schema_name() const {
  return _impl_.schema_name_.Get();
}
inline void ImportRequest_ImportOptions::_internal_set_schema_name(const std::string& value) {
  
  _impl_.schema_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportRequest_ImportOptions::_internal_mutable_schema_name() {
  
  return _impl_.schema_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportRequest_ImportOptions::release_schema_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ImportRequest.ImportOptions.schema_name)
  return _impl_.schema_name_.Release();
}
inline void ImportRequest_ImportOptions::set_allocated_schema_name(std::string* schema_name) {
  if (schema_name != nullptr) {
    
  } else {
    
  }
  _impl_.schema_name_.SetAllocated(schema_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.schema_name_.IsDefault()) {
    _impl_.schema_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ImportRequest.ImportOptions.schema_name)
}

// bool copy_from = 5;
inline void ImportRequest_ImportOptions::clear_copy_from() {
  _impl_.copy_from_ = false;
}
inline bool ImportRequest_ImportOptions::_internal_copy_from() const {
  return _impl_.copy_from_;
}
inline bool ImportRequest_ImportOptions::copy_from() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.ImportOptions.copy_from)
  return _internal_copy_from();
}
inline void ImportRequest_ImportOptions::_internal_set_copy_from(bool value) {
  
  _impl_.copy_from_ = value;
}
inline void ImportRequest_ImportOptions::set_copy_from(bool value) {
  _internal_set_copy_from(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.ImportOptions.copy_from)
}

// bool has_header = 6;
inline void ImportRequest_ImportOptions::clear_has_header() {
  _impl_.has_header_ = false;
}
inline bool ImportRequest_ImportOptions::_internal_has_header() const {
  return _impl_.has_header_;
}
inline bool ImportRequest_ImportOptions::has_header() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.ImportOptions.has_header)
  return _internal_has_header();
}
inline void ImportRequest_ImportOptions::_internal_set_has_header(bool value) {
  
  _impl_.has_header_ = value;
}
inline void ImportRequest_ImportOptions::set_has_header(bool value) {
  _internal_set_has_header(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.ImportOptions.has_header)
}

// -------------------------------------------------------------------

// ImportRequest

// string db_name = 1;
inline void ImportRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& ImportRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.db_name)
}
inline std::string* ImportRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ImportRequest.db_name)
  return _s;
}
inline const std::string& ImportRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void ImportRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ImportRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void ImportRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ImportRequest.db_name)
}

// string table_name = 2;
inline void ImportRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& ImportRequest::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.table_name)
}
inline std::string* ImportRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ImportRequest.table_name)
  return _s;
}
inline const std::string& ImportRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void ImportRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ImportRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void ImportRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ImportRequest.table_name)
}

// string file_path = 3;
inline void ImportRequest::clear_file_path() {
  _impl_.file_path_.ClearToEmpty();
}
inline const std::string& ImportRequest::file_path() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ImportRequest::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.file_path)
}
inline std::string* ImportRequest::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ImportRequest.file_path)
  return _s;
}
inline const std::string& ImportRequest::_internal_file_path() const {
  return _impl_.file_path_.Get();
}
inline void ImportRequest::_internal_set_file_path(const std::string& value) {
  
  _impl_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* ImportRequest::_internal_mutable_file_path() {
  
  return _impl_.file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* ImportRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ImportRequest.file_path)
  return _impl_.file_path_.Release();
}
inline void ImportRequest::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  _impl_.file_path_.SetAllocated(file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_path_.IsDefault()) {
    _impl_.file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ImportRequest.file_path)
}

// .infinity_grpc_proto.ImportRequest.ImportOptions import_options = 4;
inline bool ImportRequest::_internal_has_import_options() const {
  return this != internal_default_instance() && _impl_.import_options_ != nullptr;
}
inline bool ImportRequest::has_import_options() const {
  return _internal_has_import_options();
}
inline void ImportRequest::clear_import_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.import_options_ != nullptr) {
    delete _impl_.import_options_;
  }
  _impl_.import_options_ = nullptr;
}
inline const ::infinity_grpc_proto::ImportRequest_ImportOptions& ImportRequest::_internal_import_options() const {
  const ::infinity_grpc_proto::ImportRequest_ImportOptions* p = _impl_.import_options_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ImportRequest_ImportOptions&>(
      ::infinity_grpc_proto::_ImportRequest_ImportOptions_default_instance_);
}
inline const ::infinity_grpc_proto::ImportRequest_ImportOptions& ImportRequest::import_options() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.import_options)
  return _internal_import_options();
}
inline void ImportRequest::unsafe_arena_set_allocated_import_options(
    ::infinity_grpc_proto::ImportRequest_ImportOptions* import_options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.import_options_);
  }
  _impl_.import_options_ = import_options;
  if (import_options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.ImportRequest.import_options)
}
inline ::infinity_grpc_proto::ImportRequest_ImportOptions* ImportRequest::release_import_options() {
  
  ::infinity_grpc_proto::ImportRequest_ImportOptions* temp = _impl_.import_options_;
  _impl_.import_options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ImportRequest_ImportOptions* ImportRequest::unsafe_arena_release_import_options() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ImportRequest.import_options)
  
  ::infinity_grpc_proto::ImportRequest_ImportOptions* temp = _impl_.import_options_;
  _impl_.import_options_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ImportRequest_ImportOptions* ImportRequest::_internal_mutable_import_options() {
  
  if (_impl_.import_options_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ImportRequest_ImportOptions>(GetArenaForAllocation());
    _impl_.import_options_ = p;
  }
  return _impl_.import_options_;
}
inline ::infinity_grpc_proto::ImportRequest_ImportOptions* ImportRequest::mutable_import_options() {
  ::infinity_grpc_proto::ImportRequest_ImportOptions* _msg = _internal_mutable_import_options();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ImportRequest.import_options)
  return _msg;
}
inline void ImportRequest::set_allocated_import_options(::infinity_grpc_proto::ImportRequest_ImportOptions* import_options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.import_options_;
  }
  if (import_options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(import_options);
    if (message_arena != submessage_arena) {
      import_options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, import_options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.import_options_ = import_options;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ImportRequest.import_options)
}

// uint64 session_id = 5;
inline void ImportRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t ImportRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t ImportRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ImportRequest.session_id)
  return _internal_session_id();
}
inline void ImportRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void ImportRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ImportRequest.session_id)
}

// -------------------------------------------------------------------

// ParsedExpr

// .infinity_grpc_proto.ConstantExpr constant_expr = 2;
inline bool ParsedExpr::_internal_has_constant_expr() const {
  return ParsedExprType_case() == kConstantExpr;
}
inline bool ParsedExpr::has_constant_expr() const {
  return _internal_has_constant_expr();
}
inline void ParsedExpr::set_has_constant_expr() {
  _impl_._oneof_case_[0] = kConstantExpr;
}
inline void ParsedExpr::clear_constant_expr() {
  if (_internal_has_constant_expr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ParsedExprType_.constant_expr_;
    }
    clear_has_ParsedExprType();
  }
}
inline ::infinity_grpc_proto::ConstantExpr* ParsedExpr::release_constant_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ParsedExpr.constant_expr)
  if (_internal_has_constant_expr()) {
    clear_has_ParsedExprType();
    ::infinity_grpc_proto::ConstantExpr* temp = _impl_.ParsedExprType_.constant_expr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ParsedExprType_.constant_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::infinity_grpc_proto::ConstantExpr& ParsedExpr::_internal_constant_expr() const {
  return _internal_has_constant_expr()
      ? *_impl_.ParsedExprType_.constant_expr_
      : reinterpret_cast< ::infinity_grpc_proto::ConstantExpr&>(::infinity_grpc_proto::_ConstantExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ConstantExpr& ParsedExpr::constant_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ParsedExpr.constant_expr)
  return _internal_constant_expr();
}
inline ::infinity_grpc_proto::ConstantExpr* ParsedExpr::unsafe_arena_release_constant_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infinity_grpc_proto.ParsedExpr.constant_expr)
  if (_internal_has_constant_expr()) {
    clear_has_ParsedExprType();
    ::infinity_grpc_proto::ConstantExpr* temp = _impl_.ParsedExprType_.constant_expr_;
    _impl_.ParsedExprType_.constant_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParsedExpr::unsafe_arena_set_allocated_constant_expr(::infinity_grpc_proto::ConstantExpr* constant_expr) {
  clear_ParsedExprType();
  if (constant_expr) {
    set_has_constant_expr();
    _impl_.ParsedExprType_.constant_expr_ = constant_expr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.ParsedExpr.constant_expr)
}
inline ::infinity_grpc_proto::ConstantExpr* ParsedExpr::_internal_mutable_constant_expr() {
  if (!_internal_has_constant_expr()) {
    clear_ParsedExprType();
    set_has_constant_expr();
    _impl_.ParsedExprType_.constant_expr_ = CreateMaybeMessage< ::infinity_grpc_proto::ConstantExpr >(GetArenaForAllocation());
  }
  return _impl_.ParsedExprType_.constant_expr_;
}
inline ::infinity_grpc_proto::ConstantExpr* ParsedExpr::mutable_constant_expr() {
  ::infinity_grpc_proto::ConstantExpr* _msg = _internal_mutable_constant_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ParsedExpr.constant_expr)
  return _msg;
}

// .infinity_grpc_proto.ColumnExpr column_expr = 4;
inline bool ParsedExpr::_internal_has_column_expr() const {
  return ParsedExprType_case() == kColumnExpr;
}
inline bool ParsedExpr::has_column_expr() const {
  return _internal_has_column_expr();
}
inline void ParsedExpr::set_has_column_expr() {
  _impl_._oneof_case_[0] = kColumnExpr;
}
inline void ParsedExpr::clear_column_expr() {
  if (_internal_has_column_expr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ParsedExprType_.column_expr_;
    }
    clear_has_ParsedExprType();
  }
}
inline ::infinity_grpc_proto::ColumnExpr* ParsedExpr::release_column_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ParsedExpr.column_expr)
  if (_internal_has_column_expr()) {
    clear_has_ParsedExprType();
    ::infinity_grpc_proto::ColumnExpr* temp = _impl_.ParsedExprType_.column_expr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ParsedExprType_.column_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::infinity_grpc_proto::ColumnExpr& ParsedExpr::_internal_column_expr() const {
  return _internal_has_column_expr()
      ? *_impl_.ParsedExprType_.column_expr_
      : reinterpret_cast< ::infinity_grpc_proto::ColumnExpr&>(::infinity_grpc_proto::_ColumnExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ColumnExpr& ParsedExpr::column_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ParsedExpr.column_expr)
  return _internal_column_expr();
}
inline ::infinity_grpc_proto::ColumnExpr* ParsedExpr::unsafe_arena_release_column_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infinity_grpc_proto.ParsedExpr.column_expr)
  if (_internal_has_column_expr()) {
    clear_has_ParsedExprType();
    ::infinity_grpc_proto::ColumnExpr* temp = _impl_.ParsedExprType_.column_expr_;
    _impl_.ParsedExprType_.column_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParsedExpr::unsafe_arena_set_allocated_column_expr(::infinity_grpc_proto::ColumnExpr* column_expr) {
  clear_ParsedExprType();
  if (column_expr) {
    set_has_column_expr();
    _impl_.ParsedExprType_.column_expr_ = column_expr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.ParsedExpr.column_expr)
}
inline ::infinity_grpc_proto::ColumnExpr* ParsedExpr::_internal_mutable_column_expr() {
  if (!_internal_has_column_expr()) {
    clear_ParsedExprType();
    set_has_column_expr();
    _impl_.ParsedExprType_.column_expr_ = CreateMaybeMessage< ::infinity_grpc_proto::ColumnExpr >(GetArenaForAllocation());
  }
  return _impl_.ParsedExprType_.column_expr_;
}
inline ::infinity_grpc_proto::ColumnExpr* ParsedExpr::mutable_column_expr() {
  ::infinity_grpc_proto::ColumnExpr* _msg = _internal_mutable_column_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ParsedExpr.column_expr)
  return _msg;
}

// .infinity_grpc_proto.FunctionExpr function_expr = 5;
inline bool ParsedExpr::_internal_has_function_expr() const {
  return ParsedExprType_case() == kFunctionExpr;
}
inline bool ParsedExpr::has_function_expr() const {
  return _internal_has_function_expr();
}
inline void ParsedExpr::set_has_function_expr() {
  _impl_._oneof_case_[0] = kFunctionExpr;
}
inline void ParsedExpr::clear_function_expr() {
  if (_internal_has_function_expr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ParsedExprType_.function_expr_;
    }
    clear_has_ParsedExprType();
  }
}
inline ::infinity_grpc_proto::FunctionExpr* ParsedExpr::release_function_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ParsedExpr.function_expr)
  if (_internal_has_function_expr()) {
    clear_has_ParsedExprType();
    ::infinity_grpc_proto::FunctionExpr* temp = _impl_.ParsedExprType_.function_expr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ParsedExprType_.function_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::infinity_grpc_proto::FunctionExpr& ParsedExpr::_internal_function_expr() const {
  return _internal_has_function_expr()
      ? *_impl_.ParsedExprType_.function_expr_
      : reinterpret_cast< ::infinity_grpc_proto::FunctionExpr&>(::infinity_grpc_proto::_FunctionExpr_default_instance_);
}
inline const ::infinity_grpc_proto::FunctionExpr& ParsedExpr::function_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ParsedExpr.function_expr)
  return _internal_function_expr();
}
inline ::infinity_grpc_proto::FunctionExpr* ParsedExpr::unsafe_arena_release_function_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infinity_grpc_proto.ParsedExpr.function_expr)
  if (_internal_has_function_expr()) {
    clear_has_ParsedExprType();
    ::infinity_grpc_proto::FunctionExpr* temp = _impl_.ParsedExprType_.function_expr_;
    _impl_.ParsedExprType_.function_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParsedExpr::unsafe_arena_set_allocated_function_expr(::infinity_grpc_proto::FunctionExpr* function_expr) {
  clear_ParsedExprType();
  if (function_expr) {
    set_has_function_expr();
    _impl_.ParsedExprType_.function_expr_ = function_expr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.ParsedExpr.function_expr)
}
inline ::infinity_grpc_proto::FunctionExpr* ParsedExpr::_internal_mutable_function_expr() {
  if (!_internal_has_function_expr()) {
    clear_ParsedExprType();
    set_has_function_expr();
    _impl_.ParsedExprType_.function_expr_ = CreateMaybeMessage< ::infinity_grpc_proto::FunctionExpr >(GetArenaForAllocation());
  }
  return _impl_.ParsedExprType_.function_expr_;
}
inline ::infinity_grpc_proto::FunctionExpr* ParsedExpr::mutable_function_expr() {
  ::infinity_grpc_proto::FunctionExpr* _msg = _internal_mutable_function_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ParsedExpr.function_expr)
  return _msg;
}

// .infinity_grpc_proto.KnnExpr knn_expr = 12;
inline bool ParsedExpr::_internal_has_knn_expr() const {
  return ParsedExprType_case() == kKnnExpr;
}
inline bool ParsedExpr::has_knn_expr() const {
  return _internal_has_knn_expr();
}
inline void ParsedExpr::set_has_knn_expr() {
  _impl_._oneof_case_[0] = kKnnExpr;
}
inline void ParsedExpr::clear_knn_expr() {
  if (_internal_has_knn_expr()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ParsedExprType_.knn_expr_;
    }
    clear_has_ParsedExprType();
  }
}
inline ::infinity_grpc_proto::KnnExpr* ParsedExpr::release_knn_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ParsedExpr.knn_expr)
  if (_internal_has_knn_expr()) {
    clear_has_ParsedExprType();
    ::infinity_grpc_proto::KnnExpr* temp = _impl_.ParsedExprType_.knn_expr_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ParsedExprType_.knn_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::infinity_grpc_proto::KnnExpr& ParsedExpr::_internal_knn_expr() const {
  return _internal_has_knn_expr()
      ? *_impl_.ParsedExprType_.knn_expr_
      : reinterpret_cast< ::infinity_grpc_proto::KnnExpr&>(::infinity_grpc_proto::_KnnExpr_default_instance_);
}
inline const ::infinity_grpc_proto::KnnExpr& ParsedExpr::knn_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ParsedExpr.knn_expr)
  return _internal_knn_expr();
}
inline ::infinity_grpc_proto::KnnExpr* ParsedExpr::unsafe_arena_release_knn_expr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:infinity_grpc_proto.ParsedExpr.knn_expr)
  if (_internal_has_knn_expr()) {
    clear_has_ParsedExprType();
    ::infinity_grpc_proto::KnnExpr* temp = _impl_.ParsedExprType_.knn_expr_;
    _impl_.ParsedExprType_.knn_expr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ParsedExpr::unsafe_arena_set_allocated_knn_expr(::infinity_grpc_proto::KnnExpr* knn_expr) {
  clear_ParsedExprType();
  if (knn_expr) {
    set_has_knn_expr();
    _impl_.ParsedExprType_.knn_expr_ = knn_expr;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.ParsedExpr.knn_expr)
}
inline ::infinity_grpc_proto::KnnExpr* ParsedExpr::_internal_mutable_knn_expr() {
  if (!_internal_has_knn_expr()) {
    clear_ParsedExprType();
    set_has_knn_expr();
    _impl_.ParsedExprType_.knn_expr_ = CreateMaybeMessage< ::infinity_grpc_proto::KnnExpr >(GetArenaForAllocation());
  }
  return _impl_.ParsedExprType_.knn_expr_;
}
inline ::infinity_grpc_proto::KnnExpr* ParsedExpr::mutable_knn_expr() {
  ::infinity_grpc_proto::KnnExpr* _msg = _internal_mutable_knn_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ParsedExpr.knn_expr)
  return _msg;
}

// string alias = 1;
inline void ParsedExpr::clear_alias() {
  _impl_.alias_.ClearToEmpty();
}
inline const std::string& ParsedExpr::alias() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ParsedExpr.alias)
  return _internal_alias();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ParsedExpr::set_alias(ArgT0&& arg0, ArgT... args) {
 
 _impl_.alias_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ParsedExpr.alias)
}
inline std::string* ParsedExpr::mutable_alias() {
  std::string* _s = _internal_mutable_alias();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ParsedExpr.alias)
  return _s;
}
inline const std::string& ParsedExpr::_internal_alias() const {
  return _impl_.alias_.Get();
}
inline void ParsedExpr::_internal_set_alias(const std::string& value) {
  
  _impl_.alias_.Set(value, GetArenaForAllocation());
}
inline std::string* ParsedExpr::_internal_mutable_alias() {
  
  return _impl_.alias_.Mutable(GetArenaForAllocation());
}
inline std::string* ParsedExpr::release_alias() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ParsedExpr.alias)
  return _impl_.alias_.Release();
}
inline void ParsedExpr::set_allocated_alias(std::string* alias) {
  if (alias != nullptr) {
    
  } else {
    
  }
  _impl_.alias_.SetAllocated(alias, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.alias_.IsDefault()) {
    _impl_.alias_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ParsedExpr.alias)
}

inline bool ParsedExpr::has_ParsedExprType() const {
  return ParsedExprType_case() != PARSEDEXPRTYPE_NOT_SET;
}
inline void ParsedExpr::clear_has_ParsedExprType() {
  _impl_._oneof_case_[0] = PARSEDEXPRTYPE_NOT_SET;
}
inline ParsedExpr::ParsedExprTypeCase ParsedExpr::ParsedExprType_case() const {
  return ParsedExpr::ParsedExprTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConstantExpr

// .infinity_grpc_proto.ConstantExpr.LiteralType literal_type = 1;
inline void ConstantExpr::clear_literal_type() {
  _impl_.literal_type_ = 0;
}
inline ::infinity_grpc_proto::ConstantExpr_LiteralType ConstantExpr::_internal_literal_type() const {
  return static_cast< ::infinity_grpc_proto::ConstantExpr_LiteralType >(_impl_.literal_type_);
}
inline ::infinity_grpc_proto::ConstantExpr_LiteralType ConstantExpr::literal_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ConstantExpr.literal_type)
  return _internal_literal_type();
}
inline void ConstantExpr::_internal_set_literal_type(::infinity_grpc_proto::ConstantExpr_LiteralType value) {
  
  _impl_.literal_type_ = value;
}
inline void ConstantExpr::set_literal_type(::infinity_grpc_proto::ConstantExpr_LiteralType value) {
  _internal_set_literal_type(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ConstantExpr.literal_type)
}

// bool bool_value = 2;
inline void ConstantExpr::clear_bool_value() {
  _impl_.bool_value_ = false;
}
inline bool ConstantExpr::_internal_bool_value() const {
  return _impl_.bool_value_;
}
inline bool ConstantExpr::bool_value() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ConstantExpr.bool_value)
  return _internal_bool_value();
}
inline void ConstantExpr::_internal_set_bool_value(bool value) {
  
  _impl_.bool_value_ = value;
}
inline void ConstantExpr::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ConstantExpr.bool_value)
}

// int64 i64_value = 3;
inline void ConstantExpr::clear_i64_value() {
  _impl_.i64_value_ = int64_t{0};
}
inline int64_t ConstantExpr::_internal_i64_value() const {
  return _impl_.i64_value_;
}
inline int64_t ConstantExpr::i64_value() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ConstantExpr.i64_value)
  return _internal_i64_value();
}
inline void ConstantExpr::_internal_set_i64_value(int64_t value) {
  
  _impl_.i64_value_ = value;
}
inline void ConstantExpr::set_i64_value(int64_t value) {
  _internal_set_i64_value(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ConstantExpr.i64_value)
}

// double f64_value = 4;
inline void ConstantExpr::clear_f64_value() {
  _impl_.f64_value_ = 0;
}
inline double ConstantExpr::_internal_f64_value() const {
  return _impl_.f64_value_;
}
inline double ConstantExpr::f64_value() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ConstantExpr.f64_value)
  return _internal_f64_value();
}
inline void ConstantExpr::_internal_set_f64_value(double value) {
  
  _impl_.f64_value_ = value;
}
inline void ConstantExpr::set_f64_value(double value) {
  _internal_set_f64_value(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ConstantExpr.f64_value)
}

// string str_value = 5;
inline void ConstantExpr::clear_str_value() {
  _impl_.str_value_.ClearToEmpty();
}
inline const std::string& ConstantExpr::str_value() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ConstantExpr.str_value)
  return _internal_str_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConstantExpr::set_str_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.str_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ConstantExpr.str_value)
}
inline std::string* ConstantExpr::mutable_str_value() {
  std::string* _s = _internal_mutable_str_value();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ConstantExpr.str_value)
  return _s;
}
inline const std::string& ConstantExpr::_internal_str_value() const {
  return _impl_.str_value_.Get();
}
inline void ConstantExpr::_internal_set_str_value(const std::string& value) {
  
  _impl_.str_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ConstantExpr::_internal_mutable_str_value() {
  
  return _impl_.str_value_.Mutable(GetArenaForAllocation());
}
inline std::string* ConstantExpr::release_str_value() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ConstantExpr.str_value)
  return _impl_.str_value_.Release();
}
inline void ConstantExpr::set_allocated_str_value(std::string* str_value) {
  if (str_value != nullptr) {
    
  } else {
    
  }
  _impl_.str_value_.SetAllocated(str_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.str_value_.IsDefault()) {
    _impl_.str_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ConstantExpr.str_value)
}

// string date_value = 6;
inline void ConstantExpr::clear_date_value() {
  _impl_.date_value_.ClearToEmpty();
}
inline const std::string& ConstantExpr::date_value() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ConstantExpr.date_value)
  return _internal_date_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConstantExpr::set_date_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.date_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ConstantExpr.date_value)
}
inline std::string* ConstantExpr::mutable_date_value() {
  std::string* _s = _internal_mutable_date_value();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ConstantExpr.date_value)
  return _s;
}
inline const std::string& ConstantExpr::_internal_date_value() const {
  return _impl_.date_value_.Get();
}
inline void ConstantExpr::_internal_set_date_value(const std::string& value) {
  
  _impl_.date_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ConstantExpr::_internal_mutable_date_value() {
  
  return _impl_.date_value_.Mutable(GetArenaForAllocation());
}
inline std::string* ConstantExpr::release_date_value() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ConstantExpr.date_value)
  return _impl_.date_value_.Release();
}
inline void ConstantExpr::set_allocated_date_value(std::string* date_value) {
  if (date_value != nullptr) {
    
  } else {
    
  }
  _impl_.date_value_.SetAllocated(date_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.date_value_.IsDefault()) {
    _impl_.date_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ConstantExpr.date_value)
}

// repeated int64 long_array = 7;
inline int ConstantExpr::_internal_long_array_size() const {
  return _impl_.long_array_.size();
}
inline int ConstantExpr::long_array_size() const {
  return _internal_long_array_size();
}
inline void ConstantExpr::clear_long_array() {
  _impl_.long_array_.Clear();
}
inline int64_t ConstantExpr::_internal_long_array(int index) const {
  return _impl_.long_array_.Get(index);
}
inline int64_t ConstantExpr::long_array(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ConstantExpr.long_array)
  return _internal_long_array(index);
}
inline void ConstantExpr::set_long_array(int index, int64_t value) {
  _impl_.long_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ConstantExpr.long_array)
}
inline void ConstantExpr::_internal_add_long_array(int64_t value) {
  _impl_.long_array_.Add(value);
}
inline void ConstantExpr::add_long_array(int64_t value) {
  _internal_add_long_array(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ConstantExpr.long_array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ConstantExpr::_internal_long_array() const {
  return _impl_.long_array_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ConstantExpr::long_array() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.ConstantExpr.long_array)
  return _internal_long_array();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ConstantExpr::_internal_mutable_long_array() {
  return &_impl_.long_array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ConstantExpr::mutable_long_array() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.ConstantExpr.long_array)
  return _internal_mutable_long_array();
}

// repeated double double_array = 8;
inline int ConstantExpr::_internal_double_array_size() const {
  return _impl_.double_array_.size();
}
inline int ConstantExpr::double_array_size() const {
  return _internal_double_array_size();
}
inline void ConstantExpr::clear_double_array() {
  _impl_.double_array_.Clear();
}
inline double ConstantExpr::_internal_double_array(int index) const {
  return _impl_.double_array_.Get(index);
}
inline double ConstantExpr::double_array(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ConstantExpr.double_array)
  return _internal_double_array(index);
}
inline void ConstantExpr::set_double_array(int index, double value) {
  _impl_.double_array_.Set(index, value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ConstantExpr.double_array)
}
inline void ConstantExpr::_internal_add_double_array(double value) {
  _impl_.double_array_.Add(value);
}
inline void ConstantExpr::add_double_array(double value) {
  _internal_add_double_array(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ConstantExpr.double_array)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ConstantExpr::_internal_double_array() const {
  return _impl_.double_array_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
ConstantExpr::double_array() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.ConstantExpr.double_array)
  return _internal_double_array();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ConstantExpr::_internal_mutable_double_array() {
  return &_impl_.double_array_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
ConstantExpr::mutable_double_array() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.ConstantExpr.double_array)
  return _internal_mutable_double_array();
}

// -------------------------------------------------------------------

// FunctionExpr

// string function_name = 1;
inline void FunctionExpr::clear_function_name() {
  _impl_.function_name_.ClearToEmpty();
}
inline const std::string& FunctionExpr::function_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.FunctionExpr.function_name)
  return _internal_function_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FunctionExpr::set_function_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.function_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.FunctionExpr.function_name)
}
inline std::string* FunctionExpr::mutable_function_name() {
  std::string* _s = _internal_mutable_function_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.FunctionExpr.function_name)
  return _s;
}
inline const std::string& FunctionExpr::_internal_function_name() const {
  return _impl_.function_name_.Get();
}
inline void FunctionExpr::_internal_set_function_name(const std::string& value) {
  
  _impl_.function_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FunctionExpr::_internal_mutable_function_name() {
  
  return _impl_.function_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FunctionExpr::release_function_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.FunctionExpr.function_name)
  return _impl_.function_name_.Release();
}
inline void FunctionExpr::set_allocated_function_name(std::string* function_name) {
  if (function_name != nullptr) {
    
  } else {
    
  }
  _impl_.function_name_.SetAllocated(function_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.function_name_.IsDefault()) {
    _impl_.function_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.FunctionExpr.function_name)
}

// repeated .infinity_grpc_proto.ParsedExpr arguments = 2;
inline int FunctionExpr::_internal_arguments_size() const {
  return _impl_.arguments_.size();
}
inline int FunctionExpr::arguments_size() const {
  return _internal_arguments_size();
}
inline void FunctionExpr::clear_arguments() {
  _impl_.arguments_.Clear();
}
inline ::infinity_grpc_proto::ParsedExpr* FunctionExpr::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.FunctionExpr.arguments)
  return _impl_.arguments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
FunctionExpr::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.FunctionExpr.arguments)
  return &_impl_.arguments_;
}
inline const ::infinity_grpc_proto::ParsedExpr& FunctionExpr::_internal_arguments(int index) const {
  return _impl_.arguments_.Get(index);
}
inline const ::infinity_grpc_proto::ParsedExpr& FunctionExpr::arguments(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.FunctionExpr.arguments)
  return _internal_arguments(index);
}
inline ::infinity_grpc_proto::ParsedExpr* FunctionExpr::_internal_add_arguments() {
  return _impl_.arguments_.Add();
}
inline ::infinity_grpc_proto::ParsedExpr* FunctionExpr::add_arguments() {
  ::infinity_grpc_proto::ParsedExpr* _add = _internal_add_arguments();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.FunctionExpr.arguments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
FunctionExpr::arguments() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.FunctionExpr.arguments)
  return _impl_.arguments_;
}

// -------------------------------------------------------------------

// ColumnExpr

// repeated string column_name = 1;
inline int ColumnExpr::_internal_column_name_size() const {
  return _impl_.column_name_.size();
}
inline int ColumnExpr::column_name_size() const {
  return _internal_column_name_size();
}
inline void ColumnExpr::clear_column_name() {
  _impl_.column_name_.Clear();
}
inline std::string* ColumnExpr::add_column_name() {
  std::string* _s = _internal_add_column_name();
  // @@protoc_insertion_point(field_add_mutable:infinity_grpc_proto.ColumnExpr.column_name)
  return _s;
}
inline const std::string& ColumnExpr::_internal_column_name(int index) const {
  return _impl_.column_name_.Get(index);
}
inline const std::string& ColumnExpr::column_name(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnExpr.column_name)
  return _internal_column_name(index);
}
inline std::string* ColumnExpr::mutable_column_name(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ColumnExpr.column_name)
  return _impl_.column_name_.Mutable(index);
}
inline void ColumnExpr::set_column_name(int index, const std::string& value) {
  _impl_.column_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnExpr.column_name)
}
inline void ColumnExpr::set_column_name(int index, std::string&& value) {
  _impl_.column_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnExpr.column_name)
}
inline void ColumnExpr::set_column_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:infinity_grpc_proto.ColumnExpr.column_name)
}
inline void ColumnExpr::set_column_name(int index, const char* value, size_t size) {
  _impl_.column_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:infinity_grpc_proto.ColumnExpr.column_name)
}
inline std::string* ColumnExpr::_internal_add_column_name() {
  return _impl_.column_name_.Add();
}
inline void ColumnExpr::add_column_name(const std::string& value) {
  _impl_.column_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ColumnExpr.column_name)
}
inline void ColumnExpr::add_column_name(std::string&& value) {
  _impl_.column_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ColumnExpr.column_name)
}
inline void ColumnExpr::add_column_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:infinity_grpc_proto.ColumnExpr.column_name)
}
inline void ColumnExpr::add_column_name(const char* value, size_t size) {
  _impl_.column_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:infinity_grpc_proto.ColumnExpr.column_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ColumnExpr::column_name() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.ColumnExpr.column_name)
  return _impl_.column_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ColumnExpr::mutable_column_name() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.ColumnExpr.column_name)
  return &_impl_.column_name_;
}

// bool star = 2;
inline void ColumnExpr::clear_star() {
  _impl_.star_ = false;
}
inline bool ColumnExpr::_internal_star() const {
  return _impl_.star_;
}
inline bool ColumnExpr::star() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnExpr.star)
  return _internal_star();
}
inline void ColumnExpr::_internal_set_star(bool value) {
  
  _impl_.star_ = value;
}
inline void ColumnExpr::set_star(bool value) {
  _internal_set_star(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnExpr.star)
}

// -------------------------------------------------------------------

// BetweenExpr

// .infinity_grpc_proto.ParsedExpr value = 1;
inline bool BetweenExpr::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool BetweenExpr::has_value() const {
  return _internal_has_value();
}
inline void BetweenExpr::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& BetweenExpr::_internal_value() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& BetweenExpr::value() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.BetweenExpr.value)
  return _internal_value();
}
inline void BetweenExpr::unsafe_arena_set_allocated_value(
    ::infinity_grpc_proto::ParsedExpr* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.BetweenExpr.value)
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::release_value() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.BetweenExpr.value)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::mutable_value() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.BetweenExpr.value)
  return _msg;
}
inline void BetweenExpr::set_allocated_value(::infinity_grpc_proto::ParsedExpr* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.BetweenExpr.value)
}

// .infinity_grpc_proto.ParsedExpr upper_bound = 2;
inline bool BetweenExpr::_internal_has_upper_bound() const {
  return this != internal_default_instance() && _impl_.upper_bound_ != nullptr;
}
inline bool BetweenExpr::has_upper_bound() const {
  return _internal_has_upper_bound();
}
inline void BetweenExpr::clear_upper_bound() {
  if (GetArenaForAllocation() == nullptr && _impl_.upper_bound_ != nullptr) {
    delete _impl_.upper_bound_;
  }
  _impl_.upper_bound_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& BetweenExpr::_internal_upper_bound() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.upper_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& BetweenExpr::upper_bound() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.BetweenExpr.upper_bound)
  return _internal_upper_bound();
}
inline void BetweenExpr::unsafe_arena_set_allocated_upper_bound(
    ::infinity_grpc_proto::ParsedExpr* upper_bound) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.upper_bound_);
  }
  _impl_.upper_bound_ = upper_bound;
  if (upper_bound) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.BetweenExpr.upper_bound)
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::release_upper_bound() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.upper_bound_;
  _impl_.upper_bound_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::unsafe_arena_release_upper_bound() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.BetweenExpr.upper_bound)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.upper_bound_;
  _impl_.upper_bound_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::_internal_mutable_upper_bound() {
  
  if (_impl_.upper_bound_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.upper_bound_ = p;
  }
  return _impl_.upper_bound_;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::mutable_upper_bound() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_upper_bound();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.BetweenExpr.upper_bound)
  return _msg;
}
inline void BetweenExpr::set_allocated_upper_bound(::infinity_grpc_proto::ParsedExpr* upper_bound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.upper_bound_;
  }
  if (upper_bound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(upper_bound);
    if (message_arena != submessage_arena) {
      upper_bound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, upper_bound, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.upper_bound_ = upper_bound;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.BetweenExpr.upper_bound)
}

// .infinity_grpc_proto.ParsedExpr lower_bound = 3;
inline bool BetweenExpr::_internal_has_lower_bound() const {
  return this != internal_default_instance() && _impl_.lower_bound_ != nullptr;
}
inline bool BetweenExpr::has_lower_bound() const {
  return _internal_has_lower_bound();
}
inline void BetweenExpr::clear_lower_bound() {
  if (GetArenaForAllocation() == nullptr && _impl_.lower_bound_ != nullptr) {
    delete _impl_.lower_bound_;
  }
  _impl_.lower_bound_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& BetweenExpr::_internal_lower_bound() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.lower_bound_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& BetweenExpr::lower_bound() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.BetweenExpr.lower_bound)
  return _internal_lower_bound();
}
inline void BetweenExpr::unsafe_arena_set_allocated_lower_bound(
    ::infinity_grpc_proto::ParsedExpr* lower_bound) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.lower_bound_);
  }
  _impl_.lower_bound_ = lower_bound;
  if (lower_bound) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.BetweenExpr.lower_bound)
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::release_lower_bound() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.lower_bound_;
  _impl_.lower_bound_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::unsafe_arena_release_lower_bound() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.BetweenExpr.lower_bound)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.lower_bound_;
  _impl_.lower_bound_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::_internal_mutable_lower_bound() {
  
  if (_impl_.lower_bound_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.lower_bound_ = p;
  }
  return _impl_.lower_bound_;
}
inline ::infinity_grpc_proto::ParsedExpr* BetweenExpr::mutable_lower_bound() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_lower_bound();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.BetweenExpr.lower_bound)
  return _msg;
}
inline void BetweenExpr::set_allocated_lower_bound(::infinity_grpc_proto::ParsedExpr* lower_bound) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.lower_bound_;
  }
  if (lower_bound) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lower_bound);
    if (message_arena != submessage_arena) {
      lower_bound = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lower_bound, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.lower_bound_ = lower_bound;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.BetweenExpr.lower_bound)
}

// -------------------------------------------------------------------

// InExpr

// .infinity_grpc_proto.ParsedExpr left = 1;
inline bool InExpr::_internal_has_left() const {
  return this != internal_default_instance() && _impl_.left_ != nullptr;
}
inline bool InExpr::has_left() const {
  return _internal_has_left();
}
inline void InExpr::clear_left() {
  if (GetArenaForAllocation() == nullptr && _impl_.left_ != nullptr) {
    delete _impl_.left_;
  }
  _impl_.left_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& InExpr::_internal_left() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.left_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& InExpr::left() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InExpr.left)
  return _internal_left();
}
inline void InExpr::unsafe_arena_set_allocated_left(
    ::infinity_grpc_proto::ParsedExpr* left) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.left_);
  }
  _impl_.left_ = left;
  if (left) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.InExpr.left)
}
inline ::infinity_grpc_proto::ParsedExpr* InExpr::release_left() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.left_;
  _impl_.left_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* InExpr::unsafe_arena_release_left() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.InExpr.left)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.left_;
  _impl_.left_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* InExpr::_internal_mutable_left() {
  
  if (_impl_.left_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.left_ = p;
  }
  return _impl_.left_;
}
inline ::infinity_grpc_proto::ParsedExpr* InExpr::mutable_left() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_left();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.InExpr.left)
  return _msg;
}
inline void InExpr::set_allocated_left(::infinity_grpc_proto::ParsedExpr* left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.left_;
  }
  if (left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left);
    if (message_arena != submessage_arena) {
      left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.left_ = left;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.InExpr.left)
}

// repeated .infinity_grpc_proto.ParsedExpr arguments = 2;
inline int InExpr::_internal_arguments_size() const {
  return _impl_.arguments_.size();
}
inline int InExpr::arguments_size() const {
  return _internal_arguments_size();
}
inline void InExpr::clear_arguments() {
  _impl_.arguments_.Clear();
}
inline ::infinity_grpc_proto::ParsedExpr* InExpr::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.InExpr.arguments)
  return _impl_.arguments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
InExpr::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.InExpr.arguments)
  return &_impl_.arguments_;
}
inline const ::infinity_grpc_proto::ParsedExpr& InExpr::_internal_arguments(int index) const {
  return _impl_.arguments_.Get(index);
}
inline const ::infinity_grpc_proto::ParsedExpr& InExpr::arguments(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InExpr.arguments)
  return _internal_arguments(index);
}
inline ::infinity_grpc_proto::ParsedExpr* InExpr::_internal_add_arguments() {
  return _impl_.arguments_.Add();
}
inline ::infinity_grpc_proto::ParsedExpr* InExpr::add_arguments() {
  ::infinity_grpc_proto::ParsedExpr* _add = _internal_add_arguments();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.InExpr.arguments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
InExpr::arguments() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.InExpr.arguments)
  return _impl_.arguments_;
}

// bool not_in = 3;
inline void InExpr::clear_not_in() {
  _impl_.not_in_ = false;
}
inline bool InExpr::_internal_not_in() const {
  return _impl_.not_in_;
}
inline bool InExpr::not_in() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InExpr.not_in)
  return _internal_not_in();
}
inline void InExpr::_internal_set_not_in(bool value) {
  
  _impl_.not_in_ = value;
}
inline void InExpr::set_not_in(bool value) {
  _internal_set_not_in(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.InExpr.not_in)
}

// -------------------------------------------------------------------

// KnnExpr

// .infinity_grpc_proto.ParsedExpr column_expr = 1;
inline bool KnnExpr::_internal_has_column_expr() const {
  return this != internal_default_instance() && _impl_.column_expr_ != nullptr;
}
inline bool KnnExpr::has_column_expr() const {
  return _internal_has_column_expr();
}
inline void KnnExpr::clear_column_expr() {
  if (GetArenaForAllocation() == nullptr && _impl_.column_expr_ != nullptr) {
    delete _impl_.column_expr_;
  }
  _impl_.column_expr_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& KnnExpr::_internal_column_expr() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.column_expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& KnnExpr::column_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.KnnExpr.column_expr)
  return _internal_column_expr();
}
inline void KnnExpr::unsafe_arena_set_allocated_column_expr(
    ::infinity_grpc_proto::ParsedExpr* column_expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.column_expr_);
  }
  _impl_.column_expr_ = column_expr;
  if (column_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.KnnExpr.column_expr)
}
inline ::infinity_grpc_proto::ParsedExpr* KnnExpr::release_column_expr() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.column_expr_;
  _impl_.column_expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* KnnExpr::unsafe_arena_release_column_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.KnnExpr.column_expr)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.column_expr_;
  _impl_.column_expr_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* KnnExpr::_internal_mutable_column_expr() {
  
  if (_impl_.column_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.column_expr_ = p;
  }
  return _impl_.column_expr_;
}
inline ::infinity_grpc_proto::ParsedExpr* KnnExpr::mutable_column_expr() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_column_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.KnnExpr.column_expr)
  return _msg;
}
inline void KnnExpr::set_allocated_column_expr(::infinity_grpc_proto::ParsedExpr* column_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.column_expr_;
  }
  if (column_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(column_expr);
    if (message_arena != submessage_arena) {
      column_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, column_expr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.column_expr_ = column_expr;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.KnnExpr.column_expr)
}

// repeated string embedding_data = 2;
inline int KnnExpr::_internal_embedding_data_size() const {
  return _impl_.embedding_data_.size();
}
inline int KnnExpr::embedding_data_size() const {
  return _internal_embedding_data_size();
}
inline void KnnExpr::clear_embedding_data() {
  _impl_.embedding_data_.Clear();
}
inline std::string* KnnExpr::add_embedding_data() {
  std::string* _s = _internal_add_embedding_data();
  // @@protoc_insertion_point(field_add_mutable:infinity_grpc_proto.KnnExpr.embedding_data)
  return _s;
}
inline const std::string& KnnExpr::_internal_embedding_data(int index) const {
  return _impl_.embedding_data_.Get(index);
}
inline const std::string& KnnExpr::embedding_data(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.KnnExpr.embedding_data)
  return _internal_embedding_data(index);
}
inline std::string* KnnExpr::mutable_embedding_data(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.KnnExpr.embedding_data)
  return _impl_.embedding_data_.Mutable(index);
}
inline void KnnExpr::set_embedding_data(int index, const std::string& value) {
  _impl_.embedding_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.KnnExpr.embedding_data)
}
inline void KnnExpr::set_embedding_data(int index, std::string&& value) {
  _impl_.embedding_data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.KnnExpr.embedding_data)
}
inline void KnnExpr::set_embedding_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.embedding_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:infinity_grpc_proto.KnnExpr.embedding_data)
}
inline void KnnExpr::set_embedding_data(int index, const char* value, size_t size) {
  _impl_.embedding_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:infinity_grpc_proto.KnnExpr.embedding_data)
}
inline std::string* KnnExpr::_internal_add_embedding_data() {
  return _impl_.embedding_data_.Add();
}
inline void KnnExpr::add_embedding_data(const std::string& value) {
  _impl_.embedding_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.KnnExpr.embedding_data)
}
inline void KnnExpr::add_embedding_data(std::string&& value) {
  _impl_.embedding_data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.KnnExpr.embedding_data)
}
inline void KnnExpr::add_embedding_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.embedding_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:infinity_grpc_proto.KnnExpr.embedding_data)
}
inline void KnnExpr::add_embedding_data(const char* value, size_t size) {
  _impl_.embedding_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:infinity_grpc_proto.KnnExpr.embedding_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
KnnExpr::embedding_data() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.KnnExpr.embedding_data)
  return _impl_.embedding_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
KnnExpr::mutable_embedding_data() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.KnnExpr.embedding_data)
  return &_impl_.embedding_data_;
}

// int64 dimension = 3;
inline void KnnExpr::clear_dimension() {
  _impl_.dimension_ = int64_t{0};
}
inline int64_t KnnExpr::_internal_dimension() const {
  return _impl_.dimension_;
}
inline int64_t KnnExpr::dimension() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.KnnExpr.dimension)
  return _internal_dimension();
}
inline void KnnExpr::_internal_set_dimension(int64_t value) {
  
  _impl_.dimension_ = value;
}
inline void KnnExpr::set_dimension(int64_t value) {
  _internal_set_dimension(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.KnnExpr.dimension)
}

// .infinity_grpc_proto.KnnExpr.EmbeddingDataType embedding_data_type = 4;
inline void KnnExpr::clear_embedding_data_type() {
  _impl_.embedding_data_type_ = 0;
}
inline ::infinity_grpc_proto::KnnExpr_EmbeddingDataType KnnExpr::_internal_embedding_data_type() const {
  return static_cast< ::infinity_grpc_proto::KnnExpr_EmbeddingDataType >(_impl_.embedding_data_type_);
}
inline ::infinity_grpc_proto::KnnExpr_EmbeddingDataType KnnExpr::embedding_data_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.KnnExpr.embedding_data_type)
  return _internal_embedding_data_type();
}
inline void KnnExpr::_internal_set_embedding_data_type(::infinity_grpc_proto::KnnExpr_EmbeddingDataType value) {
  
  _impl_.embedding_data_type_ = value;
}
inline void KnnExpr::set_embedding_data_type(::infinity_grpc_proto::KnnExpr_EmbeddingDataType value) {
  _internal_set_embedding_data_type(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.KnnExpr.embedding_data_type)
}

// .infinity_grpc_proto.KnnExpr.KnnDistanceType distance_type = 5;
inline void KnnExpr::clear_distance_type() {
  _impl_.distance_type_ = 0;
}
inline ::infinity_grpc_proto::KnnExpr_KnnDistanceType KnnExpr::_internal_distance_type() const {
  return static_cast< ::infinity_grpc_proto::KnnExpr_KnnDistanceType >(_impl_.distance_type_);
}
inline ::infinity_grpc_proto::KnnExpr_KnnDistanceType KnnExpr::distance_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.KnnExpr.distance_type)
  return _internal_distance_type();
}
inline void KnnExpr::_internal_set_distance_type(::infinity_grpc_proto::KnnExpr_KnnDistanceType value) {
  
  _impl_.distance_type_ = value;
}
inline void KnnExpr::set_distance_type(::infinity_grpc_proto::KnnExpr_KnnDistanceType value) {
  _internal_set_distance_type(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.KnnExpr.distance_type)
}

// -------------------------------------------------------------------

// SelectStatement

// string db_name = 1;
inline void SelectStatement::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& SelectStatement::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectStatement::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.SelectStatement.db_name)
}
inline std::string* SelectStatement::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectStatement.db_name)
  return _s;
}
inline const std::string& SelectStatement::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void SelectStatement::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectStatement::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectStatement::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.SelectStatement.db_name)
  return _impl_.db_name_.Release();
}
inline void SelectStatement::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.SelectStatement.db_name)
}

// string table_name = 2;
inline void SelectStatement::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& SelectStatement::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectStatement::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.SelectStatement.table_name)
}
inline std::string* SelectStatement::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectStatement.table_name)
  return _s;
}
inline const std::string& SelectStatement::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void SelectStatement::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectStatement::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectStatement::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.SelectStatement.table_name)
  return _impl_.table_name_.Release();
}
inline void SelectStatement::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.SelectStatement.table_name)
}

// uint64 session_id = 9;
inline void SelectStatement::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t SelectStatement::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t SelectStatement::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.session_id)
  return _internal_session_id();
}
inline void SelectStatement::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void SelectStatement::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.SelectStatement.session_id)
}

// repeated .infinity_grpc_proto.ParsedExpr select_list = 3;
inline int SelectStatement::_internal_select_list_size() const {
  return _impl_.select_list_.size();
}
inline int SelectStatement::select_list_size() const {
  return _internal_select_list_size();
}
inline void SelectStatement::clear_select_list() {
  _impl_.select_list_.Clear();
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::mutable_select_list(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectStatement.select_list)
  return _impl_.select_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
SelectStatement::mutable_select_list() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.SelectStatement.select_list)
  return &_impl_.select_list_;
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::_internal_select_list(int index) const {
  return _impl_.select_list_.Get(index);
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::select_list(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.select_list)
  return _internal_select_list(index);
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::_internal_add_select_list() {
  return _impl_.select_list_.Add();
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::add_select_list() {
  ::infinity_grpc_proto::ParsedExpr* _add = _internal_add_select_list();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.SelectStatement.select_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
SelectStatement::select_list() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.SelectStatement.select_list)
  return _impl_.select_list_;
}

// .infinity_grpc_proto.ParsedExpr where_expr = 4;
inline bool SelectStatement::_internal_has_where_expr() const {
  return this != internal_default_instance() && _impl_.where_expr_ != nullptr;
}
inline bool SelectStatement::has_where_expr() const {
  return _internal_has_where_expr();
}
inline void SelectStatement::clear_where_expr() {
  if (GetArenaForAllocation() == nullptr && _impl_.where_expr_ != nullptr) {
    delete _impl_.where_expr_;
  }
  _impl_.where_expr_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::_internal_where_expr() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.where_expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::where_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.where_expr)
  return _internal_where_expr();
}
inline void SelectStatement::unsafe_arena_set_allocated_where_expr(
    ::infinity_grpc_proto::ParsedExpr* where_expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.where_expr_);
  }
  _impl_.where_expr_ = where_expr;
  if (where_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.SelectStatement.where_expr)
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::release_where_expr() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.where_expr_;
  _impl_.where_expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::unsafe_arena_release_where_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.SelectStatement.where_expr)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.where_expr_;
  _impl_.where_expr_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::_internal_mutable_where_expr() {
  
  if (_impl_.where_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.where_expr_ = p;
  }
  return _impl_.where_expr_;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::mutable_where_expr() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_where_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectStatement.where_expr)
  return _msg;
}
inline void SelectStatement::set_allocated_where_expr(::infinity_grpc_proto::ParsedExpr* where_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.where_expr_;
  }
  if (where_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(where_expr);
    if (message_arena != submessage_arena) {
      where_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, where_expr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.where_expr_ = where_expr;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.SelectStatement.where_expr)
}

// repeated .infinity_grpc_proto.ParsedExpr group_by_list = 5;
inline int SelectStatement::_internal_group_by_list_size() const {
  return _impl_.group_by_list_.size();
}
inline int SelectStatement::group_by_list_size() const {
  return _internal_group_by_list_size();
}
inline void SelectStatement::clear_group_by_list() {
  _impl_.group_by_list_.Clear();
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::mutable_group_by_list(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectStatement.group_by_list)
  return _impl_.group_by_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >*
SelectStatement::mutable_group_by_list() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.SelectStatement.group_by_list)
  return &_impl_.group_by_list_;
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::_internal_group_by_list(int index) const {
  return _impl_.group_by_list_.Get(index);
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::group_by_list(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.group_by_list)
  return _internal_group_by_list(index);
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::_internal_add_group_by_list() {
  return _impl_.group_by_list_.Add();
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::add_group_by_list() {
  ::infinity_grpc_proto::ParsedExpr* _add = _internal_add_group_by_list();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.SelectStatement.group_by_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ParsedExpr >&
SelectStatement::group_by_list() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.SelectStatement.group_by_list)
  return _impl_.group_by_list_;
}

// .infinity_grpc_proto.ParsedExpr limit_expr = 6;
inline bool SelectStatement::_internal_has_limit_expr() const {
  return this != internal_default_instance() && _impl_.limit_expr_ != nullptr;
}
inline bool SelectStatement::has_limit_expr() const {
  return _internal_has_limit_expr();
}
inline void SelectStatement::clear_limit_expr() {
  if (GetArenaForAllocation() == nullptr && _impl_.limit_expr_ != nullptr) {
    delete _impl_.limit_expr_;
  }
  _impl_.limit_expr_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::_internal_limit_expr() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.limit_expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::limit_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.limit_expr)
  return _internal_limit_expr();
}
inline void SelectStatement::unsafe_arena_set_allocated_limit_expr(
    ::infinity_grpc_proto::ParsedExpr* limit_expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.limit_expr_);
  }
  _impl_.limit_expr_ = limit_expr;
  if (limit_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.SelectStatement.limit_expr)
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::release_limit_expr() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.limit_expr_;
  _impl_.limit_expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::unsafe_arena_release_limit_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.SelectStatement.limit_expr)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.limit_expr_;
  _impl_.limit_expr_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::_internal_mutable_limit_expr() {
  
  if (_impl_.limit_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.limit_expr_ = p;
  }
  return _impl_.limit_expr_;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::mutable_limit_expr() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_limit_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectStatement.limit_expr)
  return _msg;
}
inline void SelectStatement::set_allocated_limit_expr(::infinity_grpc_proto::ParsedExpr* limit_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.limit_expr_;
  }
  if (limit_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(limit_expr);
    if (message_arena != submessage_arena) {
      limit_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, limit_expr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.limit_expr_ = limit_expr;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.SelectStatement.limit_expr)
}

// .infinity_grpc_proto.ParsedExpr offset_expr = 7;
inline bool SelectStatement::_internal_has_offset_expr() const {
  return this != internal_default_instance() && _impl_.offset_expr_ != nullptr;
}
inline bool SelectStatement::has_offset_expr() const {
  return _internal_has_offset_expr();
}
inline void SelectStatement::clear_offset_expr() {
  if (GetArenaForAllocation() == nullptr && _impl_.offset_expr_ != nullptr) {
    delete _impl_.offset_expr_;
  }
  _impl_.offset_expr_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::_internal_offset_expr() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.offset_expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::offset_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.offset_expr)
  return _internal_offset_expr();
}
inline void SelectStatement::unsafe_arena_set_allocated_offset_expr(
    ::infinity_grpc_proto::ParsedExpr* offset_expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offset_expr_);
  }
  _impl_.offset_expr_ = offset_expr;
  if (offset_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.SelectStatement.offset_expr)
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::release_offset_expr() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.offset_expr_;
  _impl_.offset_expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::unsafe_arena_release_offset_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.SelectStatement.offset_expr)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.offset_expr_;
  _impl_.offset_expr_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::_internal_mutable_offset_expr() {
  
  if (_impl_.offset_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.offset_expr_ = p;
  }
  return _impl_.offset_expr_;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::mutable_offset_expr() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_offset_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectStatement.offset_expr)
  return _msg;
}
inline void SelectStatement::set_allocated_offset_expr(::infinity_grpc_proto::ParsedExpr* offset_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.offset_expr_;
  }
  if (offset_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offset_expr);
    if (message_arena != submessage_arena) {
      offset_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offset_expr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.offset_expr_ = offset_expr;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.SelectStatement.offset_expr)
}

// .infinity_grpc_proto.ParsedExpr search_expr = 8;
inline bool SelectStatement::_internal_has_search_expr() const {
  return this != internal_default_instance() && _impl_.search_expr_ != nullptr;
}
inline bool SelectStatement::has_search_expr() const {
  return _internal_has_search_expr();
}
inline void SelectStatement::clear_search_expr() {
  if (GetArenaForAllocation() == nullptr && _impl_.search_expr_ != nullptr) {
    delete _impl_.search_expr_;
  }
  _impl_.search_expr_ = nullptr;
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::_internal_search_expr() const {
  const ::infinity_grpc_proto::ParsedExpr* p = _impl_.search_expr_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::ParsedExpr&>(
      ::infinity_grpc_proto::_ParsedExpr_default_instance_);
}
inline const ::infinity_grpc_proto::ParsedExpr& SelectStatement::search_expr() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectStatement.search_expr)
  return _internal_search_expr();
}
inline void SelectStatement::unsafe_arena_set_allocated_search_expr(
    ::infinity_grpc_proto::ParsedExpr* search_expr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.search_expr_);
  }
  _impl_.search_expr_ = search_expr;
  if (search_expr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.SelectStatement.search_expr)
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::release_search_expr() {
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.search_expr_;
  _impl_.search_expr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::unsafe_arena_release_search_expr() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.SelectStatement.search_expr)
  
  ::infinity_grpc_proto::ParsedExpr* temp = _impl_.search_expr_;
  _impl_.search_expr_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::_internal_mutable_search_expr() {
  
  if (_impl_.search_expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::ParsedExpr>(GetArenaForAllocation());
    _impl_.search_expr_ = p;
  }
  return _impl_.search_expr_;
}
inline ::infinity_grpc_proto::ParsedExpr* SelectStatement::mutable_search_expr() {
  ::infinity_grpc_proto::ParsedExpr* _msg = _internal_mutable_search_expr();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectStatement.search_expr)
  return _msg;
}
inline void SelectStatement::set_allocated_search_expr(::infinity_grpc_proto::ParsedExpr* search_expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.search_expr_;
  }
  if (search_expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(search_expr);
    if (message_arena != submessage_arena) {
      search_expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, search_expr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.search_expr_ = search_expr;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.SelectStatement.search_expr)
}

// -------------------------------------------------------------------

// DisConnectRequest

// uint64 session_id = 1;
inline void DisConnectRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t DisConnectRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t DisConnectRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DisConnectRequest.session_id)
  return _internal_session_id();
}
inline void DisConnectRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void DisConnectRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DisConnectRequest.session_id)
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// CommonResponse

// bool success = 1;
inline void CommonResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool CommonResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool CommonResponse::success() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CommonResponse.success)
  return _internal_success();
}
inline void CommonResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void CommonResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CommonResponse.success)
}

// string error_msg = 2;
inline void CommonResponse::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& CommonResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CommonResponse.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommonResponse::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CommonResponse.error_msg)
}
inline std::string* CommonResponse::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CommonResponse.error_msg)
  return _s;
}
inline const std::string& CommonResponse::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void CommonResponse::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* CommonResponse::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* CommonResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CommonResponse.error_msg)
  return _impl_.error_msg_.Release();
}
inline void CommonResponse::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CommonResponse.error_msg)
}

// uint64 session_id = 3;
inline void CommonResponse::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t CommonResponse::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t CommonResponse::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CommonResponse.session_id)
  return _internal_session_id();
}
inline void CommonResponse::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void CommonResponse::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CommonResponse.session_id)
}

// -------------------------------------------------------------------

// SelectResponse

// bool success = 1;
inline void SelectResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool SelectResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool SelectResponse::success() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectResponse.success)
  return _internal_success();
}
inline void SelectResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void SelectResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.SelectResponse.success)
}

// string error_msg = 2;
inline void SelectResponse::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& SelectResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectResponse.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectResponse::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.SelectResponse.error_msg)
}
inline std::string* SelectResponse::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectResponse.error_msg)
  return _s;
}
inline const std::string& SelectResponse::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void SelectResponse::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectResponse::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.SelectResponse.error_msg)
  return _impl_.error_msg_.Release();
}
inline void SelectResponse::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.SelectResponse.error_msg)
}

// repeated .infinity_grpc_proto.ColumnDef column_defs = 3;
inline int SelectResponse::_internal_column_defs_size() const {
  return _impl_.column_defs_.size();
}
inline int SelectResponse::column_defs_size() const {
  return _internal_column_defs_size();
}
inline void SelectResponse::clear_column_defs() {
  _impl_.column_defs_.Clear();
}
inline ::infinity_grpc_proto::ColumnDef* SelectResponse::mutable_column_defs(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectResponse.column_defs)
  return _impl_.column_defs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef >*
SelectResponse::mutable_column_defs() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.SelectResponse.column_defs)
  return &_impl_.column_defs_;
}
inline const ::infinity_grpc_proto::ColumnDef& SelectResponse::_internal_column_defs(int index) const {
  return _impl_.column_defs_.Get(index);
}
inline const ::infinity_grpc_proto::ColumnDef& SelectResponse::column_defs(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectResponse.column_defs)
  return _internal_column_defs(index);
}
inline ::infinity_grpc_proto::ColumnDef* SelectResponse::_internal_add_column_defs() {
  return _impl_.column_defs_.Add();
}
inline ::infinity_grpc_proto::ColumnDef* SelectResponse::add_column_defs() {
  ::infinity_grpc_proto::ColumnDef* _add = _internal_add_column_defs();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.SelectResponse.column_defs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnDef >&
SelectResponse::column_defs() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.SelectResponse.column_defs)
  return _impl_.column_defs_;
}

// repeated .infinity_grpc_proto.ColumnField column_fields = 4;
inline int SelectResponse::_internal_column_fields_size() const {
  return _impl_.column_fields_.size();
}
inline int SelectResponse::column_fields_size() const {
  return _internal_column_fields_size();
}
inline void SelectResponse::clear_column_fields() {
  _impl_.column_fields_.Clear();
}
inline ::infinity_grpc_proto::ColumnField* SelectResponse::mutable_column_fields(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.SelectResponse.column_fields)
  return _impl_.column_fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnField >*
SelectResponse::mutable_column_fields() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.SelectResponse.column_fields)
  return &_impl_.column_fields_;
}
inline const ::infinity_grpc_proto::ColumnField& SelectResponse::_internal_column_fields(int index) const {
  return _impl_.column_fields_.Get(index);
}
inline const ::infinity_grpc_proto::ColumnField& SelectResponse::column_fields(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.SelectResponse.column_fields)
  return _internal_column_fields(index);
}
inline ::infinity_grpc_proto::ColumnField* SelectResponse::_internal_add_column_fields() {
  return _impl_.column_fields_.Add();
}
inline ::infinity_grpc_proto::ColumnField* SelectResponse::add_column_fields() {
  ::infinity_grpc_proto::ColumnField* _add = _internal_add_column_fields();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.SelectResponse.column_fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::ColumnField >&
SelectResponse::column_fields() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.SelectResponse.column_fields)
  return _impl_.column_fields_;
}

// -------------------------------------------------------------------

// ColumnField

// .infinity_grpc_proto.ColumnType column_type = 1;
inline void ColumnField::clear_column_type() {
  _impl_.column_type_ = 0;
}
inline ::infinity_grpc_proto::ColumnType ColumnField::_internal_column_type() const {
  return static_cast< ::infinity_grpc_proto::ColumnType >(_impl_.column_type_);
}
inline ::infinity_grpc_proto::ColumnType ColumnField::column_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnField.column_type)
  return _internal_column_type();
}
inline void ColumnField::_internal_set_column_type(::infinity_grpc_proto::ColumnType value) {
  
  _impl_.column_type_ = value;
}
inline void ColumnField::set_column_type(::infinity_grpc_proto::ColumnType value) {
  _internal_set_column_type(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnField.column_type)
}

// bytes column_vector = 2;
inline void ColumnField::clear_column_vector() {
  _impl_.column_vector_.ClearToEmpty();
}
inline const std::string& ColumnField::column_vector() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ColumnField.column_vector)
  return _internal_column_vector();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnField::set_column_vector(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_vector_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ColumnField.column_vector)
}
inline std::string* ColumnField::mutable_column_vector() {
  std::string* _s = _internal_mutable_column_vector();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ColumnField.column_vector)
  return _s;
}
inline const std::string& ColumnField::_internal_column_vector() const {
  return _impl_.column_vector_.Get();
}
inline void ColumnField::_internal_set_column_vector(const std::string& value) {
  
  _impl_.column_vector_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnField::_internal_mutable_column_vector() {
  
  return _impl_.column_vector_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnField::release_column_vector() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ColumnField.column_vector)
  return _impl_.column_vector_.Release();
}
inline void ColumnField::set_allocated_column_vector(std::string* column_vector) {
  if (column_vector != nullptr) {
    
  } else {
    
  }
  _impl_.column_vector_.SetAllocated(column_vector, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_vector_.IsDefault()) {
    _impl_.column_vector_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ColumnField.column_vector)
}

// -------------------------------------------------------------------

// DataBlock_ColumnVector

// repeated .infinity_grpc_proto.DataBlock.ColumnVector column_vectors = 1;
inline int DataBlock_ColumnVector::_internal_column_vectors_size() const {
  return _impl_.column_vectors_.size();
}
inline int DataBlock_ColumnVector::column_vectors_size() const {
  return _internal_column_vectors_size();
}
inline void DataBlock_ColumnVector::clear_column_vectors() {
  _impl_.column_vectors_.Clear();
}
inline ::infinity_grpc_proto::DataBlock_ColumnVector* DataBlock_ColumnVector::mutable_column_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DataBlock.ColumnVector.column_vectors)
  return _impl_.column_vectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector >*
DataBlock_ColumnVector::mutable_column_vectors() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.DataBlock.ColumnVector.column_vectors)
  return &_impl_.column_vectors_;
}
inline const ::infinity_grpc_proto::DataBlock_ColumnVector& DataBlock_ColumnVector::_internal_column_vectors(int index) const {
  return _impl_.column_vectors_.Get(index);
}
inline const ::infinity_grpc_proto::DataBlock_ColumnVector& DataBlock_ColumnVector::column_vectors(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataBlock.ColumnVector.column_vectors)
  return _internal_column_vectors(index);
}
inline ::infinity_grpc_proto::DataBlock_ColumnVector* DataBlock_ColumnVector::_internal_add_column_vectors() {
  return _impl_.column_vectors_.Add();
}
inline ::infinity_grpc_proto::DataBlock_ColumnVector* DataBlock_ColumnVector::add_column_vectors() {
  ::infinity_grpc_proto::DataBlock_ColumnVector* _add = _internal_add_column_vectors();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.DataBlock.ColumnVector.column_vectors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector >&
DataBlock_ColumnVector::column_vectors() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.DataBlock.ColumnVector.column_vectors)
  return _impl_.column_vectors_;
}

// -------------------------------------------------------------------

// DataBlock

// int32 row_count = 1;
inline void DataBlock::clear_row_count() {
  _impl_.row_count_ = 0;
}
inline int32_t DataBlock::_internal_row_count() const {
  return _impl_.row_count_;
}
inline int32_t DataBlock::row_count() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataBlock.row_count)
  return _internal_row_count();
}
inline void DataBlock::_internal_set_row_count(int32_t value) {
  
  _impl_.row_count_ = value;
}
inline void DataBlock::set_row_count(int32_t value) {
  _internal_set_row_count(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DataBlock.row_count)
}

// int32 column_count = 2;
inline void DataBlock::clear_column_count() {
  _impl_.column_count_ = 0;
}
inline int32_t DataBlock::_internal_column_count() const {
  return _impl_.column_count_;
}
inline int32_t DataBlock::column_count() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataBlock.column_count)
  return _internal_column_count();
}
inline void DataBlock::_internal_set_column_count(int32_t value) {
  
  _impl_.column_count_ = value;
}
inline void DataBlock::set_column_count(int32_t value) {
  _internal_set_column_count(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DataBlock.column_count)
}

// int32 capacity = 3;
inline void DataBlock::clear_capacity() {
  _impl_.capacity_ = 0;
}
inline int32_t DataBlock::_internal_capacity() const {
  return _impl_.capacity_;
}
inline int32_t DataBlock::capacity() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataBlock.capacity)
  return _internal_capacity();
}
inline void DataBlock::_internal_set_capacity(int32_t value) {
  
  _impl_.capacity_ = value;
}
inline void DataBlock::set_capacity(int32_t value) {
  _internal_set_capacity(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DataBlock.capacity)
}

// repeated .infinity_grpc_proto.DataBlock.ColumnVector column_vectors = 4;
inline int DataBlock::_internal_column_vectors_size() const {
  return _impl_.column_vectors_.size();
}
inline int DataBlock::column_vectors_size() const {
  return _internal_column_vectors_size();
}
inline void DataBlock::clear_column_vectors() {
  _impl_.column_vectors_.Clear();
}
inline ::infinity_grpc_proto::DataBlock_ColumnVector* DataBlock::mutable_column_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DataBlock.column_vectors)
  return _impl_.column_vectors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector >*
DataBlock::mutable_column_vectors() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.DataBlock.column_vectors)
  return &_impl_.column_vectors_;
}
inline const ::infinity_grpc_proto::DataBlock_ColumnVector& DataBlock::_internal_column_vectors(int index) const {
  return _impl_.column_vectors_.Get(index);
}
inline const ::infinity_grpc_proto::DataBlock_ColumnVector& DataBlock::column_vectors(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DataBlock.column_vectors)
  return _internal_column_vectors(index);
}
inline ::infinity_grpc_proto::DataBlock_ColumnVector* DataBlock::_internal_add_column_vectors() {
  return _impl_.column_vectors_.Add();
}
inline ::infinity_grpc_proto::DataBlock_ColumnVector* DataBlock::add_column_vectors() {
  ::infinity_grpc_proto::DataBlock_ColumnVector* _add = _internal_add_column_vectors();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.DataBlock.column_vectors)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::DataBlock_ColumnVector >&
DataBlock::column_vectors() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.DataBlock.column_vectors)
  return _impl_.column_vectors_;
}

// -------------------------------------------------------------------

// ListDatabaseRequest

// uint64 session_id = 1;
inline void ListDatabaseRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t ListDatabaseRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t ListDatabaseRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListDatabaseRequest.session_id)
  return _internal_session_id();
}
inline void ListDatabaseRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void ListDatabaseRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListDatabaseRequest.session_id)
}

// -------------------------------------------------------------------

// ListDatabaseResponse

// repeated string db_names = 1;
inline int ListDatabaseResponse::_internal_db_names_size() const {
  return _impl_.db_names_.size();
}
inline int ListDatabaseResponse::db_names_size() const {
  return _internal_db_names_size();
}
inline void ListDatabaseResponse::clear_db_names() {
  _impl_.db_names_.Clear();
}
inline std::string* ListDatabaseResponse::add_db_names() {
  std::string* _s = _internal_add_db_names();
  // @@protoc_insertion_point(field_add_mutable:infinity_grpc_proto.ListDatabaseResponse.db_names)
  return _s;
}
inline const std::string& ListDatabaseResponse::_internal_db_names(int index) const {
  return _impl_.db_names_.Get(index);
}
inline const std::string& ListDatabaseResponse::db_names(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListDatabaseResponse.db_names)
  return _internal_db_names(index);
}
inline std::string* ListDatabaseResponse::mutable_db_names(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ListDatabaseResponse.db_names)
  return _impl_.db_names_.Mutable(index);
}
inline void ListDatabaseResponse::set_db_names(int index, const std::string& value) {
  _impl_.db_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListDatabaseResponse.db_names)
}
inline void ListDatabaseResponse::set_db_names(int index, std::string&& value) {
  _impl_.db_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListDatabaseResponse.db_names)
}
inline void ListDatabaseResponse::set_db_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.db_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:infinity_grpc_proto.ListDatabaseResponse.db_names)
}
inline void ListDatabaseResponse::set_db_names(int index, const char* value, size_t size) {
  _impl_.db_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:infinity_grpc_proto.ListDatabaseResponse.db_names)
}
inline std::string* ListDatabaseResponse::_internal_add_db_names() {
  return _impl_.db_names_.Add();
}
inline void ListDatabaseResponse::add_db_names(const std::string& value) {
  _impl_.db_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ListDatabaseResponse.db_names)
}
inline void ListDatabaseResponse::add_db_names(std::string&& value) {
  _impl_.db_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ListDatabaseResponse.db_names)
}
inline void ListDatabaseResponse::add_db_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.db_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:infinity_grpc_proto.ListDatabaseResponse.db_names)
}
inline void ListDatabaseResponse::add_db_names(const char* value, size_t size) {
  _impl_.db_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:infinity_grpc_proto.ListDatabaseResponse.db_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListDatabaseResponse::db_names() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.ListDatabaseResponse.db_names)
  return _impl_.db_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListDatabaseResponse::mutable_db_names() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.ListDatabaseResponse.db_names)
  return &_impl_.db_names_;
}

// bool success = 2;
inline void ListDatabaseResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ListDatabaseResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ListDatabaseResponse::success() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListDatabaseResponse.success)
  return _internal_success();
}
inline void ListDatabaseResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ListDatabaseResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListDatabaseResponse.success)
}

// string error_msg = 3;
inline void ListDatabaseResponse::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& ListDatabaseResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListDatabaseResponse.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListDatabaseResponse::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListDatabaseResponse.error_msg)
}
inline std::string* ListDatabaseResponse::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ListDatabaseResponse.error_msg)
  return _s;
}
inline const std::string& ListDatabaseResponse::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void ListDatabaseResponse::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ListDatabaseResponse::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ListDatabaseResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ListDatabaseResponse.error_msg)
  return _impl_.error_msg_.Release();
}
inline void ListDatabaseResponse::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ListDatabaseResponse.error_msg)
}

// -------------------------------------------------------------------

// DescribeDatabaseRequest

// string db_name = 1;
inline void DescribeDatabaseRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& DescribeDatabaseRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeDatabaseRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DescribeDatabaseRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeDatabaseRequest.db_name)
}
inline std::string* DescribeDatabaseRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DescribeDatabaseRequest.db_name)
  return _s;
}
inline const std::string& DescribeDatabaseRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void DescribeDatabaseRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DescribeDatabaseRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DescribeDatabaseRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DescribeDatabaseRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void DescribeDatabaseRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DescribeDatabaseRequest.db_name)
}

// uint64 session_id = 2;
inline void DescribeDatabaseRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t DescribeDatabaseRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t DescribeDatabaseRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeDatabaseRequest.session_id)
  return _internal_session_id();
}
inline void DescribeDatabaseRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void DescribeDatabaseRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeDatabaseRequest.session_id)
}

// -------------------------------------------------------------------

// DescribeDatabaseResponse

// string db_name = 1;
inline void DescribeDatabaseResponse::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& DescribeDatabaseResponse::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeDatabaseResponse.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DescribeDatabaseResponse::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeDatabaseResponse.db_name)
}
inline std::string* DescribeDatabaseResponse::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DescribeDatabaseResponse.db_name)
  return _s;
}
inline const std::string& DescribeDatabaseResponse::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void DescribeDatabaseResponse::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DescribeDatabaseResponse::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DescribeDatabaseResponse::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DescribeDatabaseResponse.db_name)
  return _impl_.db_name_.Release();
}
inline void DescribeDatabaseResponse::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DescribeDatabaseResponse.db_name)
}

// int32 db_id = 2;
inline void DescribeDatabaseResponse::clear_db_id() {
  _impl_.db_id_ = 0;
}
inline int32_t DescribeDatabaseResponse::_internal_db_id() const {
  return _impl_.db_id_;
}
inline int32_t DescribeDatabaseResponse::db_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeDatabaseResponse.db_id)
  return _internal_db_id();
}
inline void DescribeDatabaseResponse::_internal_set_db_id(int32_t value) {
  
  _impl_.db_id_ = value;
}
inline void DescribeDatabaseResponse::set_db_id(int32_t value) {
  _internal_set_db_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeDatabaseResponse.db_id)
}

// int32 num_segments = 3;
inline void DescribeDatabaseResponse::clear_num_segments() {
  _impl_.num_segments_ = 0;
}
inline int32_t DescribeDatabaseResponse::_internal_num_segments() const {
  return _impl_.num_segments_;
}
inline int32_t DescribeDatabaseResponse::num_segments() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeDatabaseResponse.num_segments)
  return _internal_num_segments();
}
inline void DescribeDatabaseResponse::_internal_set_num_segments(int32_t value) {
  
  _impl_.num_segments_ = value;
}
inline void DescribeDatabaseResponse::set_num_segments(int32_t value) {
  _internal_set_num_segments(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeDatabaseResponse.num_segments)
}

// int32 num_blocks = 4;
inline void DescribeDatabaseResponse::clear_num_blocks() {
  _impl_.num_blocks_ = 0;
}
inline int32_t DescribeDatabaseResponse::_internal_num_blocks() const {
  return _impl_.num_blocks_;
}
inline int32_t DescribeDatabaseResponse::num_blocks() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeDatabaseResponse.num_blocks)
  return _internal_num_blocks();
}
inline void DescribeDatabaseResponse::_internal_set_num_blocks(int32_t value) {
  
  _impl_.num_blocks_ = value;
}
inline void DescribeDatabaseResponse::set_num_blocks(int32_t value) {
  _internal_set_num_blocks(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeDatabaseResponse.num_blocks)
}

// -------------------------------------------------------------------

// ListTableRequest

// string db_name = 1;
inline void ListTableRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& ListTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListTableRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTableRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListTableRequest.db_name)
}
inline std::string* ListTableRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ListTableRequest.db_name)
  return _s;
}
inline const std::string& ListTableRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void ListTableRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTableRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ListTableRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void ListTableRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ListTableRequest.db_name)
}

// bool success = 2;
inline void ListTableRequest::clear_success() {
  _impl_.success_ = false;
}
inline bool ListTableRequest::_internal_success() const {
  return _impl_.success_;
}
inline bool ListTableRequest::success() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListTableRequest.success)
  return _internal_success();
}
inline void ListTableRequest::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ListTableRequest::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListTableRequest.success)
}

// string error_msg = 3;
inline void ListTableRequest::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& ListTableRequest::error_msg() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListTableRequest.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTableRequest::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListTableRequest.error_msg)
}
inline std::string* ListTableRequest::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ListTableRequest.error_msg)
  return _s;
}
inline const std::string& ListTableRequest::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void ListTableRequest::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTableRequest::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTableRequest::release_error_msg() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ListTableRequest.error_msg)
  return _impl_.error_msg_.Release();
}
inline void ListTableRequest::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ListTableRequest.error_msg)
}

// uint64 session_id = 4;
inline void ListTableRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t ListTableRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t ListTableRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListTableRequest.session_id)
  return _internal_session_id();
}
inline void ListTableRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void ListTableRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListTableRequest.session_id)
}

// -------------------------------------------------------------------

// ListTableResponse

// repeated string table_name = 1;
inline int ListTableResponse::_internal_table_name_size() const {
  return _impl_.table_name_.size();
}
inline int ListTableResponse::table_name_size() const {
  return _internal_table_name_size();
}
inline void ListTableResponse::clear_table_name() {
  _impl_.table_name_.Clear();
}
inline std::string* ListTableResponse::add_table_name() {
  std::string* _s = _internal_add_table_name();
  // @@protoc_insertion_point(field_add_mutable:infinity_grpc_proto.ListTableResponse.table_name)
  return _s;
}
inline const std::string& ListTableResponse::_internal_table_name(int index) const {
  return _impl_.table_name_.Get(index);
}
inline const std::string& ListTableResponse::table_name(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListTableResponse.table_name)
  return _internal_table_name(index);
}
inline std::string* ListTableResponse::mutable_table_name(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ListTableResponse.table_name)
  return _impl_.table_name_.Mutable(index);
}
inline void ListTableResponse::set_table_name(int index, const std::string& value) {
  _impl_.table_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListTableResponse.table_name)
}
inline void ListTableResponse::set_table_name(int index, std::string&& value) {
  _impl_.table_name_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListTableResponse.table_name)
}
inline void ListTableResponse::set_table_name(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.table_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:infinity_grpc_proto.ListTableResponse.table_name)
}
inline void ListTableResponse::set_table_name(int index, const char* value, size_t size) {
  _impl_.table_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:infinity_grpc_proto.ListTableResponse.table_name)
}
inline std::string* ListTableResponse::_internal_add_table_name() {
  return _impl_.table_name_.Add();
}
inline void ListTableResponse::add_table_name(const std::string& value) {
  _impl_.table_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ListTableResponse.table_name)
}
inline void ListTableResponse::add_table_name(std::string&& value) {
  _impl_.table_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.ListTableResponse.table_name)
}
inline void ListTableResponse::add_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.table_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:infinity_grpc_proto.ListTableResponse.table_name)
}
inline void ListTableResponse::add_table_name(const char* value, size_t size) {
  _impl_.table_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:infinity_grpc_proto.ListTableResponse.table_name)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListTableResponse::table_name() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.ListTableResponse.table_name)
  return _impl_.table_name_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListTableResponse::mutable_table_name() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.ListTableResponse.table_name)
  return &_impl_.table_name_;
}

// bool success = 2;
inline void ListTableResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ListTableResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ListTableResponse::success() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListTableResponse.success)
  return _internal_success();
}
inline void ListTableResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ListTableResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListTableResponse.success)
}

// string error_msg = 3;
inline void ListTableResponse::clear_error_msg() {
  _impl_.error_msg_.ClearToEmpty();
}
inline const std::string& ListTableResponse::error_msg() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.ListTableResponse.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListTableResponse::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.ListTableResponse.error_msg)
}
inline std::string* ListTableResponse::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.ListTableResponse.error_msg)
  return _s;
}
inline const std::string& ListTableResponse::_internal_error_msg() const {
  return _impl_.error_msg_.Get();
}
inline void ListTableResponse::_internal_set_error_msg(const std::string& value) {
  
  _impl_.error_msg_.Set(value, GetArenaForAllocation());
}
inline std::string* ListTableResponse::_internal_mutable_error_msg() {
  
  return _impl_.error_msg_.Mutable(GetArenaForAllocation());
}
inline std::string* ListTableResponse::release_error_msg() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.ListTableResponse.error_msg)
  return _impl_.error_msg_.Release();
}
inline void ListTableResponse::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  _impl_.error_msg_.SetAllocated(error_msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_msg_.IsDefault()) {
    _impl_.error_msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.ListTableResponse.error_msg)
}

// -------------------------------------------------------------------

// DescribeTableRequest

// string db_name = 1;
inline void DescribeTableRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& DescribeTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeTableRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DescribeTableRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeTableRequest.db_name)
}
inline std::string* DescribeTableRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DescribeTableRequest.db_name)
  return _s;
}
inline const std::string& DescribeTableRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void DescribeTableRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DescribeTableRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DescribeTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DescribeTableRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void DescribeTableRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DescribeTableRequest.db_name)
}

// uint64 session_id = 2;
inline void DescribeTableRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t DescribeTableRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t DescribeTableRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeTableRequest.session_id)
  return _internal_session_id();
}
inline void DescribeTableRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void DescribeTableRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeTableRequest.session_id)
}

// -------------------------------------------------------------------

// DescribeTableResponse

// string table_name = 1;
inline void DescribeTableResponse::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DescribeTableResponse::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeTableResponse.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DescribeTableResponse::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeTableResponse.table_name)
}
inline std::string* DescribeTableResponse::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DescribeTableResponse.table_name)
  return _s;
}
inline const std::string& DescribeTableResponse::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DescribeTableResponse::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DescribeTableResponse::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DescribeTableResponse::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DescribeTableResponse.table_name)
  return _impl_.table_name_.Release();
}
inline void DescribeTableResponse::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DescribeTableResponse.table_name)
}

// int32 table_id = 2;
inline void DescribeTableResponse::clear_table_id() {
  _impl_.table_id_ = 0;
}
inline int32_t DescribeTableResponse::_internal_table_id() const {
  return _impl_.table_id_;
}
inline int32_t DescribeTableResponse::table_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeTableResponse.table_id)
  return _internal_table_id();
}
inline void DescribeTableResponse::_internal_set_table_id(int32_t value) {
  
  _impl_.table_id_ = value;
}
inline void DescribeTableResponse::set_table_id(int32_t value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeTableResponse.table_id)
}

// int32 num_segments = 3;
inline void DescribeTableResponse::clear_num_segments() {
  _impl_.num_segments_ = 0;
}
inline int32_t DescribeTableResponse::_internal_num_segments() const {
  return _impl_.num_segments_;
}
inline int32_t DescribeTableResponse::num_segments() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeTableResponse.num_segments)
  return _internal_num_segments();
}
inline void DescribeTableResponse::_internal_set_num_segments(int32_t value) {
  
  _impl_.num_segments_ = value;
}
inline void DescribeTableResponse::set_num_segments(int32_t value) {
  _internal_set_num_segments(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeTableResponse.num_segments)
}

// int32 num_blocks = 4;
inline void DescribeTableResponse::clear_num_blocks() {
  _impl_.num_blocks_ = 0;
}
inline int32_t DescribeTableResponse::_internal_num_blocks() const {
  return _impl_.num_blocks_;
}
inline int32_t DescribeTableResponse::num_blocks() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DescribeTableResponse.num_blocks)
  return _internal_num_blocks();
}
inline void DescribeTableResponse::_internal_set_num_blocks(int32_t value) {
  
  _impl_.num_blocks_ = value;
}
inline void DescribeTableResponse::set_num_blocks(int32_t value) {
  _internal_set_num_blocks(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DescribeTableResponse.num_blocks)
}

// -------------------------------------------------------------------

// GetDatabaseRequest

// string db_name = 1;
inline void GetDatabaseRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& GetDatabaseRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.GetDatabaseRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDatabaseRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.GetDatabaseRequest.db_name)
}
inline std::string* GetDatabaseRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.GetDatabaseRequest.db_name)
  return _s;
}
inline const std::string& GetDatabaseRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void GetDatabaseRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetDatabaseRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetDatabaseRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.GetDatabaseRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void GetDatabaseRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.GetDatabaseRequest.db_name)
}

// uint64 session_id = 2;
inline void GetDatabaseRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t GetDatabaseRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t GetDatabaseRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.GetDatabaseRequest.session_id)
  return _internal_session_id();
}
inline void GetDatabaseRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void GetDatabaseRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.GetDatabaseRequest.session_id)
}

// -------------------------------------------------------------------

// GetTableRequest

// string db_name = 1;
inline void GetTableRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& GetTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.GetTableRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTableRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.GetTableRequest.db_name)
}
inline std::string* GetTableRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.GetTableRequest.db_name)
  return _s;
}
inline const std::string& GetTableRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void GetTableRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTableRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.GetTableRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void GetTableRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.GetTableRequest.db_name)
}

// string table_name = 2;
inline void GetTableRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& GetTableRequest::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.GetTableRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTableRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.GetTableRequest.table_name)
}
inline std::string* GetTableRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.GetTableRequest.table_name)
  return _s;
}
inline const std::string& GetTableRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void GetTableRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTableRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTableRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.GetTableRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void GetTableRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.GetTableRequest.table_name)
}

// uint64 session_id = 3;
inline void GetTableRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t GetTableRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t GetTableRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.GetTableRequest.session_id)
  return _internal_session_id();
}
inline void GetTableRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void GetTableRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.GetTableRequest.session_id)
}

// -------------------------------------------------------------------

// CreateIndexRequest

// string db_name = 1;
inline void CreateIndexRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& CreateIndexRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateIndexRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIndexRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateIndexRequest.db_name)
}
inline std::string* CreateIndexRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateIndexRequest.db_name)
  return _s;
}
inline const std::string& CreateIndexRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void CreateIndexRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateIndexRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void CreateIndexRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateIndexRequest.db_name)
}

// string table_name = 2;
inline void CreateIndexRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& CreateIndexRequest::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateIndexRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIndexRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateIndexRequest.table_name)
}
inline std::string* CreateIndexRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateIndexRequest.table_name)
  return _s;
}
inline const std::string& CreateIndexRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void CreateIndexRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateIndexRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void CreateIndexRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateIndexRequest.table_name)
}

// string index_name = 3;
inline void CreateIndexRequest::clear_index_name() {
  _impl_.index_name_.ClearToEmpty();
}
inline const std::string& CreateIndexRequest::index_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateIndexRequest.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIndexRequest::set_index_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateIndexRequest.index_name)
}
inline std::string* CreateIndexRequest::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateIndexRequest.index_name)
  return _s;
}
inline const std::string& CreateIndexRequest::_internal_index_name() const {
  return _impl_.index_name_.Get();
}
inline void CreateIndexRequest::_internal_set_index_name(const std::string& value) {
  
  _impl_.index_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::_internal_mutable_index_name() {
  
  return _impl_.index_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::release_index_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateIndexRequest.index_name)
  return _impl_.index_name_.Release();
}
inline void CreateIndexRequest::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    
  } else {
    
  }
  _impl_.index_name_.SetAllocated(index_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_name_.IsDefault()) {
    _impl_.index_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateIndexRequest.index_name)
}

// string method_type = 4;
inline void CreateIndexRequest::clear_method_type() {
  _impl_.method_type_.ClearToEmpty();
}
inline const std::string& CreateIndexRequest::method_type() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateIndexRequest.method_type)
  return _internal_method_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIndexRequest::set_method_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.method_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateIndexRequest.method_type)
}
inline std::string* CreateIndexRequest::mutable_method_type() {
  std::string* _s = _internal_mutable_method_type();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateIndexRequest.method_type)
  return _s;
}
inline const std::string& CreateIndexRequest::_internal_method_type() const {
  return _impl_.method_type_.Get();
}
inline void CreateIndexRequest::_internal_set_method_type(const std::string& value) {
  
  _impl_.method_type_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::_internal_mutable_method_type() {
  
  return _impl_.method_type_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::release_method_type() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateIndexRequest.method_type)
  return _impl_.method_type_.Release();
}
inline void CreateIndexRequest::set_allocated_method_type(std::string* method_type) {
  if (method_type != nullptr) {
    
  } else {
    
  }
  _impl_.method_type_.SetAllocated(method_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.method_type_.IsDefault()) {
    _impl_.method_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateIndexRequest.method_type)
}

// repeated string column_names = 5;
inline int CreateIndexRequest::_internal_column_names_size() const {
  return _impl_.column_names_.size();
}
inline int CreateIndexRequest::column_names_size() const {
  return _internal_column_names_size();
}
inline void CreateIndexRequest::clear_column_names() {
  _impl_.column_names_.Clear();
}
inline std::string* CreateIndexRequest::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:infinity_grpc_proto.CreateIndexRequest.column_names)
  return _s;
}
inline const std::string& CreateIndexRequest::_internal_column_names(int index) const {
  return _impl_.column_names_.Get(index);
}
inline const std::string& CreateIndexRequest::column_names(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateIndexRequest.column_names)
  return _internal_column_names(index);
}
inline std::string* CreateIndexRequest::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateIndexRequest.column_names)
  return _impl_.column_names_.Mutable(index);
}
inline void CreateIndexRequest::set_column_names(int index, const std::string& value) {
  _impl_.column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateIndexRequest.column_names)
}
inline void CreateIndexRequest::set_column_names(int index, std::string&& value) {
  _impl_.column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateIndexRequest.column_names)
}
inline void CreateIndexRequest::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:infinity_grpc_proto.CreateIndexRequest.column_names)
}
inline void CreateIndexRequest::set_column_names(int index, const char* value, size_t size) {
  _impl_.column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:infinity_grpc_proto.CreateIndexRequest.column_names)
}
inline std::string* CreateIndexRequest::_internal_add_column_names() {
  return _impl_.column_names_.Add();
}
inline void CreateIndexRequest::add_column_names(const std::string& value) {
  _impl_.column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.CreateIndexRequest.column_names)
}
inline void CreateIndexRequest::add_column_names(std::string&& value) {
  _impl_.column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.CreateIndexRequest.column_names)
}
inline void CreateIndexRequest::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:infinity_grpc_proto.CreateIndexRequest.column_names)
}
inline void CreateIndexRequest::add_column_names(const char* value, size_t size) {
  _impl_.column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:infinity_grpc_proto.CreateIndexRequest.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateIndexRequest::column_names() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.CreateIndexRequest.column_names)
  return _impl_.column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateIndexRequest::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.CreateIndexRequest.column_names)
  return &_impl_.column_names_;
}

// repeated .infinity_grpc_proto.InitParameter index_para_list = 6;
inline int CreateIndexRequest::_internal_index_para_list_size() const {
  return _impl_.index_para_list_.size();
}
inline int CreateIndexRequest::index_para_list_size() const {
  return _internal_index_para_list_size();
}
inline void CreateIndexRequest::clear_index_para_list() {
  _impl_.index_para_list_.Clear();
}
inline ::infinity_grpc_proto::InitParameter* CreateIndexRequest::mutable_index_para_list(int index) {
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateIndexRequest.index_para_list)
  return _impl_.index_para_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::InitParameter >*
CreateIndexRequest::mutable_index_para_list() {
  // @@protoc_insertion_point(field_mutable_list:infinity_grpc_proto.CreateIndexRequest.index_para_list)
  return &_impl_.index_para_list_;
}
inline const ::infinity_grpc_proto::InitParameter& CreateIndexRequest::_internal_index_para_list(int index) const {
  return _impl_.index_para_list_.Get(index);
}
inline const ::infinity_grpc_proto::InitParameter& CreateIndexRequest::index_para_list(int index) const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateIndexRequest.index_para_list)
  return _internal_index_para_list(index);
}
inline ::infinity_grpc_proto::InitParameter* CreateIndexRequest::_internal_add_index_para_list() {
  return _impl_.index_para_list_.Add();
}
inline ::infinity_grpc_proto::InitParameter* CreateIndexRequest::add_index_para_list() {
  ::infinity_grpc_proto::InitParameter* _add = _internal_add_index_para_list();
  // @@protoc_insertion_point(field_add:infinity_grpc_proto.CreateIndexRequest.index_para_list)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::infinity_grpc_proto::InitParameter >&
CreateIndexRequest::index_para_list() const {
  // @@protoc_insertion_point(field_list:infinity_grpc_proto.CreateIndexRequest.index_para_list)
  return _impl_.index_para_list_;
}

// .infinity_grpc_proto.Options options = 7;
inline bool CreateIndexRequest::_internal_has_options() const {
  return this != internal_default_instance() && _impl_.options_ != nullptr;
}
inline bool CreateIndexRequest::has_options() const {
  return _internal_has_options();
}
inline void CreateIndexRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && _impl_.options_ != nullptr) {
    delete _impl_.options_;
  }
  _impl_.options_ = nullptr;
}
inline const ::infinity_grpc_proto::Options& CreateIndexRequest::_internal_options() const {
  const ::infinity_grpc_proto::Options* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::infinity_grpc_proto::Options&>(
      ::infinity_grpc_proto::_Options_default_instance_);
}
inline const ::infinity_grpc_proto::Options& CreateIndexRequest::options() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateIndexRequest.options)
  return _internal_options();
}
inline void CreateIndexRequest::unsafe_arena_set_allocated_options(
    ::infinity_grpc_proto::Options* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:infinity_grpc_proto.CreateIndexRequest.options)
}
inline ::infinity_grpc_proto::Options* CreateIndexRequest::release_options() {
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::infinity_grpc_proto::Options* CreateIndexRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.CreateIndexRequest.options)
  
  ::infinity_grpc_proto::Options* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::infinity_grpc_proto::Options* CreateIndexRequest::_internal_mutable_options() {
  
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::infinity_grpc_proto::Options>(GetArenaForAllocation());
    _impl_.options_ = p;
  }
  return _impl_.options_;
}
inline ::infinity_grpc_proto::Options* CreateIndexRequest::mutable_options() {
  ::infinity_grpc_proto::Options* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.CreateIndexRequest.options)
  return _msg;
}
inline void CreateIndexRequest::set_allocated_options(::infinity_grpc_proto::Options* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.options_ = options;
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.CreateIndexRequest.options)
}

// uint64 session_id = 8;
inline void CreateIndexRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t CreateIndexRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t CreateIndexRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.CreateIndexRequest.session_id)
  return _internal_session_id();
}
inline void CreateIndexRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void CreateIndexRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.CreateIndexRequest.session_id)
}

// -------------------------------------------------------------------

// InitParameter

// string para_name = 1;
inline void InitParameter::clear_para_name() {
  _impl_.para_name_.ClearToEmpty();
}
inline const std::string& InitParameter::para_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InitParameter.para_name)
  return _internal_para_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitParameter::set_para_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.para_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.InitParameter.para_name)
}
inline std::string* InitParameter::mutable_para_name() {
  std::string* _s = _internal_mutable_para_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.InitParameter.para_name)
  return _s;
}
inline const std::string& InitParameter::_internal_para_name() const {
  return _impl_.para_name_.Get();
}
inline void InitParameter::_internal_set_para_name(const std::string& value) {
  
  _impl_.para_name_.Set(value, GetArenaForAllocation());
}
inline std::string* InitParameter::_internal_mutable_para_name() {
  
  return _impl_.para_name_.Mutable(GetArenaForAllocation());
}
inline std::string* InitParameter::release_para_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.InitParameter.para_name)
  return _impl_.para_name_.Release();
}
inline void InitParameter::set_allocated_para_name(std::string* para_name) {
  if (para_name != nullptr) {
    
  } else {
    
  }
  _impl_.para_name_.SetAllocated(para_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.para_name_.IsDefault()) {
    _impl_.para_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.InitParameter.para_name)
}

// string para_value = 2;
inline void InitParameter::clear_para_value() {
  _impl_.para_value_.ClearToEmpty();
}
inline const std::string& InitParameter::para_value() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.InitParameter.para_value)
  return _internal_para_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InitParameter::set_para_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.para_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.InitParameter.para_value)
}
inline std::string* InitParameter::mutable_para_value() {
  std::string* _s = _internal_mutable_para_value();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.InitParameter.para_value)
  return _s;
}
inline const std::string& InitParameter::_internal_para_value() const {
  return _impl_.para_value_.Get();
}
inline void InitParameter::_internal_set_para_value(const std::string& value) {
  
  _impl_.para_value_.Set(value, GetArenaForAllocation());
}
inline std::string* InitParameter::_internal_mutable_para_value() {
  
  return _impl_.para_value_.Mutable(GetArenaForAllocation());
}
inline std::string* InitParameter::release_para_value() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.InitParameter.para_value)
  return _impl_.para_value_.Release();
}
inline void InitParameter::set_allocated_para_value(std::string* para_value) {
  if (para_value != nullptr) {
    
  } else {
    
  }
  _impl_.para_value_.SetAllocated(para_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.para_value_.IsDefault()) {
    _impl_.para_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.InitParameter.para_value)
}

// -------------------------------------------------------------------

// DropIndexRequest

// string db_name = 1;
inline void DropIndexRequest::clear_db_name() {
  _impl_.db_name_.ClearToEmpty();
}
inline const std::string& DropIndexRequest::db_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropIndexRequest.db_name)
  return _internal_db_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropIndexRequest::set_db_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.db_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropIndexRequest.db_name)
}
inline std::string* DropIndexRequest::mutable_db_name() {
  std::string* _s = _internal_mutable_db_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DropIndexRequest.db_name)
  return _s;
}
inline const std::string& DropIndexRequest::_internal_db_name() const {
  return _impl_.db_name_.Get();
}
inline void DropIndexRequest::_internal_set_db_name(const std::string& value) {
  
  _impl_.db_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropIndexRequest::_internal_mutable_db_name() {
  
  return _impl_.db_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropIndexRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DropIndexRequest.db_name)
  return _impl_.db_name_.Release();
}
inline void DropIndexRequest::set_allocated_db_name(std::string* db_name) {
  if (db_name != nullptr) {
    
  } else {
    
  }
  _impl_.db_name_.SetAllocated(db_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.db_name_.IsDefault()) {
    _impl_.db_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DropIndexRequest.db_name)
}

// string table_name = 2;
inline void DropIndexRequest::clear_table_name() {
  _impl_.table_name_.ClearToEmpty();
}
inline const std::string& DropIndexRequest::table_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropIndexRequest.table_name)
  return _internal_table_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropIndexRequest::set_table_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.table_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropIndexRequest.table_name)
}
inline std::string* DropIndexRequest::mutable_table_name() {
  std::string* _s = _internal_mutable_table_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DropIndexRequest.table_name)
  return _s;
}
inline const std::string& DropIndexRequest::_internal_table_name() const {
  return _impl_.table_name_.Get();
}
inline void DropIndexRequest::_internal_set_table_name(const std::string& value) {
  
  _impl_.table_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropIndexRequest::_internal_mutable_table_name() {
  
  return _impl_.table_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropIndexRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DropIndexRequest.table_name)
  return _impl_.table_name_.Release();
}
inline void DropIndexRequest::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    
  } else {
    
  }
  _impl_.table_name_.SetAllocated(table_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.table_name_.IsDefault()) {
    _impl_.table_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DropIndexRequest.table_name)
}

// string index_name = 3;
inline void DropIndexRequest::clear_index_name() {
  _impl_.index_name_.ClearToEmpty();
}
inline const std::string& DropIndexRequest::index_name() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropIndexRequest.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropIndexRequest::set_index_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.index_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropIndexRequest.index_name)
}
inline std::string* DropIndexRequest::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:infinity_grpc_proto.DropIndexRequest.index_name)
  return _s;
}
inline const std::string& DropIndexRequest::_internal_index_name() const {
  return _impl_.index_name_.Get();
}
inline void DropIndexRequest::_internal_set_index_name(const std::string& value) {
  
  _impl_.index_name_.Set(value, GetArenaForAllocation());
}
inline std::string* DropIndexRequest::_internal_mutable_index_name() {
  
  return _impl_.index_name_.Mutable(GetArenaForAllocation());
}
inline std::string* DropIndexRequest::release_index_name() {
  // @@protoc_insertion_point(field_release:infinity_grpc_proto.DropIndexRequest.index_name)
  return _impl_.index_name_.Release();
}
inline void DropIndexRequest::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    
  } else {
    
  }
  _impl_.index_name_.SetAllocated(index_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.index_name_.IsDefault()) {
    _impl_.index_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:infinity_grpc_proto.DropIndexRequest.index_name)
}

// uint64 session_id = 4;
inline void DropIndexRequest::clear_session_id() {
  _impl_.session_id_ = uint64_t{0u};
}
inline uint64_t DropIndexRequest::_internal_session_id() const {
  return _impl_.session_id_;
}
inline uint64_t DropIndexRequest::session_id() const {
  // @@protoc_insertion_point(field_get:infinity_grpc_proto.DropIndexRequest.session_id)
  return _internal_session_id();
}
inline void DropIndexRequest::_internal_set_session_id(uint64_t value) {
  
  _impl_.session_id_ = value;
}
inline void DropIndexRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:infinity_grpc_proto.DropIndexRequest.session_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace infinity_grpc_proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::infinity_grpc_proto::ImportRequest_ImportOptions_CopyFileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infinity_grpc_proto::ImportRequest_ImportOptions_CopyFileType>() {
  return ::infinity_grpc_proto::ImportRequest_ImportOptions_CopyFileType_descriptor();
}
template <> struct is_proto_enum< ::infinity_grpc_proto::ConstantExpr_LiteralType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infinity_grpc_proto::ConstantExpr_LiteralType>() {
  return ::infinity_grpc_proto::ConstantExpr_LiteralType_descriptor();
}
template <> struct is_proto_enum< ::infinity_grpc_proto::KnnExpr_KnnDistanceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infinity_grpc_proto::KnnExpr_KnnDistanceType>() {
  return ::infinity_grpc_proto::KnnExpr_KnnDistanceType_descriptor();
}
template <> struct is_proto_enum< ::infinity_grpc_proto::KnnExpr_EmbeddingDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infinity_grpc_proto::KnnExpr_EmbeddingDataType>() {
  return ::infinity_grpc_proto::KnnExpr_EmbeddingDataType_descriptor();
}
template <> struct is_proto_enum< ::infinity_grpc_proto::LogicType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infinity_grpc_proto::LogicType>() {
  return ::infinity_grpc_proto::LogicType_descriptor();
}
template <> struct is_proto_enum< ::infinity_grpc_proto::Constraint> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infinity_grpc_proto::Constraint>() {
  return ::infinity_grpc_proto::Constraint_descriptor();
}
template <> struct is_proto_enum< ::infinity_grpc_proto::ElementType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infinity_grpc_proto::ElementType>() {
  return ::infinity_grpc_proto::ElementType_descriptor();
}
template <> struct is_proto_enum< ::infinity_grpc_proto::ColumnType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::infinity_grpc_proto::ColumnType>() {
  return ::infinity_grpc_proto::ColumnType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_infinity_5fgrpc_2eproto
