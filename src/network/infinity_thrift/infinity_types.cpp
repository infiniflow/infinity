/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "infinity_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace infinity_thrift_rpc {

int _kLogicTypeValues[] = {
  LogicType::Boolean,
  LogicType::TinyInt,
  LogicType::SmallInt,
  LogicType::Integer,
  LogicType::BigInt,
  LogicType::HugeInt,
  LogicType::Decimal,
  LogicType::Float,
  LogicType::Double,
  LogicType::Float16,
  LogicType::BFloat16,
  LogicType::Varchar,
  LogicType::Embedding,
  LogicType::Tensor,
  LogicType::TensorArray,
  LogicType::Sparse,
  LogicType::MultiVector,
  LogicType::Date,
  LogicType::Time,
  LogicType::DateTime,
  LogicType::Timestamp,
  LogicType::Interval,
  LogicType::Array,
  LogicType::Invalid
};
const char* _kLogicTypeNames[] = {
  "Boolean",
  "TinyInt",
  "SmallInt",
  "Integer",
  "BigInt",
  "HugeInt",
  "Decimal",
  "Float",
  "Double",
  "Float16",
  "BFloat16",
  "Varchar",
  "Embedding",
  "Tensor",
  "TensorArray",
  "Sparse",
  "MultiVector",
  "Date",
  "Time",
  "DateTime",
  "Timestamp",
  "Interval",
  "Array",
  "Invalid"
};
const std::map<int, const char*> _LogicType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(24, _kLogicTypeValues, _kLogicTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LogicType::type& val) {
  std::map<int, const char*>::const_iterator it = _LogicType_VALUES_TO_NAMES.find(val);
  if (it != _LogicType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LogicType::type& val) {
  std::map<int, const char*>::const_iterator it = _LogicType_VALUES_TO_NAMES.find(val);
  if (it != _LogicType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCreateConflictValues[] = {
  CreateConflict::Ignore,
  CreateConflict::Error,
  CreateConflict::Replace
};
const char* _kCreateConflictNames[] = {
  "Ignore",
  "Error",
  "Replace"
};
const std::map<int, const char*> _CreateConflict_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCreateConflictValues, _kCreateConflictNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CreateConflict::type& val) {
  std::map<int, const char*>::const_iterator it = _CreateConflict_VALUES_TO_NAMES.find(val);
  if (it != _CreateConflict_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CreateConflict::type& val) {
  std::map<int, const char*>::const_iterator it = _CreateConflict_VALUES_TO_NAMES.find(val);
  if (it != _CreateConflict_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kDropConflictValues[] = {
  DropConflict::Ignore,
  DropConflict::Error
};
const char* _kDropConflictNames[] = {
  "Ignore",
  "Error"
};
const std::map<int, const char*> _DropConflict_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDropConflictValues, _kDropConflictNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const DropConflict::type& val) {
  std::map<int, const char*>::const_iterator it = _DropConflict_VALUES_TO_NAMES.find(val);
  if (it != _DropConflict_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const DropConflict::type& val) {
  std::map<int, const char*>::const_iterator it = _DropConflict_VALUES_TO_NAMES.find(val);
  if (it != _DropConflict_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kElementTypeValues[] = {
  ElementType::ElementBit,
  ElementType::ElementUInt8,
  ElementType::ElementInt8,
  ElementType::ElementInt16,
  ElementType::ElementInt32,
  ElementType::ElementInt64,
  ElementType::ElementFloat32,
  ElementType::ElementFloat64,
  ElementType::ElementFloat16,
  ElementType::ElementBFloat16
};
const char* _kElementTypeNames[] = {
  "ElementBit",
  "ElementUInt8",
  "ElementInt8",
  "ElementInt16",
  "ElementInt32",
  "ElementInt64",
  "ElementFloat32",
  "ElementFloat64",
  "ElementFloat16",
  "ElementBFloat16"
};
const std::map<int, const char*> _ElementType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kElementTypeValues, _kElementTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ElementType::type& val) {
  std::map<int, const char*>::const_iterator it = _ElementType_VALUES_TO_NAMES.find(val);
  if (it != _ElementType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ElementType::type& val) {
  std::map<int, const char*>::const_iterator it = _ElementType_VALUES_TO_NAMES.find(val);
  if (it != _ElementType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kConstraintValues[] = {
  Constraint::PrimaryKey,
  Constraint::NotNull,
  Constraint::Null,
  Constraint::Unique
};
const char* _kConstraintNames[] = {
  "PrimaryKey",
  "NotNull",
  "Null",
  "Unique"
};
const std::map<int, const char*> _Constraint_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kConstraintValues, _kConstraintNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Constraint::type& val) {
  std::map<int, const char*>::const_iterator it = _Constraint_VALUES_TO_NAMES.find(val);
  if (it != _Constraint_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Constraint::type& val) {
  std::map<int, const char*>::const_iterator it = _Constraint_VALUES_TO_NAMES.find(val);
  if (it != _Constraint_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLiteralTypeValues[] = {
  LiteralType::Boolean,
  LiteralType::Double,
  LiteralType::String,
  LiteralType::Int64,
  LiteralType::Null,
  LiteralType::IntegerArray,
  LiteralType::DoubleArray,
  LiteralType::IntegerTensor,
  LiteralType::DoubleTensor,
  LiteralType::IntegerTensorArray,
  LiteralType::DoubleTensorArray,
  LiteralType::SparseIntegerArray,
  LiteralType::SparseDoubleArray,
  LiteralType::Date,
  LiteralType::Time,
  LiteralType::Inteval,
  LiteralType::DateTime,
  LiteralType::Timestamp,
  LiteralType::CurlyBracketsArray
};
const char* _kLiteralTypeNames[] = {
  "Boolean",
  "Double",
  "String",
  "Int64",
  "Null",
  "IntegerArray",
  "DoubleArray",
  "IntegerTensor",
  "DoubleTensor",
  "IntegerTensorArray",
  "DoubleTensorArray",
  "SparseIntegerArray",
  "SparseDoubleArray",
  "Date",
  "Time",
  "Inteval",
  "DateTime",
  "Timestamp",
  "CurlyBracketsArray"
};
const std::map<int, const char*> _LiteralType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(19, _kLiteralTypeValues, _kLiteralTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LiteralType::type& val) {
  std::map<int, const char*>::const_iterator it = _LiteralType_VALUES_TO_NAMES.find(val);
  if (it != _LiteralType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LiteralType::type& val) {
  std::map<int, const char*>::const_iterator it = _LiteralType_VALUES_TO_NAMES.find(val);
  if (it != _LiteralType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kKnnDistanceTypeValues[] = {
  KnnDistanceType::L2,
  KnnDistanceType::Cosine,
  KnnDistanceType::InnerProduct,
  KnnDistanceType::Hamming
};
const char* _kKnnDistanceTypeNames[] = {
  "L2",
  "Cosine",
  "InnerProduct",
  "Hamming"
};
const std::map<int, const char*> _KnnDistanceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kKnnDistanceTypeValues, _kKnnDistanceTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const KnnDistanceType::type& val) {
  std::map<int, const char*>::const_iterator it = _KnnDistanceType_VALUES_TO_NAMES.find(val);
  if (it != _KnnDistanceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const KnnDistanceType::type& val) {
  std::map<int, const char*>::const_iterator it = _KnnDistanceType_VALUES_TO_NAMES.find(val);
  if (it != _KnnDistanceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCopyFileTypeValues[] = {
  CopyFileType::CSV,
  CopyFileType::JSON,
  CopyFileType::JSONL,
  CopyFileType::FVECS,
  CopyFileType::CSR,
  CopyFileType::BVECS
};
const char* _kCopyFileTypeNames[] = {
  "CSV",
  "JSON",
  "JSONL",
  "FVECS",
  "CSR",
  "BVECS"
};
const std::map<int, const char*> _CopyFileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kCopyFileTypeValues, _kCopyFileTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CopyFileType::type& val) {
  std::map<int, const char*>::const_iterator it = _CopyFileType_VALUES_TO_NAMES.find(val);
  if (it != _CopyFileType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CopyFileType::type& val) {
  std::map<int, const char*>::const_iterator it = _CopyFileType_VALUES_TO_NAMES.find(val);
  if (it != _CopyFileType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kColumnTypeValues[] = {
  ColumnType::ColumnBool,
  ColumnType::ColumnInt8,
  ColumnType::ColumnInt16,
  ColumnType::ColumnInt32,
  ColumnType::ColumnInt64,
  ColumnType::ColumnFloat32,
  ColumnType::ColumnFloat64,
  ColumnType::ColumnFloat16,
  ColumnType::ColumnBFloat16,
  ColumnType::ColumnVarchar,
  ColumnType::ColumnEmbedding,
  ColumnType::ColumnTensor,
  ColumnType::ColumnTensorArray,
  ColumnType::ColumnSparse,
  ColumnType::ColumnMultiVector,
  ColumnType::ColumnRowID,
  ColumnType::ColumnDate,
  ColumnType::ColumnTime,
  ColumnType::ColumnDateTime,
  ColumnType::ColumnTimestamp,
  ColumnType::ColumnInterval,
  ColumnType::ColumnArray,
  ColumnType::ColumnInvalid
};
const char* _kColumnTypeNames[] = {
  "ColumnBool",
  "ColumnInt8",
  "ColumnInt16",
  "ColumnInt32",
  "ColumnInt64",
  "ColumnFloat32",
  "ColumnFloat64",
  "ColumnFloat16",
  "ColumnBFloat16",
  "ColumnVarchar",
  "ColumnEmbedding",
  "ColumnTensor",
  "ColumnTensorArray",
  "ColumnSparse",
  "ColumnMultiVector",
  "ColumnRowID",
  "ColumnDate",
  "ColumnTime",
  "ColumnDateTime",
  "ColumnTimestamp",
  "ColumnInterval",
  "ColumnArray",
  "ColumnInvalid"
};
const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(23, _kColumnTypeValues, _kColumnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kIndexTypeValues[] = {
  IndexType::IVF,
  IndexType::Hnsw,
  IndexType::FullText,
  IndexType::BMP,
  IndexType::Secondary,
  IndexType::EMVB,
  IndexType::DiskAnn
};
const char* _kIndexTypeNames[] = {
  "IVF",
  "Hnsw",
  "FullText",
  "BMP",
  "Secondary",
  "EMVB",
  "DiskAnn"
};
const std::map<int, const char*> _IndexType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kIndexTypeValues, _kIndexTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const IndexType::type& val) {
  std::map<int, const char*>::const_iterator it = _IndexType_VALUES_TO_NAMES.find(val);
  if (it != _IndexType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const IndexType::type& val) {
  std::map<int, const char*>::const_iterator it = _IndexType_VALUES_TO_NAMES.find(val);
  if (it != _IndexType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kExplainTypeValues[] = {
  ExplainType::Analyze,
  ExplainType::Ast,
  ExplainType::UnOpt,
  ExplainType::Opt,
  ExplainType::Physical,
  ExplainType::Pipeline,
  ExplainType::Fragment
};
const char* _kExplainTypeNames[] = {
  "Analyze",
  "Ast",
  "UnOpt",
  "Opt",
  "Physical",
  "Pipeline",
  "Fragment"
};
const std::map<int, const char*> _ExplainType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kExplainTypeValues, _kExplainTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ExplainType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExplainType_VALUES_TO_NAMES.find(val);
  if (it != _ExplainType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ExplainType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExplainType_VALUES_TO_NAMES.find(val);
  if (it != _ExplainType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Property::~Property() noexcept {
}


void Property::__set_key(const std::string& val) {
  this->key = val;
}

void Property::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const Property& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Property::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Property::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Property");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Property &a, Property &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

Property::Property(const Property& other0) {
  key = other0.key;
  value = other0.value;
  __isset = other0.__isset;
}
Property& Property::operator=(const Property& other1) {
  key = other1.key;
  value = other1.value;
  __isset = other1.__isset;
  return *this;
}
void Property::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Property(";
  out << "key=" << to_string(key);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


CreateOption::~CreateOption() noexcept {
}


void CreateOption::__set_conflict_type(const CreateConflict::type val) {
  this->conflict_type = val;
}

void CreateOption::__set_properties(const std::vector<Property> & val) {
  this->properties = val;
}
std::ostream& operator<<(std::ostream& out, const CreateOption& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->conflict_type = static_cast<CreateConflict::type>(ecast2);
          this->__isset.conflict_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->properties.clear();
            uint32_t _size3;
            ::apache::thrift::protocol::TType _etype6;
            xfer += iprot->readListBegin(_etype6, _size3);
            this->properties.resize(_size3);
            uint32_t _i7;
            for (_i7 = 0; _i7 < _size3; ++_i7)
            {
              xfer += this->properties[_i7].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateOption");

  xfer += oprot->writeFieldBegin("conflict_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->conflict_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->properties.size()));
    std::vector<Property> ::const_iterator _iter8;
    for (_iter8 = this->properties.begin(); _iter8 != this->properties.end(); ++_iter8)
    {
      xfer += (*_iter8).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateOption &a, CreateOption &b) {
  using ::std::swap;
  swap(a.conflict_type, b.conflict_type);
  swap(a.properties, b.properties);
  swap(a.__isset, b.__isset);
}

CreateOption::CreateOption(const CreateOption& other9) {
  conflict_type = other9.conflict_type;
  properties = other9.properties;
  __isset = other9.__isset;
}
CreateOption& CreateOption::operator=(const CreateOption& other10) {
  conflict_type = other10.conflict_type;
  properties = other10.properties;
  __isset = other10.__isset;
  return *this;
}
void CreateOption::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateOption(";
  out << "conflict_type=" << to_string(conflict_type);
  out << ", " << "properties=" << to_string(properties);
  out << ")";
}


DropOption::~DropOption() noexcept {
}


void DropOption::__set_conflict_type(const DropConflict::type val) {
  this->conflict_type = val;
}
std::ostream& operator<<(std::ostream& out, const DropOption& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->conflict_type = static_cast<DropConflict::type>(ecast11);
          this->__isset.conflict_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropOption");

  xfer += oprot->writeFieldBegin("conflict_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->conflict_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropOption &a, DropOption &b) {
  using ::std::swap;
  swap(a.conflict_type, b.conflict_type);
  swap(a.__isset, b.__isset);
}

DropOption::DropOption(const DropOption& other12) noexcept {
  conflict_type = other12.conflict_type;
  __isset = other12.__isset;
}
DropOption& DropOption::operator=(const DropOption& other13) noexcept {
  conflict_type = other13.conflict_type;
  __isset = other13.__isset;
  return *this;
}
void DropOption::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropOption(";
  out << "conflict_type=" << to_string(conflict_type);
  out << ")";
}


NumberType::~NumberType() noexcept {
}

std::ostream& operator<<(std::ostream& out, const NumberType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NumberType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NumberType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NumberType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NumberType &a, NumberType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

NumberType::NumberType(const NumberType& other14) noexcept {
  (void) other14;
}
NumberType& NumberType::operator=(const NumberType& other15) noexcept {
  (void) other15;
  return *this;
}
void NumberType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NumberType(";
  out << ")";
}


VarcharType::~VarcharType() noexcept {
}

std::ostream& operator<<(std::ostream& out, const VarcharType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VarcharType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VarcharType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VarcharType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VarcharType &a, VarcharType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

VarcharType::VarcharType(const VarcharType& other16) noexcept {
  (void) other16;
}
VarcharType& VarcharType::operator=(const VarcharType& other17) noexcept {
  (void) other17;
  return *this;
}
void VarcharType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VarcharType(";
  out << ")";
}


EmbeddingType::~EmbeddingType() noexcept {
}


void EmbeddingType::__set_dimension(const int32_t val) {
  this->dimension = val;
}

void EmbeddingType::__set_element_type(const ElementType::type val) {
  this->element_type = val;
}
std::ostream& operator<<(std::ostream& out, const EmbeddingType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EmbeddingType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dimension);
          this->__isset.dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast18;
          xfer += iprot->readI32(ecast18);
          this->element_type = static_cast<ElementType::type>(ecast18);
          this->__isset.element_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EmbeddingType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EmbeddingType");

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dimension);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("element_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->element_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EmbeddingType &a, EmbeddingType &b) {
  using ::std::swap;
  swap(a.dimension, b.dimension);
  swap(a.element_type, b.element_type);
  swap(a.__isset, b.__isset);
}

EmbeddingType::EmbeddingType(const EmbeddingType& other19) noexcept {
  dimension = other19.dimension;
  element_type = other19.element_type;
  __isset = other19.__isset;
}
EmbeddingType& EmbeddingType::operator=(const EmbeddingType& other20) noexcept {
  dimension = other20.dimension;
  element_type = other20.element_type;
  __isset = other20.__isset;
  return *this;
}
void EmbeddingType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EmbeddingType(";
  out << "dimension=" << to_string(dimension);
  out << ", " << "element_type=" << to_string(element_type);
  out << ")";
}


SparseType::~SparseType() noexcept {
}


void SparseType::__set_dimension(const int64_t val) {
  this->dimension = val;
}

void SparseType::__set_element_type(const ElementType::type val) {
  this->element_type = val;
}

void SparseType::__set_index_type(const ElementType::type val) {
  this->index_type = val;
}
std::ostream& operator<<(std::ostream& out, const SparseType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SparseType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->dimension);
          this->__isset.dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->element_type = static_cast<ElementType::type>(ecast21);
          this->__isset.element_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->index_type = static_cast<ElementType::type>(ecast22);
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SparseType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SparseType");

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->dimension);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("element_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->element_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->index_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SparseType &a, SparseType &b) {
  using ::std::swap;
  swap(a.dimension, b.dimension);
  swap(a.element_type, b.element_type);
  swap(a.index_type, b.index_type);
  swap(a.__isset, b.__isset);
}

SparseType::SparseType(const SparseType& other23) noexcept {
  dimension = other23.dimension;
  element_type = other23.element_type;
  index_type = other23.index_type;
  __isset = other23.__isset;
}
SparseType& SparseType::operator=(const SparseType& other24) noexcept {
  dimension = other24.dimension;
  element_type = other24.element_type;
  index_type = other24.index_type;
  __isset = other24.__isset;
  return *this;
}
void SparseType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SparseType(";
  out << "dimension=" << to_string(dimension);
  out << ", " << "element_type=" << to_string(element_type);
  out << ", " << "index_type=" << to_string(index_type);
  out << ")";
}


ArrayType::~ArrayType() noexcept {
}


void ArrayType::__set_element_data_type(::std::shared_ptr<DataType> val) {
  this->element_data_type = val;
}
std::ostream& operator<<(std::ostream& out, const ArrayType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ArrayType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->element_data_type) { 
            this->element_data_type = ::std::shared_ptr<DataType>(new DataType);
          }
          xfer += this->element_data_type->read(iprot);
          bool wasSet = false;
          if (this->element_data_type->__isset.logic_type) { wasSet = true; }
          if (this->element_data_type->__isset.physical_type) { wasSet = true; }
          if (!wasSet) { this->element_data_type.reset(); }
          this->__isset.element_data_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ArrayType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ArrayType");

  xfer += oprot->writeFieldBegin("element_data_type", ::apache::thrift::protocol::T_STRUCT, 1);
  if (this->element_data_type) {
    xfer += this->element_data_type->write(oprot); 
  } else {oprot->writeStructBegin("DataType"); 
    oprot->writeStructEnd();
    oprot->writeFieldStop();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ArrayType &a, ArrayType &b) {
  using ::std::swap;
  swap(a.element_data_type, b.element_data_type);
  swap(a.__isset, b.__isset);
}

ArrayType::ArrayType(const ArrayType& other25) noexcept {
  element_data_type = other25.element_data_type;
  __isset = other25.__isset;
}
ArrayType& ArrayType::operator=(const ArrayType& other26) noexcept {
  element_data_type = other26.element_data_type;
  __isset = other26.__isset;
  return *this;
}
void ArrayType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ArrayType(";
  out << "element_data_type=" << to_string(element_data_type);
  out << ")";
}


PhysicalType::~PhysicalType() noexcept {
}


void PhysicalType::__set_number_type(const NumberType& val) {
  this->number_type = val;
__isset.number_type = true;
}

void PhysicalType::__set_varchar_type(const VarcharType& val) {
  this->varchar_type = val;
__isset.varchar_type = true;
}

void PhysicalType::__set_embedding_type(const EmbeddingType& val) {
  this->embedding_type = val;
__isset.embedding_type = true;
}

void PhysicalType::__set_sparse_type(const SparseType& val) {
  this->sparse_type = val;
__isset.sparse_type = true;
}

void PhysicalType::__set_array_type(const ArrayType& val) {
  this->array_type = val;
__isset.array_type = true;
}
std::ostream& operator<<(std::ostream& out, const PhysicalType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PhysicalType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->number_type.read(iprot);
          this->__isset.number_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->varchar_type.read(iprot);
          this->__isset.varchar_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->embedding_type.read(iprot);
          this->__isset.embedding_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->sparse_type.read(iprot);
          this->__isset.sparse_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->array_type.read(iprot);
          this->__isset.array_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PhysicalType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PhysicalType");

  if (this->__isset.number_type) {
    xfer += oprot->writeFieldBegin("number_type", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->number_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.varchar_type) {
    xfer += oprot->writeFieldBegin("varchar_type", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->varchar_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.embedding_type) {
    xfer += oprot->writeFieldBegin("embedding_type", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->embedding_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sparse_type) {
    xfer += oprot->writeFieldBegin("sparse_type", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->sparse_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.array_type) {
    xfer += oprot->writeFieldBegin("array_type", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->array_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PhysicalType &a, PhysicalType &b) {
  using ::std::swap;
  swap(a.number_type, b.number_type);
  swap(a.varchar_type, b.varchar_type);
  swap(a.embedding_type, b.embedding_type);
  swap(a.sparse_type, b.sparse_type);
  swap(a.array_type, b.array_type);
  swap(a.__isset, b.__isset);
}

PhysicalType::PhysicalType(const PhysicalType& other27) noexcept {
  number_type = other27.number_type;
  varchar_type = other27.varchar_type;
  embedding_type = other27.embedding_type;
  sparse_type = other27.sparse_type;
  array_type = other27.array_type;
  __isset = other27.__isset;
}
PhysicalType& PhysicalType::operator=(const PhysicalType& other28) noexcept {
  number_type = other28.number_type;
  varchar_type = other28.varchar_type;
  embedding_type = other28.embedding_type;
  sparse_type = other28.sparse_type;
  array_type = other28.array_type;
  __isset = other28.__isset;
  return *this;
}
void PhysicalType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PhysicalType(";
  out << "number_type="; (__isset.number_type ? (out << to_string(number_type)) : (out << "<null>"));
  out << ", " << "varchar_type="; (__isset.varchar_type ? (out << to_string(varchar_type)) : (out << "<null>"));
  out << ", " << "embedding_type="; (__isset.embedding_type ? (out << to_string(embedding_type)) : (out << "<null>"));
  out << ", " << "sparse_type="; (__isset.sparse_type ? (out << to_string(sparse_type)) : (out << "<null>"));
  out << ", " << "array_type="; (__isset.array_type ? (out << to_string(array_type)) : (out << "<null>"));
  out << ")";
}


DataType::~DataType() noexcept {
}


void DataType::__set_logic_type(const LogicType::type val) {
  this->logic_type = val;
}

void DataType::__set_physical_type(const PhysicalType& val) {
  this->physical_type = val;
}
std::ostream& operator<<(std::ostream& out, const DataType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DataType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast29;
          xfer += iprot->readI32(ecast29);
          this->logic_type = static_cast<LogicType::type>(ecast29);
          this->__isset.logic_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->physical_type.read(iprot);
          this->__isset.physical_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataType");

  xfer += oprot->writeFieldBegin("logic_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->logic_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("physical_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->physical_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataType &a, DataType &b) {
  using ::std::swap;
  swap(a.logic_type, b.logic_type);
  swap(a.physical_type, b.physical_type);
  swap(a.__isset, b.__isset);
}

DataType::DataType(const DataType& other30) noexcept {
  logic_type = other30.logic_type;
  physical_type = other30.physical_type;
  __isset = other30.__isset;
}
DataType& DataType::operator=(const DataType& other31) noexcept {
  logic_type = other31.logic_type;
  physical_type = other31.physical_type;
  __isset = other31.__isset;
  return *this;
}
void DataType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataType(";
  out << "logic_type=" << to_string(logic_type);
  out << ", " << "physical_type=" << to_string(physical_type);
  out << ")";
}


ParsedExprType::~ParsedExprType() noexcept {
}


void ParsedExprType::__set_constant_expr(::std::shared_ptr<ConstantExpr> val) {
  this->constant_expr = val;
__isset.constant_expr = true;
}

void ParsedExprType::__set_column_expr(::std::shared_ptr<ColumnExpr> val) {
  this->column_expr = val;
__isset.column_expr = true;
}

void ParsedExprType::__set_function_expr(::std::shared_ptr<FunctionExpr> val) {
  this->function_expr = val;
__isset.function_expr = true;
}

void ParsedExprType::__set_between_expr(::std::shared_ptr<BetweenExpr> val) {
  this->between_expr = val;
__isset.between_expr = true;
}

void ParsedExprType::__set_knn_expr(::std::shared_ptr<KnnExpr> val) {
  this->knn_expr = val;
__isset.knn_expr = true;
}

void ParsedExprType::__set_match_sparse_expr(::std::shared_ptr<MatchSparseExpr> val) {
  this->match_sparse_expr = val;
__isset.match_sparse_expr = true;
}

void ParsedExprType::__set_match_tensor_expr(::std::shared_ptr<MatchTensorExpr> val) {
  this->match_tensor_expr = val;
__isset.match_tensor_expr = true;
}

void ParsedExprType::__set_match_expr(::std::shared_ptr<MatchExpr> val) {
  this->match_expr = val;
__isset.match_expr = true;
}

void ParsedExprType::__set_fusion_expr(::std::shared_ptr<FusionExpr> val) {
  this->fusion_expr = val;
__isset.fusion_expr = true;
}

void ParsedExprType::__set_search_expr(::std::shared_ptr<SearchExpr> val) {
  this->search_expr = val;
__isset.search_expr = true;
}

void ParsedExprType::__set_in_expr(::std::shared_ptr<InExpr> val) {
  this->in_expr = val;
__isset.in_expr = true;
}
std::ostream& operator<<(std::ostream& out, const ParsedExprType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ParsedExprType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->constant_expr) { 
            this->constant_expr = ::std::shared_ptr<ConstantExpr>(new ConstantExpr);
          }
          xfer += this->constant_expr->read(iprot);
          bool wasSet = false;
          if (this->constant_expr->__isset.literal_type) { wasSet = true; }
          if (this->constant_expr->__isset.bool_value) { wasSet = true; }
          if (this->constant_expr->__isset.i64_value) { wasSet = true; }
          if (this->constant_expr->__isset.f64_value) { wasSet = true; }
          if (this->constant_expr->__isset.str_value) { wasSet = true; }
          if (this->constant_expr->__isset.i64_array_value) { wasSet = true; }
          if (this->constant_expr->__isset.f64_array_value) { wasSet = true; }
          if (this->constant_expr->__isset.i64_tensor_value) { wasSet = true; }
          if (this->constant_expr->__isset.f64_tensor_value) { wasSet = true; }
          if (this->constant_expr->__isset.i64_tensor_array_value) { wasSet = true; }
          if (this->constant_expr->__isset.f64_tensor_array_value) { wasSet = true; }
          if (this->constant_expr->__isset.i64_array_idx) { wasSet = true; }
          if (this->constant_expr->__isset.curly_brackets_array) { wasSet = true; }
          if (!wasSet) { this->constant_expr.reset(); }
          this->__isset.constant_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->column_expr) { 
            this->column_expr = ::std::shared_ptr<ColumnExpr>(new ColumnExpr);
          }
          xfer += this->column_expr->read(iprot);
          bool wasSet = false;
          if (this->column_expr->__isset.column_name) { wasSet = true; }
          if (this->column_expr->__isset.star) { wasSet = true; }
          if (!wasSet) { this->column_expr.reset(); }
          this->__isset.column_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->function_expr) { 
            this->function_expr = ::std::shared_ptr<FunctionExpr>(new FunctionExpr);
          }
          xfer += this->function_expr->read(iprot);
          bool wasSet = false;
          if (this->function_expr->__isset.function_name) { wasSet = true; }
          if (this->function_expr->__isset.arguments) { wasSet = true; }
          if (!wasSet) { this->function_expr.reset(); }
          this->__isset.function_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->between_expr) { 
            this->between_expr = ::std::shared_ptr<BetweenExpr>(new BetweenExpr);
          }
          xfer += this->between_expr->read(iprot);
          bool wasSet = false;
          if (this->between_expr->__isset.value) { wasSet = true; }
          if (this->between_expr->__isset.upper_bound) { wasSet = true; }
          if (this->between_expr->__isset.lower_bound) { wasSet = true; }
          if (!wasSet) { this->between_expr.reset(); }
          this->__isset.between_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->knn_expr) { 
            this->knn_expr = ::std::shared_ptr<KnnExpr>(new KnnExpr);
          }
          xfer += this->knn_expr->read(iprot);
          bool wasSet = false;
          if (this->knn_expr->__isset.column_expr) { wasSet = true; }
          if (this->knn_expr->__isset.embedding_data) { wasSet = true; }
          if (this->knn_expr->__isset.embedding_data_type) { wasSet = true; }
          if (this->knn_expr->__isset.distance_type) { wasSet = true; }
          if (this->knn_expr->__isset.topn) { wasSet = true; }
          if (this->knn_expr->__isset.opt_params) { wasSet = true; }
          if (this->knn_expr->__isset.filter_expr) { wasSet = true; }
          if (this->knn_expr->__isset.query_embedding_expr) { wasSet = true; }
          if (!wasSet) { this->knn_expr.reset(); }
          this->__isset.knn_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->match_sparse_expr) { 
            this->match_sparse_expr = ::std::shared_ptr<MatchSparseExpr>(new MatchSparseExpr);
          }
          xfer += this->match_sparse_expr->read(iprot);
          bool wasSet = false;
          if (this->match_sparse_expr->__isset.column_expr) { wasSet = true; }
          if (this->match_sparse_expr->__isset.query_sparse_expr) { wasSet = true; }
          if (this->match_sparse_expr->__isset.metric_type) { wasSet = true; }
          if (this->match_sparse_expr->__isset.topn) { wasSet = true; }
          if (this->match_sparse_expr->__isset.opt_params) { wasSet = true; }
          if (this->match_sparse_expr->__isset.filter_expr) { wasSet = true; }
          if (!wasSet) { this->match_sparse_expr.reset(); }
          this->__isset.match_sparse_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->match_tensor_expr) { 
            this->match_tensor_expr = ::std::shared_ptr<MatchTensorExpr>(new MatchTensorExpr);
          }
          xfer += this->match_tensor_expr->read(iprot);
          bool wasSet = false;
          if (this->match_tensor_expr->__isset.search_method) { wasSet = true; }
          if (this->match_tensor_expr->__isset.column_expr) { wasSet = true; }
          if (this->match_tensor_expr->__isset.embedding_data_type) { wasSet = true; }
          if (this->match_tensor_expr->__isset.embedding_data) { wasSet = true; }
          if (this->match_tensor_expr->__isset.extra_options) { wasSet = true; }
          if (this->match_tensor_expr->__isset.filter_expr) { wasSet = true; }
          if (!wasSet) { this->match_tensor_expr.reset(); }
          this->__isset.match_tensor_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->match_expr) { 
            this->match_expr = ::std::shared_ptr<MatchExpr>(new MatchExpr);
          }
          xfer += this->match_expr->read(iprot);
          bool wasSet = false;
          if (this->match_expr->__isset.fields) { wasSet = true; }
          if (this->match_expr->__isset.matching_text) { wasSet = true; }
          if (this->match_expr->__isset.options_text) { wasSet = true; }
          if (this->match_expr->__isset.filter_expr) { wasSet = true; }
          if (!wasSet) { this->match_expr.reset(); }
          this->__isset.match_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->fusion_expr) { 
            this->fusion_expr = ::std::shared_ptr<FusionExpr>(new FusionExpr);
          }
          xfer += this->fusion_expr->read(iprot);
          bool wasSet = false;
          if (this->fusion_expr->__isset.method) { wasSet = true; }
          if (this->fusion_expr->__isset.options_text) { wasSet = true; }
          if (this->fusion_expr->__isset.optional_match_tensor_expr) { wasSet = true; }
          if (!wasSet) { this->fusion_expr.reset(); }
          this->__isset.fusion_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->search_expr) { 
            this->search_expr = ::std::shared_ptr<SearchExpr>(new SearchExpr);
          }
          xfer += this->search_expr->read(iprot);
          bool wasSet = false;
          if (this->search_expr->__isset.match_exprs) { wasSet = true; }
          if (this->search_expr->__isset.fusion_exprs) { wasSet = true; }
          if (!wasSet) { this->search_expr.reset(); }
          this->__isset.search_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->in_expr) { 
            this->in_expr = ::std::shared_ptr<InExpr>(new InExpr);
          }
          xfer += this->in_expr->read(iprot);
          bool wasSet = false;
          if (this->in_expr->__isset.left_operand) { wasSet = true; }
          if (this->in_expr->__isset.arguments) { wasSet = true; }
          if (this->in_expr->__isset.in_type) { wasSet = true; }
          if (!wasSet) { this->in_expr.reset(); }
          this->__isset.in_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ParsedExprType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParsedExprType");

  if (this->__isset.constant_expr) {
    xfer += oprot->writeFieldBegin("constant_expr", ::apache::thrift::protocol::T_STRUCT, 1);
    if (this->constant_expr) {
      xfer += this->constant_expr->write(oprot); 
    } else {oprot->writeStructBegin("ConstantExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_expr) {
    xfer += oprot->writeFieldBegin("column_expr", ::apache::thrift::protocol::T_STRUCT, 2);
    if (this->column_expr) {
      xfer += this->column_expr->write(oprot); 
    } else {oprot->writeStructBegin("ColumnExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.function_expr) {
    xfer += oprot->writeFieldBegin("function_expr", ::apache::thrift::protocol::T_STRUCT, 3);
    if (this->function_expr) {
      xfer += this->function_expr->write(oprot); 
    } else {oprot->writeStructBegin("FunctionExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.between_expr) {
    xfer += oprot->writeFieldBegin("between_expr", ::apache::thrift::protocol::T_STRUCT, 4);
    if (this->between_expr) {
      xfer += this->between_expr->write(oprot); 
    } else {oprot->writeStructBegin("BetweenExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.knn_expr) {
    xfer += oprot->writeFieldBegin("knn_expr", ::apache::thrift::protocol::T_STRUCT, 5);
    if (this->knn_expr) {
      xfer += this->knn_expr->write(oprot); 
    } else {oprot->writeStructBegin("KnnExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.match_sparse_expr) {
    xfer += oprot->writeFieldBegin("match_sparse_expr", ::apache::thrift::protocol::T_STRUCT, 6);
    if (this->match_sparse_expr) {
      xfer += this->match_sparse_expr->write(oprot); 
    } else {oprot->writeStructBegin("MatchSparseExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.match_tensor_expr) {
    xfer += oprot->writeFieldBegin("match_tensor_expr", ::apache::thrift::protocol::T_STRUCT, 7);
    if (this->match_tensor_expr) {
      xfer += this->match_tensor_expr->write(oprot); 
    } else {oprot->writeStructBegin("MatchTensorExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.match_expr) {
    xfer += oprot->writeFieldBegin("match_expr", ::apache::thrift::protocol::T_STRUCT, 8);
    if (this->match_expr) {
      xfer += this->match_expr->write(oprot); 
    } else {oprot->writeStructBegin("MatchExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fusion_expr) {
    xfer += oprot->writeFieldBegin("fusion_expr", ::apache::thrift::protocol::T_STRUCT, 9);
    if (this->fusion_expr) {
      xfer += this->fusion_expr->write(oprot); 
    } else {oprot->writeStructBegin("FusionExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.search_expr) {
    xfer += oprot->writeFieldBegin("search_expr", ::apache::thrift::protocol::T_STRUCT, 10);
    if (this->search_expr) {
      xfer += this->search_expr->write(oprot); 
    } else {oprot->writeStructBegin("SearchExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.in_expr) {
    xfer += oprot->writeFieldBegin("in_expr", ::apache::thrift::protocol::T_STRUCT, 11);
    if (this->in_expr) {
      xfer += this->in_expr->write(oprot); 
    } else {oprot->writeStructBegin("InExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParsedExprType &a, ParsedExprType &b) {
  using ::std::swap;
  swap(a.constant_expr, b.constant_expr);
  swap(a.column_expr, b.column_expr);
  swap(a.function_expr, b.function_expr);
  swap(a.between_expr, b.between_expr);
  swap(a.knn_expr, b.knn_expr);
  swap(a.match_sparse_expr, b.match_sparse_expr);
  swap(a.match_tensor_expr, b.match_tensor_expr);
  swap(a.match_expr, b.match_expr);
  swap(a.fusion_expr, b.fusion_expr);
  swap(a.search_expr, b.search_expr);
  swap(a.in_expr, b.in_expr);
  swap(a.__isset, b.__isset);
}

ParsedExprType::ParsedExprType(const ParsedExprType& other32) {
  constant_expr = other32.constant_expr;
  column_expr = other32.column_expr;
  function_expr = other32.function_expr;
  between_expr = other32.between_expr;
  knn_expr = other32.knn_expr;
  match_sparse_expr = other32.match_sparse_expr;
  match_tensor_expr = other32.match_tensor_expr;
  match_expr = other32.match_expr;
  fusion_expr = other32.fusion_expr;
  search_expr = other32.search_expr;
  in_expr = other32.in_expr;
  __isset = other32.__isset;
}
ParsedExprType& ParsedExprType::operator=(const ParsedExprType& other33) {
  constant_expr = other33.constant_expr;
  column_expr = other33.column_expr;
  function_expr = other33.function_expr;
  between_expr = other33.between_expr;
  knn_expr = other33.knn_expr;
  match_sparse_expr = other33.match_sparse_expr;
  match_tensor_expr = other33.match_tensor_expr;
  match_expr = other33.match_expr;
  fusion_expr = other33.fusion_expr;
  search_expr = other33.search_expr;
  in_expr = other33.in_expr;
  __isset = other33.__isset;
  return *this;
}
void ParsedExprType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParsedExprType(";
  out << "constant_expr="; (__isset.constant_expr ? (out << to_string(constant_expr)) : (out << "<null>"));
  out << ", " << "column_expr="; (__isset.column_expr ? (out << to_string(column_expr)) : (out << "<null>"));
  out << ", " << "function_expr="; (__isset.function_expr ? (out << to_string(function_expr)) : (out << "<null>"));
  out << ", " << "between_expr="; (__isset.between_expr ? (out << to_string(between_expr)) : (out << "<null>"));
  out << ", " << "knn_expr="; (__isset.knn_expr ? (out << to_string(knn_expr)) : (out << "<null>"));
  out << ", " << "match_sparse_expr="; (__isset.match_sparse_expr ? (out << to_string(match_sparse_expr)) : (out << "<null>"));
  out << ", " << "match_tensor_expr="; (__isset.match_tensor_expr ? (out << to_string(match_tensor_expr)) : (out << "<null>"));
  out << ", " << "match_expr="; (__isset.match_expr ? (out << to_string(match_expr)) : (out << "<null>"));
  out << ", " << "fusion_expr="; (__isset.fusion_expr ? (out << to_string(fusion_expr)) : (out << "<null>"));
  out << ", " << "search_expr="; (__isset.search_expr ? (out << to_string(search_expr)) : (out << "<null>"));
  out << ", " << "in_expr="; (__isset.in_expr ? (out << to_string(in_expr)) : (out << "<null>"));
  out << ")";
}


ParsedExpr::~ParsedExpr() noexcept {
}


void ParsedExpr::__set_type(const ParsedExprType& val) {
  this->type = val;
}

void ParsedExpr::__set_alias_name(const std::string& val) {
  this->alias_name = val;
}
std::ostream& operator<<(std::ostream& out, const ParsedExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ParsedExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type.read(iprot);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alias_name);
          this->__isset.alias_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ParsedExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParsedExpr");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alias_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->alias_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParsedExpr &a, ParsedExpr &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.alias_name, b.alias_name);
  swap(a.__isset, b.__isset);
}

ParsedExpr::ParsedExpr(const ParsedExpr& other34) {
  type = other34.type;
  alias_name = other34.alias_name;
  __isset = other34.__isset;
}
ParsedExpr& ParsedExpr::operator=(const ParsedExpr& other35) {
  type = other35.type;
  alias_name = other35.alias_name;
  __isset = other35.__isset;
  return *this;
}
void ParsedExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParsedExpr(";
  out << "type=" << to_string(type);
  out << ", " << "alias_name=" << to_string(alias_name);
  out << ")";
}


ColumnExpr::~ColumnExpr() noexcept {
}


void ColumnExpr::__set_column_name(const std::vector<std::string> & val) {
  this->column_name = val;
}

void ColumnExpr::__set_star(const bool val) {
  this->star = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_name.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _etype39;
            xfer += iprot->readListBegin(_etype39, _size36);
            this->column_name.resize(_size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              xfer += iprot->readString(this->column_name[_i40]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->star);
          this->__isset.star = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnExpr");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_name.size()));
    std::vector<std::string> ::const_iterator _iter41;
    for (_iter41 = this->column_name.begin(); _iter41 != this->column_name.end(); ++_iter41)
    {
      xfer += oprot->writeString((*_iter41));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("star", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->star);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnExpr &a, ColumnExpr &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.star, b.star);
  swap(a.__isset, b.__isset);
}

ColumnExpr::ColumnExpr(const ColumnExpr& other42) {
  column_name = other42.column_name;
  star = other42.star;
  __isset = other42.__isset;
}
ColumnExpr& ColumnExpr::operator=(const ColumnExpr& other43) {
  column_name = other43.column_name;
  star = other43.star;
  __isset = other43.__isset;
  return *this;
}
void ColumnExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnExpr(";
  out << "column_name=" << to_string(column_name);
  out << ", " << "star=" << to_string(star);
  out << ")";
}


EmbeddingData::~EmbeddingData() noexcept {
}


void EmbeddingData::__set_bool_array_value(const std::vector<bool> & val) {
  this->bool_array_value = val;
__isset.bool_array_value = true;
}

void EmbeddingData::__set_u8_array_value(const std::vector<int16_t> & val) {
  this->u8_array_value = val;
__isset.u8_array_value = true;
}

void EmbeddingData::__set_i8_array_value(const std::vector<int16_t> & val) {
  this->i8_array_value = val;
__isset.i8_array_value = true;
}

void EmbeddingData::__set_i16_array_value(const std::vector<int16_t> & val) {
  this->i16_array_value = val;
__isset.i16_array_value = true;
}

void EmbeddingData::__set_i32_array_value(const std::vector<int32_t> & val) {
  this->i32_array_value = val;
__isset.i32_array_value = true;
}

void EmbeddingData::__set_i64_array_value(const std::vector<int64_t> & val) {
  this->i64_array_value = val;
__isset.i64_array_value = true;
}

void EmbeddingData::__set_f32_array_value(const std::vector<double> & val) {
  this->f32_array_value = val;
__isset.f32_array_value = true;
}

void EmbeddingData::__set_f64_array_value(const std::vector<double> & val) {
  this->f64_array_value = val;
__isset.f64_array_value = true;
}

void EmbeddingData::__set_f16_array_value(const std::vector<double> & val) {
  this->f16_array_value = val;
__isset.f16_array_value = true;
}

void EmbeddingData::__set_bf16_array_value(const std::vector<double> & val) {
  this->bf16_array_value = val;
__isset.bf16_array_value = true;
}
std::ostream& operator<<(std::ostream& out, const EmbeddingData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EmbeddingData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bool_array_value.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->bool_array_value.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += iprot->readBool(this->bool_array_value[_i48]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bool_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->u8_array_value.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _etype52;
            xfer += iprot->readListBegin(_etype52, _size49);
            this->u8_array_value.resize(_size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              xfer += iprot->readI16(this->u8_array_value[_i53]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.u8_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i8_array_value.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->i8_array_value.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += iprot->readI16(this->i8_array_value[_i58]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i8_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i16_array_value.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->i16_array_value.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += iprot->readI16(this->i16_array_value[_i63]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i16_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i32_array_value.clear();
            uint32_t _size64;
            ::apache::thrift::protocol::TType _etype67;
            xfer += iprot->readListBegin(_etype67, _size64);
            this->i32_array_value.resize(_size64);
            uint32_t _i68;
            for (_i68 = 0; _i68 < _size64; ++_i68)
            {
              xfer += iprot->readI32(this->i32_array_value[_i68]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i32_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_array_value.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->i64_array_value.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += iprot->readI64(this->i64_array_value[_i73]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f32_array_value.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _etype77;
            xfer += iprot->readListBegin(_etype77, _size74);
            this->f32_array_value.resize(_size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              xfer += iprot->readDouble(this->f32_array_value[_i78]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f32_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f64_array_value.clear();
            uint32_t _size79;
            ::apache::thrift::protocol::TType _etype82;
            xfer += iprot->readListBegin(_etype82, _size79);
            this->f64_array_value.resize(_size79);
            uint32_t _i83;
            for (_i83 = 0; _i83 < _size79; ++_i83)
            {
              xfer += iprot->readDouble(this->f64_array_value[_i83]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f64_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f16_array_value.clear();
            uint32_t _size84;
            ::apache::thrift::protocol::TType _etype87;
            xfer += iprot->readListBegin(_etype87, _size84);
            this->f16_array_value.resize(_size84);
            uint32_t _i88;
            for (_i88 = 0; _i88 < _size84; ++_i88)
            {
              xfer += iprot->readDouble(this->f16_array_value[_i88]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f16_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bf16_array_value.clear();
            uint32_t _size89;
            ::apache::thrift::protocol::TType _etype92;
            xfer += iprot->readListBegin(_etype92, _size89);
            this->bf16_array_value.resize(_size89);
            uint32_t _i93;
            for (_i93 = 0; _i93 < _size89; ++_i93)
            {
              xfer += iprot->readDouble(this->bf16_array_value[_i93]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bf16_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EmbeddingData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EmbeddingData");

  if (this->__isset.bool_array_value) {
    xfer += oprot->writeFieldBegin("bool_array_value", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->bool_array_value.size()));
      std::vector<bool> ::const_iterator _iter94;
      for (_iter94 = this->bool_array_value.begin(); _iter94 != this->bool_array_value.end(); ++_iter94)
      {
        xfer += oprot->writeBool((*_iter94));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.u8_array_value) {
    xfer += oprot->writeFieldBegin("u8_array_value", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->u8_array_value.size()));
      std::vector<int16_t> ::const_iterator _iter95;
      for (_iter95 = this->u8_array_value.begin(); _iter95 != this->u8_array_value.end(); ++_iter95)
      {
        xfer += oprot->writeI16((*_iter95));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i8_array_value) {
    xfer += oprot->writeFieldBegin("i8_array_value", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->i8_array_value.size()));
      std::vector<int16_t> ::const_iterator _iter96;
      for (_iter96 = this->i8_array_value.begin(); _iter96 != this->i8_array_value.end(); ++_iter96)
      {
        xfer += oprot->writeI16((*_iter96));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i16_array_value) {
    xfer += oprot->writeFieldBegin("i16_array_value", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->i16_array_value.size()));
      std::vector<int16_t> ::const_iterator _iter97;
      for (_iter97 = this->i16_array_value.begin(); _iter97 != this->i16_array_value.end(); ++_iter97)
      {
        xfer += oprot->writeI16((*_iter97));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32_array_value) {
    xfer += oprot->writeFieldBegin("i32_array_value", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_array_value.size()));
      std::vector<int32_t> ::const_iterator _iter98;
      for (_iter98 = this->i32_array_value.begin(); _iter98 != this->i32_array_value.end(); ++_iter98)
      {
        xfer += oprot->writeI32((*_iter98));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64_array_value) {
    xfer += oprot->writeFieldBegin("i64_array_value", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->i64_array_value.size()));
      std::vector<int64_t> ::const_iterator _iter99;
      for (_iter99 = this->i64_array_value.begin(); _iter99 != this->i64_array_value.end(); ++_iter99)
      {
        xfer += oprot->writeI64((*_iter99));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f32_array_value) {
    xfer += oprot->writeFieldBegin("f32_array_value", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->f32_array_value.size()));
      std::vector<double> ::const_iterator _iter100;
      for (_iter100 = this->f32_array_value.begin(); _iter100 != this->f32_array_value.end(); ++_iter100)
      {
        xfer += oprot->writeDouble((*_iter100));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f64_array_value) {
    xfer += oprot->writeFieldBegin("f64_array_value", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->f64_array_value.size()));
      std::vector<double> ::const_iterator _iter101;
      for (_iter101 = this->f64_array_value.begin(); _iter101 != this->f64_array_value.end(); ++_iter101)
      {
        xfer += oprot->writeDouble((*_iter101));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f16_array_value) {
    xfer += oprot->writeFieldBegin("f16_array_value", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->f16_array_value.size()));
      std::vector<double> ::const_iterator _iter102;
      for (_iter102 = this->f16_array_value.begin(); _iter102 != this->f16_array_value.end(); ++_iter102)
      {
        xfer += oprot->writeDouble((*_iter102));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.bf16_array_value) {
    xfer += oprot->writeFieldBegin("bf16_array_value", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->bf16_array_value.size()));
      std::vector<double> ::const_iterator _iter103;
      for (_iter103 = this->bf16_array_value.begin(); _iter103 != this->bf16_array_value.end(); ++_iter103)
      {
        xfer += oprot->writeDouble((*_iter103));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EmbeddingData &a, EmbeddingData &b) {
  using ::std::swap;
  swap(a.bool_array_value, b.bool_array_value);
  swap(a.u8_array_value, b.u8_array_value);
  swap(a.i8_array_value, b.i8_array_value);
  swap(a.i16_array_value, b.i16_array_value);
  swap(a.i32_array_value, b.i32_array_value);
  swap(a.i64_array_value, b.i64_array_value);
  swap(a.f32_array_value, b.f32_array_value);
  swap(a.f64_array_value, b.f64_array_value);
  swap(a.f16_array_value, b.f16_array_value);
  swap(a.bf16_array_value, b.bf16_array_value);
  swap(a.__isset, b.__isset);
}

EmbeddingData::EmbeddingData(const EmbeddingData& other104) {
  bool_array_value = other104.bool_array_value;
  u8_array_value = other104.u8_array_value;
  i8_array_value = other104.i8_array_value;
  i16_array_value = other104.i16_array_value;
  i32_array_value = other104.i32_array_value;
  i64_array_value = other104.i64_array_value;
  f32_array_value = other104.f32_array_value;
  f64_array_value = other104.f64_array_value;
  f16_array_value = other104.f16_array_value;
  bf16_array_value = other104.bf16_array_value;
  __isset = other104.__isset;
}
EmbeddingData& EmbeddingData::operator=(const EmbeddingData& other105) {
  bool_array_value = other105.bool_array_value;
  u8_array_value = other105.u8_array_value;
  i8_array_value = other105.i8_array_value;
  i16_array_value = other105.i16_array_value;
  i32_array_value = other105.i32_array_value;
  i64_array_value = other105.i64_array_value;
  f32_array_value = other105.f32_array_value;
  f64_array_value = other105.f64_array_value;
  f16_array_value = other105.f16_array_value;
  bf16_array_value = other105.bf16_array_value;
  __isset = other105.__isset;
  return *this;
}
void EmbeddingData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EmbeddingData(";
  out << "bool_array_value="; (__isset.bool_array_value ? (out << to_string(bool_array_value)) : (out << "<null>"));
  out << ", " << "u8_array_value="; (__isset.u8_array_value ? (out << to_string(u8_array_value)) : (out << "<null>"));
  out << ", " << "i8_array_value="; (__isset.i8_array_value ? (out << to_string(i8_array_value)) : (out << "<null>"));
  out << ", " << "i16_array_value="; (__isset.i16_array_value ? (out << to_string(i16_array_value)) : (out << "<null>"));
  out << ", " << "i32_array_value="; (__isset.i32_array_value ? (out << to_string(i32_array_value)) : (out << "<null>"));
  out << ", " << "i64_array_value="; (__isset.i64_array_value ? (out << to_string(i64_array_value)) : (out << "<null>"));
  out << ", " << "f32_array_value="; (__isset.f32_array_value ? (out << to_string(f32_array_value)) : (out << "<null>"));
  out << ", " << "f64_array_value="; (__isset.f64_array_value ? (out << to_string(f64_array_value)) : (out << "<null>"));
  out << ", " << "f16_array_value="; (__isset.f16_array_value ? (out << to_string(f16_array_value)) : (out << "<null>"));
  out << ", " << "bf16_array_value="; (__isset.bf16_array_value ? (out << to_string(bf16_array_value)) : (out << "<null>"));
  out << ")";
}


InitParameter::~InitParameter() noexcept {
}


void InitParameter::__set_param_name(const std::string& val) {
  this->param_name = val;
}

void InitParameter::__set_param_value(const std::string& val) {
  this->param_value = val;
}
std::ostream& operator<<(std::ostream& out, const InitParameter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitParameter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param_name);
          this->__isset.param_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param_value);
          this->__isset.param_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InitParameter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitParameter");

  xfer += oprot->writeFieldBegin("param_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->param_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param_value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->param_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitParameter &a, InitParameter &b) {
  using ::std::swap;
  swap(a.param_name, b.param_name);
  swap(a.param_value, b.param_value);
  swap(a.__isset, b.__isset);
}

InitParameter::InitParameter(const InitParameter& other106) {
  param_name = other106.param_name;
  param_value = other106.param_value;
  __isset = other106.__isset;
}
InitParameter& InitParameter::operator=(const InitParameter& other107) {
  param_name = other107.param_name;
  param_value = other107.param_value;
  __isset = other107.__isset;
  return *this;
}
void InitParameter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitParameter(";
  out << "param_name=" << to_string(param_name);
  out << ", " << "param_value=" << to_string(param_value);
  out << ")";
}


ConstantExpr::~ConstantExpr() noexcept {
}


void ConstantExpr::__set_literal_type(const LiteralType::type val) {
  this->literal_type = val;
}

void ConstantExpr::__set_bool_value(const bool val) {
  this->bool_value = val;
__isset.bool_value = true;
}

void ConstantExpr::__set_i64_value(const int64_t val) {
  this->i64_value = val;
__isset.i64_value = true;
}

void ConstantExpr::__set_f64_value(const double val) {
  this->f64_value = val;
__isset.f64_value = true;
}

void ConstantExpr::__set_str_value(const std::string& val) {
  this->str_value = val;
__isset.str_value = true;
}

void ConstantExpr::__set_i64_array_value(const std::vector<int64_t> & val) {
  this->i64_array_value = val;
__isset.i64_array_value = true;
}

void ConstantExpr::__set_f64_array_value(const std::vector<double> & val) {
  this->f64_array_value = val;
__isset.f64_array_value = true;
}

void ConstantExpr::__set_i64_tensor_value(const std::vector<std::vector<int64_t> > & val) {
  this->i64_tensor_value = val;
__isset.i64_tensor_value = true;
}

void ConstantExpr::__set_f64_tensor_value(const std::vector<std::vector<double> > & val) {
  this->f64_tensor_value = val;
__isset.f64_tensor_value = true;
}

void ConstantExpr::__set_i64_tensor_array_value(const std::vector<std::vector<std::vector<int64_t> > > & val) {
  this->i64_tensor_array_value = val;
__isset.i64_tensor_array_value = true;
}

void ConstantExpr::__set_f64_tensor_array_value(const std::vector<std::vector<std::vector<double> > > & val) {
  this->f64_tensor_array_value = val;
__isset.f64_tensor_array_value = true;
}

void ConstantExpr::__set_i64_array_idx(const std::vector<int64_t> & val) {
  this->i64_array_idx = val;
__isset.i64_array_idx = true;
}

void ConstantExpr::__set_curly_brackets_array(const std::vector<ConstantExpr> & val) {
  this->curly_brackets_array = val;
__isset.curly_brackets_array = true;
}
std::ostream& operator<<(std::ostream& out, const ConstantExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ConstantExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast108;
          xfer += iprot->readI32(ecast108);
          this->literal_type = static_cast<LiteralType::type>(ecast108);
          this->__isset.literal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bool_value);
          this->__isset.bool_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64_value);
          this->__isset.i64_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->f64_value);
          this->__isset.f64_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_value);
          this->__isset.str_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_array_value.clear();
            uint32_t _size109;
            ::apache::thrift::protocol::TType _etype112;
            xfer += iprot->readListBegin(_etype112, _size109);
            this->i64_array_value.resize(_size109);
            uint32_t _i113;
            for (_i113 = 0; _i113 < _size109; ++_i113)
            {
              xfer += iprot->readI64(this->i64_array_value[_i113]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f64_array_value.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _etype117;
            xfer += iprot->readListBegin(_etype117, _size114);
            this->f64_array_value.resize(_size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              xfer += iprot->readDouble(this->f64_array_value[_i118]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f64_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_tensor_value.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->i64_tensor_value.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              {
                this->i64_tensor_value[_i123].clear();
                uint32_t _size124;
                ::apache::thrift::protocol::TType _etype127;
                xfer += iprot->readListBegin(_etype127, _size124);
                this->i64_tensor_value[_i123].resize(_size124);
                uint32_t _i128;
                for (_i128 = 0; _i128 < _size124; ++_i128)
                {
                  xfer += iprot->readI64(this->i64_tensor_value[_i123][_i128]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_tensor_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f64_tensor_value.clear();
            uint32_t _size129;
            ::apache::thrift::protocol::TType _etype132;
            xfer += iprot->readListBegin(_etype132, _size129);
            this->f64_tensor_value.resize(_size129);
            uint32_t _i133;
            for (_i133 = 0; _i133 < _size129; ++_i133)
            {
              {
                this->f64_tensor_value[_i133].clear();
                uint32_t _size134;
                ::apache::thrift::protocol::TType _etype137;
                xfer += iprot->readListBegin(_etype137, _size134);
                this->f64_tensor_value[_i133].resize(_size134);
                uint32_t _i138;
                for (_i138 = 0; _i138 < _size134; ++_i138)
                {
                  xfer += iprot->readDouble(this->f64_tensor_value[_i133][_i138]);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f64_tensor_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_tensor_array_value.clear();
            uint32_t _size139;
            ::apache::thrift::protocol::TType _etype142;
            xfer += iprot->readListBegin(_etype142, _size139);
            this->i64_tensor_array_value.resize(_size139);
            uint32_t _i143;
            for (_i143 = 0; _i143 < _size139; ++_i143)
            {
              {
                this->i64_tensor_array_value[_i143].clear();
                uint32_t _size144;
                ::apache::thrift::protocol::TType _etype147;
                xfer += iprot->readListBegin(_etype147, _size144);
                this->i64_tensor_array_value[_i143].resize(_size144);
                uint32_t _i148;
                for (_i148 = 0; _i148 < _size144; ++_i148)
                {
                  {
                    this->i64_tensor_array_value[_i143][_i148].clear();
                    uint32_t _size149;
                    ::apache::thrift::protocol::TType _etype152;
                    xfer += iprot->readListBegin(_etype152, _size149);
                    this->i64_tensor_array_value[_i143][_i148].resize(_size149);
                    uint32_t _i153;
                    for (_i153 = 0; _i153 < _size149; ++_i153)
                    {
                      xfer += iprot->readI64(this->i64_tensor_array_value[_i143][_i148][_i153]);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_tensor_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f64_tensor_array_value.clear();
            uint32_t _size154;
            ::apache::thrift::protocol::TType _etype157;
            xfer += iprot->readListBegin(_etype157, _size154);
            this->f64_tensor_array_value.resize(_size154);
            uint32_t _i158;
            for (_i158 = 0; _i158 < _size154; ++_i158)
            {
              {
                this->f64_tensor_array_value[_i158].clear();
                uint32_t _size159;
                ::apache::thrift::protocol::TType _etype162;
                xfer += iprot->readListBegin(_etype162, _size159);
                this->f64_tensor_array_value[_i158].resize(_size159);
                uint32_t _i163;
                for (_i163 = 0; _i163 < _size159; ++_i163)
                {
                  {
                    this->f64_tensor_array_value[_i158][_i163].clear();
                    uint32_t _size164;
                    ::apache::thrift::protocol::TType _etype167;
                    xfer += iprot->readListBegin(_etype167, _size164);
                    this->f64_tensor_array_value[_i158][_i163].resize(_size164);
                    uint32_t _i168;
                    for (_i168 = 0; _i168 < _size164; ++_i168)
                    {
                      xfer += iprot->readDouble(this->f64_tensor_array_value[_i158][_i163][_i168]);
                    }
                    xfer += iprot->readListEnd();
                  }
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f64_tensor_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_array_idx.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->i64_array_idx.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += iprot->readI64(this->i64_array_idx[_i173]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_array_idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->curly_brackets_array.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            this->curly_brackets_array.resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              xfer += this->curly_brackets_array[_i178].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.curly_brackets_array = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConstantExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConstantExpr");

  xfer += oprot->writeFieldBegin("literal_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->literal_type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bool_value) {
    xfer += oprot->writeFieldBegin("bool_value", ::apache::thrift::protocol::T_BOOL, 2);
    xfer += oprot->writeBool(this->bool_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64_value) {
    xfer += oprot->writeFieldBegin("i64_value", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->i64_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f64_value) {
    xfer += oprot->writeFieldBegin("f64_value", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->f64_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.str_value) {
    xfer += oprot->writeFieldBegin("str_value", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->str_value);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64_array_value) {
    xfer += oprot->writeFieldBegin("i64_array_value", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->i64_array_value.size()));
      std::vector<int64_t> ::const_iterator _iter179;
      for (_iter179 = this->i64_array_value.begin(); _iter179 != this->i64_array_value.end(); ++_iter179)
      {
        xfer += oprot->writeI64((*_iter179));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f64_array_value) {
    xfer += oprot->writeFieldBegin("f64_array_value", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->f64_array_value.size()));
      std::vector<double> ::const_iterator _iter180;
      for (_iter180 = this->f64_array_value.begin(); _iter180 != this->f64_array_value.end(); ++_iter180)
      {
        xfer += oprot->writeDouble((*_iter180));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64_tensor_value) {
    xfer += oprot->writeFieldBegin("i64_tensor_value", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->i64_tensor_value.size()));
      std::vector<std::vector<int64_t> > ::const_iterator _iter181;
      for (_iter181 = this->i64_tensor_value.begin(); _iter181 != this->i64_tensor_value.end(); ++_iter181)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*_iter181).size()));
          std::vector<int64_t> ::const_iterator _iter182;
          for (_iter182 = (*_iter181).begin(); _iter182 != (*_iter181).end(); ++_iter182)
          {
            xfer += oprot->writeI64((*_iter182));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f64_tensor_value) {
    xfer += oprot->writeFieldBegin("f64_tensor_value", ::apache::thrift::protocol::T_LIST, 9);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->f64_tensor_value.size()));
      std::vector<std::vector<double> > ::const_iterator _iter183;
      for (_iter183 = this->f64_tensor_value.begin(); _iter183 != this->f64_tensor_value.end(); ++_iter183)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter183).size()));
          std::vector<double> ::const_iterator _iter184;
          for (_iter184 = (*_iter183).begin(); _iter184 != (*_iter183).end(); ++_iter184)
          {
            xfer += oprot->writeDouble((*_iter184));
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64_tensor_array_value) {
    xfer += oprot->writeFieldBegin("i64_tensor_array_value", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->i64_tensor_array_value.size()));
      std::vector<std::vector<std::vector<int64_t> > > ::const_iterator _iter185;
      for (_iter185 = this->i64_tensor_array_value.begin(); _iter185 != this->i64_tensor_array_value.end(); ++_iter185)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*_iter185).size()));
          std::vector<std::vector<int64_t> > ::const_iterator _iter186;
          for (_iter186 = (*_iter185).begin(); _iter186 != (*_iter185).end(); ++_iter186)
          {
            {
              xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>((*_iter186).size()));
              std::vector<int64_t> ::const_iterator _iter187;
              for (_iter187 = (*_iter186).begin(); _iter187 != (*_iter186).end(); ++_iter187)
              {
                xfer += oprot->writeI64((*_iter187));
              }
              xfer += oprot->writeListEnd();
            }
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f64_tensor_array_value) {
    xfer += oprot->writeFieldBegin("f64_tensor_array_value", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->f64_tensor_array_value.size()));
      std::vector<std::vector<std::vector<double> > > ::const_iterator _iter188;
      for (_iter188 = this->f64_tensor_array_value.begin(); _iter188 != this->f64_tensor_array_value.end(); ++_iter188)
      {
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_LIST, static_cast<uint32_t>((*_iter188).size()));
          std::vector<std::vector<double> > ::const_iterator _iter189;
          for (_iter189 = (*_iter188).begin(); _iter189 != (*_iter188).end(); ++_iter189)
          {
            {
              xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>((*_iter189).size()));
              std::vector<double> ::const_iterator _iter190;
              for (_iter190 = (*_iter189).begin(); _iter190 != (*_iter189).end(); ++_iter190)
              {
                xfer += oprot->writeDouble((*_iter190));
              }
              xfer += oprot->writeListEnd();
            }
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64_array_idx) {
    xfer += oprot->writeFieldBegin("i64_array_idx", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->i64_array_idx.size()));
      std::vector<int64_t> ::const_iterator _iter191;
      for (_iter191 = this->i64_array_idx.begin(); _iter191 != this->i64_array_idx.end(); ++_iter191)
      {
        xfer += oprot->writeI64((*_iter191));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.curly_brackets_array) {
    xfer += oprot->writeFieldBegin("curly_brackets_array", ::apache::thrift::protocol::T_LIST, 13);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->curly_brackets_array.size()));
      std::vector<ConstantExpr> ::const_iterator _iter192;
      for (_iter192 = this->curly_brackets_array.begin(); _iter192 != this->curly_brackets_array.end(); ++_iter192)
      {
        xfer += (*_iter192).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConstantExpr &a, ConstantExpr &b) {
  using ::std::swap;
  swap(a.literal_type, b.literal_type);
  swap(a.bool_value, b.bool_value);
  swap(a.i64_value, b.i64_value);
  swap(a.f64_value, b.f64_value);
  swap(a.str_value, b.str_value);
  swap(a.i64_array_value, b.i64_array_value);
  swap(a.f64_array_value, b.f64_array_value);
  swap(a.i64_tensor_value, b.i64_tensor_value);
  swap(a.f64_tensor_value, b.f64_tensor_value);
  swap(a.i64_tensor_array_value, b.i64_tensor_array_value);
  swap(a.f64_tensor_array_value, b.f64_tensor_array_value);
  swap(a.i64_array_idx, b.i64_array_idx);
  swap(a.curly_brackets_array, b.curly_brackets_array);
  swap(a.__isset, b.__isset);
}

ConstantExpr::ConstantExpr(const ConstantExpr& other193) {
  literal_type = other193.literal_type;
  bool_value = other193.bool_value;
  i64_value = other193.i64_value;
  f64_value = other193.f64_value;
  str_value = other193.str_value;
  i64_array_value = other193.i64_array_value;
  f64_array_value = other193.f64_array_value;
  i64_tensor_value = other193.i64_tensor_value;
  f64_tensor_value = other193.f64_tensor_value;
  i64_tensor_array_value = other193.i64_tensor_array_value;
  f64_tensor_array_value = other193.f64_tensor_array_value;
  i64_array_idx = other193.i64_array_idx;
  curly_brackets_array = other193.curly_brackets_array;
  __isset = other193.__isset;
}
ConstantExpr& ConstantExpr::operator=(const ConstantExpr& other194) {
  literal_type = other194.literal_type;
  bool_value = other194.bool_value;
  i64_value = other194.i64_value;
  f64_value = other194.f64_value;
  str_value = other194.str_value;
  i64_array_value = other194.i64_array_value;
  f64_array_value = other194.f64_array_value;
  i64_tensor_value = other194.i64_tensor_value;
  f64_tensor_value = other194.f64_tensor_value;
  i64_tensor_array_value = other194.i64_tensor_array_value;
  f64_tensor_array_value = other194.f64_tensor_array_value;
  i64_array_idx = other194.i64_array_idx;
  curly_brackets_array = other194.curly_brackets_array;
  __isset = other194.__isset;
  return *this;
}
void ConstantExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConstantExpr(";
  out << "literal_type=" << to_string(literal_type);
  out << ", " << "bool_value="; (__isset.bool_value ? (out << to_string(bool_value)) : (out << "<null>"));
  out << ", " << "i64_value="; (__isset.i64_value ? (out << to_string(i64_value)) : (out << "<null>"));
  out << ", " << "f64_value="; (__isset.f64_value ? (out << to_string(f64_value)) : (out << "<null>"));
  out << ", " << "str_value="; (__isset.str_value ? (out << to_string(str_value)) : (out << "<null>"));
  out << ", " << "i64_array_value="; (__isset.i64_array_value ? (out << to_string(i64_array_value)) : (out << "<null>"));
  out << ", " << "f64_array_value="; (__isset.f64_array_value ? (out << to_string(f64_array_value)) : (out << "<null>"));
  out << ", " << "i64_tensor_value="; (__isset.i64_tensor_value ? (out << to_string(i64_tensor_value)) : (out << "<null>"));
  out << ", " << "f64_tensor_value="; (__isset.f64_tensor_value ? (out << to_string(f64_tensor_value)) : (out << "<null>"));
  out << ", " << "i64_tensor_array_value="; (__isset.i64_tensor_array_value ? (out << to_string(i64_tensor_array_value)) : (out << "<null>"));
  out << ", " << "f64_tensor_array_value="; (__isset.f64_tensor_array_value ? (out << to_string(f64_tensor_array_value)) : (out << "<null>"));
  out << ", " << "i64_array_idx="; (__isset.i64_array_idx ? (out << to_string(i64_array_idx)) : (out << "<null>"));
  out << ", " << "curly_brackets_array="; (__isset.curly_brackets_array ? (out << to_string(curly_brackets_array)) : (out << "<null>"));
  out << ")";
}


FunctionExpr::~FunctionExpr() noexcept {
}


void FunctionExpr::__set_function_name(const std::string& val) {
  this->function_name = val;
}

void FunctionExpr::__set_arguments(const std::vector<ParsedExpr> & val) {
  this->arguments = val;
}
std::ostream& operator<<(std::ostream& out, const FunctionExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FunctionExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          this->__isset.function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size195;
            ::apache::thrift::protocol::TType _etype198;
            xfer += iprot->readListBegin(_etype198, _size195);
            this->arguments.resize(_size195);
            uint32_t _i199;
            for (_i199 = 0; _i199 < _size195; ++_i199)
            {
              xfer += this->arguments[_i199].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FunctionExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FunctionExpr");

  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arguments.size()));
    std::vector<ParsedExpr> ::const_iterator _iter200;
    for (_iter200 = this->arguments.begin(); _iter200 != this->arguments.end(); ++_iter200)
    {
      xfer += (*_iter200).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FunctionExpr &a, FunctionExpr &b) {
  using ::std::swap;
  swap(a.function_name, b.function_name);
  swap(a.arguments, b.arguments);
  swap(a.__isset, b.__isset);
}

FunctionExpr::FunctionExpr(const FunctionExpr& other201) {
  function_name = other201.function_name;
  arguments = other201.arguments;
  __isset = other201.__isset;
}
FunctionExpr& FunctionExpr::operator=(const FunctionExpr& other202) {
  function_name = other202.function_name;
  arguments = other202.arguments;
  __isset = other202.__isset;
  return *this;
}
void FunctionExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FunctionExpr(";
  out << "function_name=" << to_string(function_name);
  out << ", " << "arguments=" << to_string(arguments);
  out << ")";
}


KnnExpr::~KnnExpr() noexcept {
}


void KnnExpr::__set_column_expr(const ColumnExpr& val) {
  this->column_expr = val;
}

void KnnExpr::__set_embedding_data(const EmbeddingData& val) {
  this->embedding_data = val;
}

void KnnExpr::__set_embedding_data_type(const ElementType::type val) {
  this->embedding_data_type = val;
}

void KnnExpr::__set_distance_type(const KnnDistanceType::type val) {
  this->distance_type = val;
}

void KnnExpr::__set_topn(const int64_t val) {
  this->topn = val;
}

void KnnExpr::__set_opt_params(const std::vector<InitParameter> & val) {
  this->opt_params = val;
}

void KnnExpr::__set_filter_expr(const ParsedExpr& val) {
  this->filter_expr = val;
__isset.filter_expr = true;
}

void KnnExpr::__set_query_embedding_expr(const FunctionExpr& val) {
  this->query_embedding_expr = val;
__isset.query_embedding_expr = true;
}
std::ostream& operator<<(std::ostream& out, const KnnExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KnnExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_expr.read(iprot);
          this->__isset.column_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->embedding_data.read(iprot);
          this->__isset.embedding_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast203;
          xfer += iprot->readI32(ecast203);
          this->embedding_data_type = static_cast<ElementType::type>(ecast203);
          this->__isset.embedding_data_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast204;
          xfer += iprot->readI32(ecast204);
          this->distance_type = static_cast<KnnDistanceType::type>(ecast204);
          this->__isset.distance_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->topn);
          this->__isset.topn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->opt_params.clear();
            uint32_t _size205;
            ::apache::thrift::protocol::TType _etype208;
            xfer += iprot->readListBegin(_etype208, _size205);
            this->opt_params.resize(_size205);
            uint32_t _i209;
            for (_i209 = 0; _i209 < _size205; ++_i209)
            {
              xfer += this->opt_params[_i209].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.opt_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter_expr.read(iprot);
          this->__isset.filter_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_embedding_expr.read(iprot);
          this->__isset.query_embedding_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KnnExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KnnExpr");

  xfer += oprot->writeFieldBegin("column_expr", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->column_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("embedding_data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->embedding_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("embedding_data_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->embedding_data_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("distance_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->distance_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topn", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->topn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("opt_params", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->opt_params.size()));
    std::vector<InitParameter> ::const_iterator _iter210;
    for (_iter210 = this->opt_params.begin(); _iter210 != this->opt_params.end(); ++_iter210)
    {
      xfer += (*_iter210).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filter_expr) {
    xfer += oprot->writeFieldBegin("filter_expr", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->filter_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.query_embedding_expr) {
    xfer += oprot->writeFieldBegin("query_embedding_expr", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->query_embedding_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KnnExpr &a, KnnExpr &b) {
  using ::std::swap;
  swap(a.column_expr, b.column_expr);
  swap(a.embedding_data, b.embedding_data);
  swap(a.embedding_data_type, b.embedding_data_type);
  swap(a.distance_type, b.distance_type);
  swap(a.topn, b.topn);
  swap(a.opt_params, b.opt_params);
  swap(a.filter_expr, b.filter_expr);
  swap(a.query_embedding_expr, b.query_embedding_expr);
  swap(a.__isset, b.__isset);
}

KnnExpr::KnnExpr(const KnnExpr& other211) {
  column_expr = other211.column_expr;
  embedding_data = other211.embedding_data;
  embedding_data_type = other211.embedding_data_type;
  distance_type = other211.distance_type;
  topn = other211.topn;
  opt_params = other211.opt_params;
  filter_expr = other211.filter_expr;
  query_embedding_expr = other211.query_embedding_expr;
  __isset = other211.__isset;
}
KnnExpr& KnnExpr::operator=(const KnnExpr& other212) {
  column_expr = other212.column_expr;
  embedding_data = other212.embedding_data;
  embedding_data_type = other212.embedding_data_type;
  distance_type = other212.distance_type;
  topn = other212.topn;
  opt_params = other212.opt_params;
  filter_expr = other212.filter_expr;
  query_embedding_expr = other212.query_embedding_expr;
  __isset = other212.__isset;
  return *this;
}
void KnnExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KnnExpr(";
  out << "column_expr=" << to_string(column_expr);
  out << ", " << "embedding_data=" << to_string(embedding_data);
  out << ", " << "embedding_data_type=" << to_string(embedding_data_type);
  out << ", " << "distance_type=" << to_string(distance_type);
  out << ", " << "topn=" << to_string(topn);
  out << ", " << "opt_params=" << to_string(opt_params);
  out << ", " << "filter_expr="; (__isset.filter_expr ? (out << to_string(filter_expr)) : (out << "<null>"));
  out << ", " << "query_embedding_expr="; (__isset.query_embedding_expr ? (out << to_string(query_embedding_expr)) : (out << "<null>"));
  out << ")";
}


MatchSparseExpr::~MatchSparseExpr() noexcept {
}


void MatchSparseExpr::__set_column_expr(const ColumnExpr& val) {
  this->column_expr = val;
}

void MatchSparseExpr::__set_query_sparse_expr(const ConstantExpr& val) {
  this->query_sparse_expr = val;
}

void MatchSparseExpr::__set_metric_type(const std::string& val) {
  this->metric_type = val;
}

void MatchSparseExpr::__set_topn(const int64_t val) {
  this->topn = val;
}

void MatchSparseExpr::__set_opt_params(const std::vector<InitParameter> & val) {
  this->opt_params = val;
}

void MatchSparseExpr::__set_filter_expr(const ParsedExpr& val) {
  this->filter_expr = val;
__isset.filter_expr = true;
}
std::ostream& operator<<(std::ostream& out, const MatchSparseExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MatchSparseExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_expr.read(iprot);
          this->__isset.column_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->query_sparse_expr.read(iprot);
          this->__isset.query_sparse_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->metric_type);
          this->__isset.metric_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->topn);
          this->__isset.topn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->opt_params.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _etype216;
            xfer += iprot->readListBegin(_etype216, _size213);
            this->opt_params.resize(_size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              xfer += this->opt_params[_i217].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.opt_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter_expr.read(iprot);
          this->__isset.filter_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatchSparseExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatchSparseExpr");

  xfer += oprot->writeFieldBegin("column_expr", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->column_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("query_sparse_expr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->query_sparse_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("metric_type", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->metric_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topn", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->topn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("opt_params", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->opt_params.size()));
    std::vector<InitParameter> ::const_iterator _iter218;
    for (_iter218 = this->opt_params.begin(); _iter218 != this->opt_params.end(); ++_iter218)
    {
      xfer += (*_iter218).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filter_expr) {
    xfer += oprot->writeFieldBegin("filter_expr", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->filter_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatchSparseExpr &a, MatchSparseExpr &b) {
  using ::std::swap;
  swap(a.column_expr, b.column_expr);
  swap(a.query_sparse_expr, b.query_sparse_expr);
  swap(a.metric_type, b.metric_type);
  swap(a.topn, b.topn);
  swap(a.opt_params, b.opt_params);
  swap(a.filter_expr, b.filter_expr);
  swap(a.__isset, b.__isset);
}

MatchSparseExpr::MatchSparseExpr(const MatchSparseExpr& other219) {
  column_expr = other219.column_expr;
  query_sparse_expr = other219.query_sparse_expr;
  metric_type = other219.metric_type;
  topn = other219.topn;
  opt_params = other219.opt_params;
  filter_expr = other219.filter_expr;
  __isset = other219.__isset;
}
MatchSparseExpr& MatchSparseExpr::operator=(const MatchSparseExpr& other220) {
  column_expr = other220.column_expr;
  query_sparse_expr = other220.query_sparse_expr;
  metric_type = other220.metric_type;
  topn = other220.topn;
  opt_params = other220.opt_params;
  filter_expr = other220.filter_expr;
  __isset = other220.__isset;
  return *this;
}
void MatchSparseExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatchSparseExpr(";
  out << "column_expr=" << to_string(column_expr);
  out << ", " << "query_sparse_expr=" << to_string(query_sparse_expr);
  out << ", " << "metric_type=" << to_string(metric_type);
  out << ", " << "topn=" << to_string(topn);
  out << ", " << "opt_params=" << to_string(opt_params);
  out << ", " << "filter_expr="; (__isset.filter_expr ? (out << to_string(filter_expr)) : (out << "<null>"));
  out << ")";
}


MatchTensorExpr::~MatchTensorExpr() noexcept {
}


void MatchTensorExpr::__set_search_method(const std::string& val) {
  this->search_method = val;
}

void MatchTensorExpr::__set_column_expr(const ColumnExpr& val) {
  this->column_expr = val;
}

void MatchTensorExpr::__set_embedding_data_type(const ElementType::type val) {
  this->embedding_data_type = val;
}

void MatchTensorExpr::__set_embedding_data(const EmbeddingData& val) {
  this->embedding_data = val;
}

void MatchTensorExpr::__set_extra_options(const std::string& val) {
  this->extra_options = val;
}

void MatchTensorExpr::__set_filter_expr(const ParsedExpr& val) {
  this->filter_expr = val;
__isset.filter_expr = true;
}
std::ostream& operator<<(std::ostream& out, const MatchTensorExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MatchTensorExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->search_method);
          this->__isset.search_method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_expr.read(iprot);
          this->__isset.column_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast221;
          xfer += iprot->readI32(ecast221);
          this->embedding_data_type = static_cast<ElementType::type>(ecast221);
          this->__isset.embedding_data_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->embedding_data.read(iprot);
          this->__isset.embedding_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->extra_options);
          this->__isset.extra_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter_expr.read(iprot);
          this->__isset.filter_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatchTensorExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatchTensorExpr");

  xfer += oprot->writeFieldBegin("search_method", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->search_method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_expr", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->column_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("embedding_data_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->embedding_data_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("embedding_data", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->embedding_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra_options", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->extra_options);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filter_expr) {
    xfer += oprot->writeFieldBegin("filter_expr", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->filter_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatchTensorExpr &a, MatchTensorExpr &b) {
  using ::std::swap;
  swap(a.search_method, b.search_method);
  swap(a.column_expr, b.column_expr);
  swap(a.embedding_data_type, b.embedding_data_type);
  swap(a.embedding_data, b.embedding_data);
  swap(a.extra_options, b.extra_options);
  swap(a.filter_expr, b.filter_expr);
  swap(a.__isset, b.__isset);
}

MatchTensorExpr::MatchTensorExpr(const MatchTensorExpr& other222) {
  search_method = other222.search_method;
  column_expr = other222.column_expr;
  embedding_data_type = other222.embedding_data_type;
  embedding_data = other222.embedding_data;
  extra_options = other222.extra_options;
  filter_expr = other222.filter_expr;
  __isset = other222.__isset;
}
MatchTensorExpr& MatchTensorExpr::operator=(const MatchTensorExpr& other223) {
  search_method = other223.search_method;
  column_expr = other223.column_expr;
  embedding_data_type = other223.embedding_data_type;
  embedding_data = other223.embedding_data;
  extra_options = other223.extra_options;
  filter_expr = other223.filter_expr;
  __isset = other223.__isset;
  return *this;
}
void MatchTensorExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatchTensorExpr(";
  out << "search_method=" << to_string(search_method);
  out << ", " << "column_expr=" << to_string(column_expr);
  out << ", " << "embedding_data_type=" << to_string(embedding_data_type);
  out << ", " << "embedding_data=" << to_string(embedding_data);
  out << ", " << "extra_options=" << to_string(extra_options);
  out << ", " << "filter_expr="; (__isset.filter_expr ? (out << to_string(filter_expr)) : (out << "<null>"));
  out << ")";
}


MatchExpr::~MatchExpr() noexcept {
}


void MatchExpr::__set_fields(const std::string& val) {
  this->fields = val;
}

void MatchExpr::__set_matching_text(const std::string& val) {
  this->matching_text = val;
}

void MatchExpr::__set_options_text(const std::string& val) {
  this->options_text = val;
}

void MatchExpr::__set_filter_expr(const ParsedExpr& val) {
  this->filter_expr = val;
__isset.filter_expr = true;
}
std::ostream& operator<<(std::ostream& out, const MatchExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MatchExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fields);
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->matching_text);
          this->__isset.matching_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->options_text);
          this->__isset.options_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->filter_expr.read(iprot);
          this->__isset.filter_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatchExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatchExpr");

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->fields);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matching_text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->matching_text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options_text", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->options_text);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.filter_expr) {
    xfer += oprot->writeFieldBegin("filter_expr", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->filter_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatchExpr &a, MatchExpr &b) {
  using ::std::swap;
  swap(a.fields, b.fields);
  swap(a.matching_text, b.matching_text);
  swap(a.options_text, b.options_text);
  swap(a.filter_expr, b.filter_expr);
  swap(a.__isset, b.__isset);
}

MatchExpr::MatchExpr(const MatchExpr& other224) {
  fields = other224.fields;
  matching_text = other224.matching_text;
  options_text = other224.options_text;
  filter_expr = other224.filter_expr;
  __isset = other224.__isset;
}
MatchExpr& MatchExpr::operator=(const MatchExpr& other225) {
  fields = other225.fields;
  matching_text = other225.matching_text;
  options_text = other225.options_text;
  filter_expr = other225.filter_expr;
  __isset = other225.__isset;
  return *this;
}
void MatchExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatchExpr(";
  out << "fields=" << to_string(fields);
  out << ", " << "matching_text=" << to_string(matching_text);
  out << ", " << "options_text=" << to_string(options_text);
  out << ", " << "filter_expr="; (__isset.filter_expr ? (out << to_string(filter_expr)) : (out << "<null>"));
  out << ")";
}


GenericMatchExpr::~GenericMatchExpr() noexcept {
}


void GenericMatchExpr::__set_match_vector_expr(::std::shared_ptr<KnnExpr> val) {
  this->match_vector_expr = val;
__isset.match_vector_expr = true;
}

void GenericMatchExpr::__set_match_sparse_expr(::std::shared_ptr<MatchSparseExpr> val) {
  this->match_sparse_expr = val;
__isset.match_sparse_expr = true;
}

void GenericMatchExpr::__set_match_tensor_expr(::std::shared_ptr<MatchTensorExpr> val) {
  this->match_tensor_expr = val;
__isset.match_tensor_expr = true;
}

void GenericMatchExpr::__set_match_text_expr(::std::shared_ptr<MatchExpr> val) {
  this->match_text_expr = val;
__isset.match_text_expr = true;
}
std::ostream& operator<<(std::ostream& out, const GenericMatchExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GenericMatchExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->match_vector_expr) { 
            this->match_vector_expr = ::std::shared_ptr<KnnExpr>(new KnnExpr);
          }
          xfer += this->match_vector_expr->read(iprot);
          bool wasSet = false;
          if (this->match_vector_expr->__isset.column_expr) { wasSet = true; }
          if (this->match_vector_expr->__isset.embedding_data) { wasSet = true; }
          if (this->match_vector_expr->__isset.embedding_data_type) { wasSet = true; }
          if (this->match_vector_expr->__isset.distance_type) { wasSet = true; }
          if (this->match_vector_expr->__isset.topn) { wasSet = true; }
          if (this->match_vector_expr->__isset.opt_params) { wasSet = true; }
          if (this->match_vector_expr->__isset.filter_expr) { wasSet = true; }
          if (this->match_vector_expr->__isset.query_embedding_expr) { wasSet = true; }
          if (!wasSet) { this->match_vector_expr.reset(); }
          this->__isset.match_vector_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->match_sparse_expr) { 
            this->match_sparse_expr = ::std::shared_ptr<MatchSparseExpr>(new MatchSparseExpr);
          }
          xfer += this->match_sparse_expr->read(iprot);
          bool wasSet = false;
          if (this->match_sparse_expr->__isset.column_expr) { wasSet = true; }
          if (this->match_sparse_expr->__isset.query_sparse_expr) { wasSet = true; }
          if (this->match_sparse_expr->__isset.metric_type) { wasSet = true; }
          if (this->match_sparse_expr->__isset.topn) { wasSet = true; }
          if (this->match_sparse_expr->__isset.opt_params) { wasSet = true; }
          if (this->match_sparse_expr->__isset.filter_expr) { wasSet = true; }
          if (!wasSet) { this->match_sparse_expr.reset(); }
          this->__isset.match_sparse_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->match_tensor_expr) { 
            this->match_tensor_expr = ::std::shared_ptr<MatchTensorExpr>(new MatchTensorExpr);
          }
          xfer += this->match_tensor_expr->read(iprot);
          bool wasSet = false;
          if (this->match_tensor_expr->__isset.search_method) { wasSet = true; }
          if (this->match_tensor_expr->__isset.column_expr) { wasSet = true; }
          if (this->match_tensor_expr->__isset.embedding_data_type) { wasSet = true; }
          if (this->match_tensor_expr->__isset.embedding_data) { wasSet = true; }
          if (this->match_tensor_expr->__isset.extra_options) { wasSet = true; }
          if (this->match_tensor_expr->__isset.filter_expr) { wasSet = true; }
          if (!wasSet) { this->match_tensor_expr.reset(); }
          this->__isset.match_tensor_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->match_text_expr) { 
            this->match_text_expr = ::std::shared_ptr<MatchExpr>(new MatchExpr);
          }
          xfer += this->match_text_expr->read(iprot);
          bool wasSet = false;
          if (this->match_text_expr->__isset.fields) { wasSet = true; }
          if (this->match_text_expr->__isset.matching_text) { wasSet = true; }
          if (this->match_text_expr->__isset.options_text) { wasSet = true; }
          if (this->match_text_expr->__isset.filter_expr) { wasSet = true; }
          if (!wasSet) { this->match_text_expr.reset(); }
          this->__isset.match_text_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GenericMatchExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GenericMatchExpr");

  if (this->__isset.match_vector_expr) {
    xfer += oprot->writeFieldBegin("match_vector_expr", ::apache::thrift::protocol::T_STRUCT, 1);
    if (this->match_vector_expr) {
      xfer += this->match_vector_expr->write(oprot); 
    } else {oprot->writeStructBegin("KnnExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.match_sparse_expr) {
    xfer += oprot->writeFieldBegin("match_sparse_expr", ::apache::thrift::protocol::T_STRUCT, 2);
    if (this->match_sparse_expr) {
      xfer += this->match_sparse_expr->write(oprot); 
    } else {oprot->writeStructBegin("MatchSparseExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.match_tensor_expr) {
    xfer += oprot->writeFieldBegin("match_tensor_expr", ::apache::thrift::protocol::T_STRUCT, 3);
    if (this->match_tensor_expr) {
      xfer += this->match_tensor_expr->write(oprot); 
    } else {oprot->writeStructBegin("MatchTensorExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.match_text_expr) {
    xfer += oprot->writeFieldBegin("match_text_expr", ::apache::thrift::protocol::T_STRUCT, 4);
    if (this->match_text_expr) {
      xfer += this->match_text_expr->write(oprot); 
    } else {oprot->writeStructBegin("MatchExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GenericMatchExpr &a, GenericMatchExpr &b) {
  using ::std::swap;
  swap(a.match_vector_expr, b.match_vector_expr);
  swap(a.match_sparse_expr, b.match_sparse_expr);
  swap(a.match_tensor_expr, b.match_tensor_expr);
  swap(a.match_text_expr, b.match_text_expr);
  swap(a.__isset, b.__isset);
}

GenericMatchExpr::GenericMatchExpr(const GenericMatchExpr& other226) {
  match_vector_expr = other226.match_vector_expr;
  match_sparse_expr = other226.match_sparse_expr;
  match_tensor_expr = other226.match_tensor_expr;
  match_text_expr = other226.match_text_expr;
  __isset = other226.__isset;
}
GenericMatchExpr& GenericMatchExpr::operator=(const GenericMatchExpr& other227) {
  match_vector_expr = other227.match_vector_expr;
  match_sparse_expr = other227.match_sparse_expr;
  match_tensor_expr = other227.match_tensor_expr;
  match_text_expr = other227.match_text_expr;
  __isset = other227.__isset;
  return *this;
}
void GenericMatchExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GenericMatchExpr(";
  out << "match_vector_expr="; (__isset.match_vector_expr ? (out << to_string(match_vector_expr)) : (out << "<null>"));
  out << ", " << "match_sparse_expr="; (__isset.match_sparse_expr ? (out << to_string(match_sparse_expr)) : (out << "<null>"));
  out << ", " << "match_tensor_expr="; (__isset.match_tensor_expr ? (out << to_string(match_tensor_expr)) : (out << "<null>"));
  out << ", " << "match_text_expr="; (__isset.match_text_expr ? (out << to_string(match_text_expr)) : (out << "<null>"));
  out << ")";
}


FusionExpr::~FusionExpr() noexcept {
}


void FusionExpr::__set_method(const std::string& val) {
  this->method = val;
}

void FusionExpr::__set_options_text(const std::string& val) {
  this->options_text = val;
}

void FusionExpr::__set_optional_match_tensor_expr(const MatchTensorExpr& val) {
  this->optional_match_tensor_expr = val;
__isset.optional_match_tensor_expr = true;
}
std::ostream& operator<<(std::ostream& out, const FusionExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FusionExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->options_text);
          this->__isset.options_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->optional_match_tensor_expr.read(iprot);
          this->__isset.optional_match_tensor_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FusionExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FusionExpr");

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options_text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->options_text);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.optional_match_tensor_expr) {
    xfer += oprot->writeFieldBegin("optional_match_tensor_expr", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->optional_match_tensor_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FusionExpr &a, FusionExpr &b) {
  using ::std::swap;
  swap(a.method, b.method);
  swap(a.options_text, b.options_text);
  swap(a.optional_match_tensor_expr, b.optional_match_tensor_expr);
  swap(a.__isset, b.__isset);
}

FusionExpr::FusionExpr(const FusionExpr& other228) {
  method = other228.method;
  options_text = other228.options_text;
  optional_match_tensor_expr = other228.optional_match_tensor_expr;
  __isset = other228.__isset;
}
FusionExpr& FusionExpr::operator=(const FusionExpr& other229) {
  method = other229.method;
  options_text = other229.options_text;
  optional_match_tensor_expr = other229.optional_match_tensor_expr;
  __isset = other229.__isset;
  return *this;
}
void FusionExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FusionExpr(";
  out << "method=" << to_string(method);
  out << ", " << "options_text=" << to_string(options_text);
  out << ", " << "optional_match_tensor_expr="; (__isset.optional_match_tensor_expr ? (out << to_string(optional_match_tensor_expr)) : (out << "<null>"));
  out << ")";
}


SearchExpr::~SearchExpr() noexcept {
}


void SearchExpr::__set_match_exprs(const std::vector<GenericMatchExpr> & val) {
  this->match_exprs = val;
__isset.match_exprs = true;
}

void SearchExpr::__set_fusion_exprs(const std::vector<FusionExpr> & val) {
  this->fusion_exprs = val;
__isset.fusion_exprs = true;
}
std::ostream& operator<<(std::ostream& out, const SearchExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SearchExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->match_exprs.clear();
            uint32_t _size230;
            ::apache::thrift::protocol::TType _etype233;
            xfer += iprot->readListBegin(_etype233, _size230);
            this->match_exprs.resize(_size230);
            uint32_t _i234;
            for (_i234 = 0; _i234 < _size230; ++_i234)
            {
              xfer += this->match_exprs[_i234].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.match_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fusion_exprs.clear();
            uint32_t _size235;
            ::apache::thrift::protocol::TType _etype238;
            xfer += iprot->readListBegin(_etype238, _size235);
            this->fusion_exprs.resize(_size235);
            uint32_t _i239;
            for (_i239 = 0; _i239 < _size235; ++_i239)
            {
              xfer += this->fusion_exprs[_i239].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fusion_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SearchExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SearchExpr");

  if (this->__isset.match_exprs) {
    xfer += oprot->writeFieldBegin("match_exprs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->match_exprs.size()));
      std::vector<GenericMatchExpr> ::const_iterator _iter240;
      for (_iter240 = this->match_exprs.begin(); _iter240 != this->match_exprs.end(); ++_iter240)
      {
        xfer += (*_iter240).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fusion_exprs) {
    xfer += oprot->writeFieldBegin("fusion_exprs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fusion_exprs.size()));
      std::vector<FusionExpr> ::const_iterator _iter241;
      for (_iter241 = this->fusion_exprs.begin(); _iter241 != this->fusion_exprs.end(); ++_iter241)
      {
        xfer += (*_iter241).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SearchExpr &a, SearchExpr &b) {
  using ::std::swap;
  swap(a.match_exprs, b.match_exprs);
  swap(a.fusion_exprs, b.fusion_exprs);
  swap(a.__isset, b.__isset);
}

SearchExpr::SearchExpr(const SearchExpr& other242) {
  match_exprs = other242.match_exprs;
  fusion_exprs = other242.fusion_exprs;
  __isset = other242.__isset;
}
SearchExpr& SearchExpr::operator=(const SearchExpr& other243) {
  match_exprs = other243.match_exprs;
  fusion_exprs = other243.fusion_exprs;
  __isset = other243.__isset;
  return *this;
}
void SearchExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SearchExpr(";
  out << "match_exprs="; (__isset.match_exprs ? (out << to_string(match_exprs)) : (out << "<null>"));
  out << ", " << "fusion_exprs="; (__isset.fusion_exprs ? (out << to_string(fusion_exprs)) : (out << "<null>"));
  out << ")";
}


BetweenExpr::~BetweenExpr() noexcept {
}


void BetweenExpr::__set_value(const ParsedExpr& val) {
  this->value = val;
}

void BetweenExpr::__set_upper_bound(const ParsedExpr& val) {
  this->upper_bound = val;
}

void BetweenExpr::__set_lower_bound(const ParsedExpr& val) {
  this->lower_bound = val;
}
std::ostream& operator<<(std::ostream& out, const BetweenExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BetweenExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->upper_bound.read(iprot);
          this->__isset.upper_bound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lower_bound.read(iprot);
          this->__isset.lower_bound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BetweenExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BetweenExpr");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upper_bound", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->upper_bound.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lower_bound", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->lower_bound.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BetweenExpr &a, BetweenExpr &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.upper_bound, b.upper_bound);
  swap(a.lower_bound, b.lower_bound);
  swap(a.__isset, b.__isset);
}

BetweenExpr::BetweenExpr(const BetweenExpr& other244) {
  value = other244.value;
  upper_bound = other244.upper_bound;
  lower_bound = other244.lower_bound;
  __isset = other244.__isset;
}
BetweenExpr& BetweenExpr::operator=(const BetweenExpr& other245) {
  value = other245.value;
  upper_bound = other245.upper_bound;
  lower_bound = other245.lower_bound;
  __isset = other245.__isset;
  return *this;
}
void BetweenExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BetweenExpr(";
  out << "value=" << to_string(value);
  out << ", " << "upper_bound=" << to_string(upper_bound);
  out << ", " << "lower_bound=" << to_string(lower_bound);
  out << ")";
}


UpdateExpr::~UpdateExpr() noexcept {
}


void UpdateExpr::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void UpdateExpr::__set_value(const ParsedExpr& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const UpdateExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UpdateExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateExpr");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateExpr &a, UpdateExpr &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

UpdateExpr::UpdateExpr(const UpdateExpr& other246) {
  column_name = other246.column_name;
  value = other246.value;
  __isset = other246.__isset;
}
UpdateExpr& UpdateExpr::operator=(const UpdateExpr& other247) {
  column_name = other247.column_name;
  value = other247.value;
  __isset = other247.__isset;
  return *this;
}
void UpdateExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateExpr(";
  out << "column_name=" << to_string(column_name);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


OrderByExpr::~OrderByExpr() noexcept {
}


void OrderByExpr::__set_expr(const ParsedExpr& val) {
  this->expr = val;
}

void OrderByExpr::__set_asc(const bool val) {
  this->asc = val;
}
std::ostream& operator<<(std::ostream& out, const OrderByExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OrderByExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->expr.read(iprot);
          this->__isset.expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->asc);
          this->__isset.asc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OrderByExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OrderByExpr");

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asc", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->asc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OrderByExpr &a, OrderByExpr &b) {
  using ::std::swap;
  swap(a.expr, b.expr);
  swap(a.asc, b.asc);
  swap(a.__isset, b.__isset);
}

OrderByExpr::OrderByExpr(const OrderByExpr& other248) {
  expr = other248.expr;
  asc = other248.asc;
  __isset = other248.__isset;
}
OrderByExpr& OrderByExpr::operator=(const OrderByExpr& other249) {
  expr = other249.expr;
  asc = other249.asc;
  __isset = other249.__isset;
  return *this;
}
void OrderByExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OrderByExpr(";
  out << "expr=" << to_string(expr);
  out << ", " << "asc=" << to_string(asc);
  out << ")";
}


InExpr::~InExpr() noexcept {
}


void InExpr::__set_left_operand(const ParsedExpr& val) {
  this->left_operand = val;
}

void InExpr::__set_arguments(const std::vector<ParsedExpr> & val) {
  this->arguments = val;
}

void InExpr::__set_in_type(const bool val) {
  this->in_type = val;
}
std::ostream& operator<<(std::ostream& out, const InExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->left_operand.read(iprot);
          this->__isset.left_operand = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size250;
            ::apache::thrift::protocol::TType _etype253;
            xfer += iprot->readListBegin(_etype253, _size250);
            this->arguments.resize(_size250);
            uint32_t _i254;
            for (_i254 = 0; _i254 < _size250; ++_i254)
            {
              xfer += this->arguments[_i254].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->in_type);
          this->__isset.in_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InExpr");

  xfer += oprot->writeFieldBegin("left_operand", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->left_operand.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arguments.size()));
    std::vector<ParsedExpr> ::const_iterator _iter255;
    for (_iter255 = this->arguments.begin(); _iter255 != this->arguments.end(); ++_iter255)
    {
      xfer += (*_iter255).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("in_type", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->in_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InExpr &a, InExpr &b) {
  using ::std::swap;
  swap(a.left_operand, b.left_operand);
  swap(a.arguments, b.arguments);
  swap(a.in_type, b.in_type);
  swap(a.__isset, b.__isset);
}

InExpr::InExpr(const InExpr& other256) {
  left_operand = other256.left_operand;
  arguments = other256.arguments;
  in_type = other256.in_type;
  __isset = other256.__isset;
}
InExpr& InExpr::operator=(const InExpr& other257) {
  left_operand = other257.left_operand;
  arguments = other257.arguments;
  in_type = other257.in_type;
  __isset = other257.__isset;
  return *this;
}
void InExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InExpr(";
  out << "left_operand=" << to_string(left_operand);
  out << ", " << "arguments=" << to_string(arguments);
  out << ", " << "in_type=" << to_string(in_type);
  out << ")";
}


ColumnDef::~ColumnDef() noexcept {
}


void ColumnDef::__set_id(const int32_t val) {
  this->id = val;
}

void ColumnDef::__set_name(const std::string& val) {
  this->name = val;
}

void ColumnDef::__set_data_type(const DataType& val) {
  this->data_type = val;
}

void ColumnDef::__set_constraints(const std::vector<Constraint::type> & val) {
  this->constraints = val;
}

void ColumnDef::__set_constant_expr(const ConstantExpr& val) {
  this->constant_expr = val;
}

void ColumnDef::__set_comment(const std::string& val) {
  this->comment = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnDef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_type.read(iprot);
          this->__isset.data_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->constraints.clear();
            uint32_t _size258;
            ::apache::thrift::protocol::TType _etype261;
            xfer += iprot->readListBegin(_etype261, _size258);
            this->constraints.resize(_size258);
            uint32_t _i262;
            for (_i262 = 0; _i262 < _size258; ++_i262)
            {
              int32_t ecast263;
              xfer += iprot->readI32(ecast263);
              this->constraints[_i262] = static_cast<Constraint::type>(ecast263);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->constant_expr.read(iprot);
          this->__isset.constant_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnDef");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_type", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->data_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraints", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->constraints.size()));
    std::vector<Constraint::type> ::const_iterator _iter264;
    for (_iter264 = this->constraints.begin(); _iter264 != this->constraints.end(); ++_iter264)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter264)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constant_expr", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->constant_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnDef &a, ColumnDef &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.data_type, b.data_type);
  swap(a.constraints, b.constraints);
  swap(a.constant_expr, b.constant_expr);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

ColumnDef::ColumnDef(const ColumnDef& other265) {
  id = other265.id;
  name = other265.name;
  data_type = other265.data_type;
  constraints = other265.constraints;
  constant_expr = other265.constant_expr;
  comment = other265.comment;
  __isset = other265.__isset;
}
ColumnDef& ColumnDef::operator=(const ColumnDef& other266) {
  id = other266.id;
  name = other266.name;
  data_type = other266.data_type;
  constraints = other266.constraints;
  constant_expr = other266.constant_expr;
  comment = other266.comment;
  __isset = other266.__isset;
  return *this;
}
void ColumnDef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnDef(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "data_type=" << to_string(data_type);
  out << ", " << "constraints=" << to_string(constraints);
  out << ", " << "constant_expr=" << to_string(constant_expr);
  out << ", " << "comment=" << to_string(comment);
  out << ")";
}


Field::~Field() noexcept {
}


void Field::__set_column_names(const std::vector<std::string> & val) {
  this->column_names = val;
}

void Field::__set_parse_exprs(const std::vector<ParsedExpr> & val) {
  this->parse_exprs = val;
}
std::ostream& operator<<(std::ostream& out, const Field& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Field::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_names.clear();
            uint32_t _size267;
            ::apache::thrift::protocol::TType _etype270;
            xfer += iprot->readListBegin(_etype270, _size267);
            this->column_names.resize(_size267);
            uint32_t _i271;
            for (_i271 = 0; _i271 < _size267; ++_i271)
            {
              xfer += iprot->readString(this->column_names[_i271]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parse_exprs.clear();
            uint32_t _size272;
            ::apache::thrift::protocol::TType _etype275;
            xfer += iprot->readListBegin(_etype275, _size272);
            this->parse_exprs.resize(_size272);
            uint32_t _i276;
            for (_i276 = 0; _i276 < _size272; ++_i276)
            {
              xfer += this->parse_exprs[_i276].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.parse_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Field::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Field");

  xfer += oprot->writeFieldBegin("column_names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_names.size()));
    std::vector<std::string> ::const_iterator _iter277;
    for (_iter277 = this->column_names.begin(); _iter277 != this->column_names.end(); ++_iter277)
    {
      xfer += oprot->writeString((*_iter277));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parse_exprs", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->parse_exprs.size()));
    std::vector<ParsedExpr> ::const_iterator _iter278;
    for (_iter278 = this->parse_exprs.begin(); _iter278 != this->parse_exprs.end(); ++_iter278)
    {
      xfer += (*_iter278).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Field &a, Field &b) {
  using ::std::swap;
  swap(a.column_names, b.column_names);
  swap(a.parse_exprs, b.parse_exprs);
  swap(a.__isset, b.__isset);
}

Field::Field(const Field& other279) {
  column_names = other279.column_names;
  parse_exprs = other279.parse_exprs;
  __isset = other279.__isset;
}
Field& Field::operator=(const Field& other280) {
  column_names = other280.column_names;
  parse_exprs = other280.parse_exprs;
  __isset = other280.__isset;
  return *this;
}
void Field::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Field(";
  out << "column_names=" << to_string(column_names);
  out << ", " << "parse_exprs=" << to_string(parse_exprs);
  out << ")";
}


ColumnField::~ColumnField() noexcept {
}


void ColumnField::__set_column_type(const ColumnType::type val) {
  this->column_type = val;
}

void ColumnField::__set_column_vectors(const std::vector<std::string> & val) {
  this->column_vectors = val;
}

void ColumnField::__set_column_name(const std::string& val) {
  this->column_name = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast281;
          xfer += iprot->readI32(ecast281);
          this->column_type = static_cast<ColumnType::type>(ecast281);
          this->__isset.column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_vectors.clear();
            uint32_t _size282;
            ::apache::thrift::protocol::TType _etype285;
            xfer += iprot->readListBegin(_etype285, _size282);
            this->column_vectors.resize(_size282);
            uint32_t _i286;
            for (_i286 = 0; _i286 < _size282; ++_i286)
            {
              xfer += iprot->readBinary(this->column_vectors[_i286]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_vectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnField");

  xfer += oprot->writeFieldBegin("column_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->column_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_vectors", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_vectors.size()));
    std::vector<std::string> ::const_iterator _iter287;
    for (_iter287 = this->column_vectors.begin(); _iter287 != this->column_vectors.end(); ++_iter287)
    {
      xfer += oprot->writeBinary((*_iter287));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnField &a, ColumnField &b) {
  using ::std::swap;
  swap(a.column_type, b.column_type);
  swap(a.column_vectors, b.column_vectors);
  swap(a.column_name, b.column_name);
  swap(a.__isset, b.__isset);
}

ColumnField::ColumnField(const ColumnField& other288) {
  column_type = other288.column_type;
  column_vectors = other288.column_vectors;
  column_name = other288.column_name;
  __isset = other288.__isset;
}
ColumnField& ColumnField::operator=(const ColumnField& other289) {
  column_type = other289.column_type;
  column_vectors = other289.column_vectors;
  column_name = other289.column_name;
  __isset = other289.__isset;
  return *this;
}
void ColumnField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnField(";
  out << "column_type=" << to_string(column_type);
  out << ", " << "column_vectors=" << to_string(column_vectors);
  out << ", " << "column_name=" << to_string(column_name);
  out << ")";
}


ImportOption::~ImportOption() noexcept {
}


void ImportOption::__set_delimiter(const std::string& val) {
  this->delimiter = val;
}

void ImportOption::__set_has_header(const bool val) {
  this->has_header = val;
}

void ImportOption::__set_copy_file_type(const CopyFileType::type val) {
  this->copy_file_type = val;
}
std::ostream& operator<<(std::ostream& out, const ImportOption& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ImportOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delimiter);
          this->__isset.delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_header);
          this->__isset.has_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast290;
          xfer += iprot->readI32(ecast290);
          this->copy_file_type = static_cast<CopyFileType::type>(ecast290);
          this->__isset.copy_file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ImportOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ImportOption");

  xfer += oprot->writeFieldBegin("delimiter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_header", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->has_header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_file_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->copy_file_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ImportOption &a, ImportOption &b) {
  using ::std::swap;
  swap(a.delimiter, b.delimiter);
  swap(a.has_header, b.has_header);
  swap(a.copy_file_type, b.copy_file_type);
  swap(a.__isset, b.__isset);
}

ImportOption::ImportOption(const ImportOption& other291) {
  delimiter = other291.delimiter;
  has_header = other291.has_header;
  copy_file_type = other291.copy_file_type;
  __isset = other291.__isset;
}
ImportOption& ImportOption::operator=(const ImportOption& other292) {
  delimiter = other292.delimiter;
  has_header = other292.has_header;
  copy_file_type = other292.copy_file_type;
  __isset = other292.__isset;
  return *this;
}
void ImportOption::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ImportOption(";
  out << "delimiter=" << to_string(delimiter);
  out << ", " << "has_header=" << to_string(has_header);
  out << ", " << "copy_file_type=" << to_string(copy_file_type);
  out << ")";
}


ExportOption::~ExportOption() noexcept {
}


void ExportOption::__set_delimiter(const std::string& val) {
  this->delimiter = val;
}

void ExportOption::__set_has_header(const bool val) {
  this->has_header = val;
}

void ExportOption::__set_copy_file_type(const CopyFileType::type val) {
  this->copy_file_type = val;
}

void ExportOption::__set_offset(const int64_t val) {
  this->offset = val;
}

void ExportOption::__set_limit(const int64_t val) {
  this->limit = val;
}

void ExportOption::__set_row_limit(const int64_t val) {
  this->row_limit = val;
}
std::ostream& operator<<(std::ostream& out, const ExportOption& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExportOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delimiter);
          this->__isset.delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_header);
          this->__isset.has_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast293;
          xfer += iprot->readI32(ecast293);
          this->copy_file_type = static_cast<CopyFileType::type>(ecast293);
          this->__isset.copy_file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_limit);
          this->__isset.row_limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExportOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExportOption");

  xfer += oprot->writeFieldBegin("delimiter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_header", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->has_header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_file_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->copy_file_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->offset);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_limit", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->row_limit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExportOption &a, ExportOption &b) {
  using ::std::swap;
  swap(a.delimiter, b.delimiter);
  swap(a.has_header, b.has_header);
  swap(a.copy_file_type, b.copy_file_type);
  swap(a.offset, b.offset);
  swap(a.limit, b.limit);
  swap(a.row_limit, b.row_limit);
  swap(a.__isset, b.__isset);
}

ExportOption::ExportOption(const ExportOption& other294) {
  delimiter = other294.delimiter;
  has_header = other294.has_header;
  copy_file_type = other294.copy_file_type;
  offset = other294.offset;
  limit = other294.limit;
  row_limit = other294.row_limit;
  __isset = other294.__isset;
}
ExportOption& ExportOption::operator=(const ExportOption& other295) {
  delimiter = other295.delimiter;
  has_header = other295.has_header;
  copy_file_type = other295.copy_file_type;
  offset = other295.offset;
  limit = other295.limit;
  row_limit = other295.row_limit;
  __isset = other295.__isset;
  return *this;
}
void ExportOption::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExportOption(";
  out << "delimiter=" << to_string(delimiter);
  out << ", " << "has_header=" << to_string(has_header);
  out << ", " << "copy_file_type=" << to_string(copy_file_type);
  out << ", " << "offset=" << to_string(offset);
  out << ", " << "limit=" << to_string(limit);
  out << ", " << "row_limit=" << to_string(row_limit);
  out << ")";
}


OptimizeOptions::~OptimizeOptions() noexcept {
}


void OptimizeOptions::__set_index_name(const std::string& val) {
  this->index_name = val;
}

void OptimizeOptions::__set_opt_params(const std::vector<InitParameter> & val) {
  this->opt_params = val;
}
std::ostream& operator<<(std::ostream& out, const OptimizeOptions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OptimizeOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->opt_params.clear();
            uint32_t _size296;
            ::apache::thrift::protocol::TType _etype299;
            xfer += iprot->readListBegin(_etype299, _size296);
            this->opt_params.resize(_size296);
            uint32_t _i300;
            for (_i300 = 0; _i300 < _size296; ++_i300)
            {
              xfer += this->opt_params[_i300].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.opt_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptimizeOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptimizeOptions");

  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("opt_params", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->opt_params.size()));
    std::vector<InitParameter> ::const_iterator _iter301;
    for (_iter301 = this->opt_params.begin(); _iter301 != this->opt_params.end(); ++_iter301)
    {
      xfer += (*_iter301).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptimizeOptions &a, OptimizeOptions &b) {
  using ::std::swap;
  swap(a.index_name, b.index_name);
  swap(a.opt_params, b.opt_params);
  swap(a.__isset, b.__isset);
}

OptimizeOptions::OptimizeOptions(const OptimizeOptions& other302) {
  index_name = other302.index_name;
  opt_params = other302.opt_params;
  __isset = other302.__isset;
}
OptimizeOptions& OptimizeOptions::operator=(const OptimizeOptions& other303) {
  index_name = other303.index_name;
  opt_params = other303.opt_params;
  __isset = other303.__isset;
  return *this;
}
void OptimizeOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptimizeOptions(";
  out << "index_name=" << to_string(index_name);
  out << ", " << "opt_params=" << to_string(opt_params);
  out << ")";
}


ConnectRequest::~ConnectRequest() noexcept {
}


void ConnectRequest::__set_client_version(const int64_t val) {
  this->client_version = val;
}
std::ostream& operator<<(std::ostream& out, const ConnectRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ConnectRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->client_version);
          this->__isset.client_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConnectRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConnectRequest");

  xfer += oprot->writeFieldBegin("client_version", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->client_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConnectRequest &a, ConnectRequest &b) {
  using ::std::swap;
  swap(a.client_version, b.client_version);
  swap(a.__isset, b.__isset);
}

ConnectRequest::ConnectRequest(const ConnectRequest& other304) noexcept {
  client_version = other304.client_version;
  __isset = other304.__isset;
}
ConnectRequest& ConnectRequest::operator=(const ConnectRequest& other305) noexcept {
  client_version = other305.client_version;
  __isset = other305.__isset;
  return *this;
}
void ConnectRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConnectRequest(";
  out << "client_version=" << to_string(client_version);
  out << ")";
}


CommonRequest::~CommonRequest() noexcept {
}


void CommonRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const CommonRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommonRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommonRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommonRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommonRequest &a, CommonRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

CommonRequest::CommonRequest(const CommonRequest& other306) noexcept {
  session_id = other306.session_id;
  __isset = other306.__isset;
}
CommonRequest& CommonRequest::operator=(const CommonRequest& other307) noexcept {
  session_id = other307.session_id;
  __isset = other307.__isset;
  return *this;
}
void CommonRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommonRequest(";
  out << "session_id=" << to_string(session_id);
  out << ")";
}


CommonResponse::~CommonResponse() noexcept {
}


void CommonResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void CommonResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void CommonResponse::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const CommonResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommonResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommonResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommonResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommonResponse &a, CommonResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

CommonResponse::CommonResponse(const CommonResponse& other308) {
  error_code = other308.error_code;
  error_msg = other308.error_msg;
  session_id = other308.session_id;
  __isset = other308.__isset;
}
CommonResponse& CommonResponse::operator=(const CommonResponse& other309) {
  error_code = other309.error_code;
  error_msg = other309.error_msg;
  session_id = other309.session_id;
  __isset = other309.__isset;
  return *this;
}
void CommonResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommonResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ListDatabaseRequest::~ListDatabaseRequest() noexcept {
}


void ListDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ListDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListDatabaseRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListDatabaseRequest &a, ListDatabaseRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ListDatabaseRequest::ListDatabaseRequest(const ListDatabaseRequest& other310) noexcept {
  session_id = other310.session_id;
  __isset = other310.__isset;
}
ListDatabaseRequest& ListDatabaseRequest::operator=(const ListDatabaseRequest& other311) noexcept {
  session_id = other311.session_id;
  __isset = other311.__isset;
  return *this;
}
void ListDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListDatabaseRequest(";
  out << "session_id=" << to_string(session_id);
  out << ")";
}


ListDatabaseResponse::~ListDatabaseResponse() noexcept {
}


void ListDatabaseResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ListDatabaseResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ListDatabaseResponse::__set_db_names(const std::vector<std::string> & val) {
  this->db_names = val;
}

void ListDatabaseResponse::__set_db_dirs(const std::vector<std::string> & val) {
  this->db_dirs = val;
}

void ListDatabaseResponse::__set_db_comments(const std::vector<std::string> & val) {
  this->db_comments = val;
}
std::ostream& operator<<(std::ostream& out, const ListDatabaseResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListDatabaseResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->db_names.clear();
            uint32_t _size312;
            ::apache::thrift::protocol::TType _etype315;
            xfer += iprot->readListBegin(_etype315, _size312);
            this->db_names.resize(_size312);
            uint32_t _i316;
            for (_i316 = 0; _i316 < _size312; ++_i316)
            {
              xfer += iprot->readString(this->db_names[_i316]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.db_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->db_dirs.clear();
            uint32_t _size317;
            ::apache::thrift::protocol::TType _etype320;
            xfer += iprot->readListBegin(_etype320, _size317);
            this->db_dirs.resize(_size317);
            uint32_t _i321;
            for (_i321 = 0; _i321 < _size317; ++_i321)
            {
              xfer += iprot->readString(this->db_dirs[_i321]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.db_dirs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->db_comments.clear();
            uint32_t _size322;
            ::apache::thrift::protocol::TType _etype325;
            xfer += iprot->readListBegin(_etype325, _size322);
            this->db_comments.resize(_size322);
            uint32_t _i326;
            for (_i326 = 0; _i326 < _size322; ++_i326)
            {
              xfer += iprot->readString(this->db_comments[_i326]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.db_comments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListDatabaseResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListDatabaseResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->db_names.size()));
    std::vector<std::string> ::const_iterator _iter327;
    for (_iter327 = this->db_names.begin(); _iter327 != this->db_names.end(); ++_iter327)
    {
      xfer += oprot->writeString((*_iter327));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_dirs", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->db_dirs.size()));
    std::vector<std::string> ::const_iterator _iter328;
    for (_iter328 = this->db_dirs.begin(); _iter328 != this->db_dirs.end(); ++_iter328)
    {
      xfer += oprot->writeString((*_iter328));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_comments", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->db_comments.size()));
    std::vector<std::string> ::const_iterator _iter329;
    for (_iter329 = this->db_comments.begin(); _iter329 != this->db_comments.end(); ++_iter329)
    {
      xfer += oprot->writeString((*_iter329));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListDatabaseResponse &a, ListDatabaseResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.db_names, b.db_names);
  swap(a.db_dirs, b.db_dirs);
  swap(a.db_comments, b.db_comments);
  swap(a.__isset, b.__isset);
}

ListDatabaseResponse::ListDatabaseResponse(const ListDatabaseResponse& other330) {
  error_code = other330.error_code;
  error_msg = other330.error_msg;
  db_names = other330.db_names;
  db_dirs = other330.db_dirs;
  db_comments = other330.db_comments;
  __isset = other330.__isset;
}
ListDatabaseResponse& ListDatabaseResponse::operator=(const ListDatabaseResponse& other331) {
  error_code = other331.error_code;
  error_msg = other331.error_msg;
  db_names = other331.db_names;
  db_dirs = other331.db_dirs;
  db_comments = other331.db_comments;
  __isset = other331.__isset;
  return *this;
}
void ListDatabaseResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListDatabaseResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "db_names=" << to_string(db_names);
  out << ", " << "db_dirs=" << to_string(db_dirs);
  out << ", " << "db_comments=" << to_string(db_comments);
  out << ")";
}


ListTableRequest::~ListTableRequest() noexcept {
}


void ListTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ListTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ListTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListTableRequest &a, ListTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ListTableRequest::ListTableRequest(const ListTableRequest& other332) {
  db_name = other332.db_name;
  session_id = other332.session_id;
  __isset = other332.__isset;
}
ListTableRequest& ListTableRequest::operator=(const ListTableRequest& other333) {
  db_name = other333.db_name;
  session_id = other333.session_id;
  __isset = other333.__isset;
  return *this;
}
void ListTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ListTableResponse::~ListTableResponse() noexcept {
}


void ListTableResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ListTableResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ListTableResponse::__set_table_names(const std::vector<std::string> & val) {
  this->table_names = val;
}
std::ostream& operator<<(std::ostream& out, const ListTableResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListTableResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_names.clear();
            uint32_t _size334;
            ::apache::thrift::protocol::TType _etype337;
            xfer += iprot->readListBegin(_etype337, _size334);
            this->table_names.resize(_size334);
            uint32_t _i338;
            for (_i338 = 0; _i338 < _size334; ++_i338)
            {
              xfer += iprot->readString(this->table_names[_i338]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListTableResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListTableResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->table_names.size()));
    std::vector<std::string> ::const_iterator _iter339;
    for (_iter339 = this->table_names.begin(); _iter339 != this->table_names.end(); ++_iter339)
    {
      xfer += oprot->writeString((*_iter339));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListTableResponse &a, ListTableResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.table_names, b.table_names);
  swap(a.__isset, b.__isset);
}

ListTableResponse::ListTableResponse(const ListTableResponse& other340) {
  error_code = other340.error_code;
  error_msg = other340.error_msg;
  table_names = other340.table_names;
  __isset = other340.__isset;
}
ListTableResponse& ListTableResponse::operator=(const ListTableResponse& other341) {
  error_code = other341.error_code;
  error_msg = other341.error_msg;
  table_names = other341.table_names;
  __isset = other341.__isset;
  return *this;
}
void ListTableResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListTableResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "table_names=" << to_string(table_names);
  out << ")";
}


ListIndexRequest::~ListIndexRequest() noexcept {
}


void ListIndexRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ListIndexRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ListIndexRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ListIndexRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListIndexRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListIndexRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListIndexRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListIndexRequest &a, ListIndexRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ListIndexRequest::ListIndexRequest(const ListIndexRequest& other342) {
  db_name = other342.db_name;
  table_name = other342.table_name;
  session_id = other342.session_id;
  __isset = other342.__isset;
}
ListIndexRequest& ListIndexRequest::operator=(const ListIndexRequest& other343) {
  db_name = other343.db_name;
  table_name = other343.table_name;
  session_id = other343.session_id;
  __isset = other343.__isset;
  return *this;
}
void ListIndexRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListIndexRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ListIndexResponse::~ListIndexResponse() noexcept {
}


void ListIndexResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ListIndexResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ListIndexResponse::__set_index_names(const std::vector<std::string> & val) {
  this->index_names = val;
}
std::ostream& operator<<(std::ostream& out, const ListIndexResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListIndexResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->index_names.clear();
            uint32_t _size344;
            ::apache::thrift::protocol::TType _etype347;
            xfer += iprot->readListBegin(_etype347, _size344);
            this->index_names.resize(_size344);
            uint32_t _i348;
            for (_i348 = 0; _i348 < _size344; ++_i348)
            {
              xfer += iprot->readString(this->index_names[_i348]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.index_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListIndexResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListIndexResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->index_names.size()));
    std::vector<std::string> ::const_iterator _iter349;
    for (_iter349 = this->index_names.begin(); _iter349 != this->index_names.end(); ++_iter349)
    {
      xfer += oprot->writeString((*_iter349));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListIndexResponse &a, ListIndexResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.index_names, b.index_names);
  swap(a.__isset, b.__isset);
}

ListIndexResponse::ListIndexResponse(const ListIndexResponse& other350) {
  error_code = other350.error_code;
  error_msg = other350.error_msg;
  index_names = other350.index_names;
  __isset = other350.__isset;
}
ListIndexResponse& ListIndexResponse::operator=(const ListIndexResponse& other351) {
  error_code = other351.error_code;
  error_msg = other351.error_msg;
  index_names = other351.index_names;
  __isset = other351.__isset;
  return *this;
}
void ListIndexResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListIndexResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "index_names=" << to_string(index_names);
  out << ")";
}


ShowDatabaseRequest::~ShowDatabaseRequest() noexcept {
}


void ShowDatabaseRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowDatabaseRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowDatabaseRequest &a, ShowDatabaseRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ShowDatabaseRequest::ShowDatabaseRequest(const ShowDatabaseRequest& other352) {
  db_name = other352.db_name;
  session_id = other352.session_id;
  __isset = other352.__isset;
}
ShowDatabaseRequest& ShowDatabaseRequest::operator=(const ShowDatabaseRequest& other353) {
  db_name = other353.db_name;
  session_id = other353.session_id;
  __isset = other353.__isset;
  return *this;
}
void ShowDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowDatabaseRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ShowDatabaseResponse::~ShowDatabaseResponse() noexcept {
}


void ShowDatabaseResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ShowDatabaseResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ShowDatabaseResponse::__set_database_name(const std::string& val) {
  this->database_name = val;
}

void ShowDatabaseResponse::__set_store_dir(const std::string& val) {
  this->store_dir = val;
}

void ShowDatabaseResponse::__set_table_count(const int64_t val) {
  this->table_count = val;
}

void ShowDatabaseResponse::__set_comment(const std::string& val) {
  this->comment = val;
}
std::ostream& operator<<(std::ostream& out, const ShowDatabaseResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowDatabaseResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database_name);
          this->__isset.database_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->store_dir);
          this->__isset.store_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->table_count);
          this->__isset.table_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowDatabaseResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowDatabaseResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->database_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("store_dir", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->store_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_count", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->table_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowDatabaseResponse &a, ShowDatabaseResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.database_name, b.database_name);
  swap(a.store_dir, b.store_dir);
  swap(a.table_count, b.table_count);
  swap(a.comment, b.comment);
  swap(a.__isset, b.__isset);
}

ShowDatabaseResponse::ShowDatabaseResponse(const ShowDatabaseResponse& other354) {
  error_code = other354.error_code;
  error_msg = other354.error_msg;
  database_name = other354.database_name;
  store_dir = other354.store_dir;
  table_count = other354.table_count;
  comment = other354.comment;
  __isset = other354.__isset;
}
ShowDatabaseResponse& ShowDatabaseResponse::operator=(const ShowDatabaseResponse& other355) {
  error_code = other355.error_code;
  error_msg = other355.error_msg;
  database_name = other355.database_name;
  store_dir = other355.store_dir;
  table_count = other355.table_count;
  comment = other355.comment;
  __isset = other355.__isset;
  return *this;
}
void ShowDatabaseResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowDatabaseResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "database_name=" << to_string(database_name);
  out << ", " << "store_dir=" << to_string(store_dir);
  out << ", " << "table_count=" << to_string(table_count);
  out << ", " << "comment=" << to_string(comment);
  out << ")";
}


ShowTableRequest::~ShowTableRequest() noexcept {
}


void ShowTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowTableRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowTableRequest &a, ShowTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ShowTableRequest::ShowTableRequest(const ShowTableRequest& other356) {
  db_name = other356.db_name;
  table_name = other356.table_name;
  session_id = other356.session_id;
  __isset = other356.__isset;
}
ShowTableRequest& ShowTableRequest::operator=(const ShowTableRequest& other357) {
  db_name = other357.db_name;
  table_name = other357.table_name;
  session_id = other357.session_id;
  __isset = other357.__isset;
  return *this;
}
void ShowTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ShowTableResponse::~ShowTableResponse() noexcept {
}


void ShowTableResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ShowTableResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ShowTableResponse::__set_database_name(const std::string& val) {
  this->database_name = val;
}

void ShowTableResponse::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowTableResponse::__set_store_dir(const std::string& val) {
  this->store_dir = val;
}

void ShowTableResponse::__set_column_count(const int64_t val) {
  this->column_count = val;
}

void ShowTableResponse::__set_segment_count(const int64_t val) {
  this->segment_count = val;
}

void ShowTableResponse::__set_row_count(const int64_t val) {
  this->row_count = val;
}
std::ostream& operator<<(std::ostream& out, const ShowTableResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowTableResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->database_name);
          this->__isset.database_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->store_dir);
          this->__isset.store_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->column_count);
          this->__isset.column_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->segment_count);
          this->__isset.segment_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_count);
          this->__isset.row_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowTableResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowTableResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("database_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->database_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("store_dir", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->store_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_count", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->column_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("segment_count", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->segment_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_count", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->row_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowTableResponse &a, ShowTableResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.database_name, b.database_name);
  swap(a.table_name, b.table_name);
  swap(a.store_dir, b.store_dir);
  swap(a.column_count, b.column_count);
  swap(a.segment_count, b.segment_count);
  swap(a.row_count, b.row_count);
  swap(a.__isset, b.__isset);
}

ShowTableResponse::ShowTableResponse(const ShowTableResponse& other358) {
  error_code = other358.error_code;
  error_msg = other358.error_msg;
  database_name = other358.database_name;
  table_name = other358.table_name;
  store_dir = other358.store_dir;
  column_count = other358.column_count;
  segment_count = other358.segment_count;
  row_count = other358.row_count;
  __isset = other358.__isset;
}
ShowTableResponse& ShowTableResponse::operator=(const ShowTableResponse& other359) {
  error_code = other359.error_code;
  error_msg = other359.error_msg;
  database_name = other359.database_name;
  table_name = other359.table_name;
  store_dir = other359.store_dir;
  column_count = other359.column_count;
  segment_count = other359.segment_count;
  row_count = other359.row_count;
  __isset = other359.__isset;
  return *this;
}
void ShowTableResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowTableResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "database_name=" << to_string(database_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "store_dir=" << to_string(store_dir);
  out << ", " << "column_count=" << to_string(column_count);
  out << ", " << "segment_count=" << to_string(segment_count);
  out << ", " << "row_count=" << to_string(row_count);
  out << ")";
}


ShowColumnsRequest::~ShowColumnsRequest() noexcept {
}


void ShowColumnsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowColumnsRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowColumnsRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowColumnsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowColumnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowColumnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowColumnsRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowColumnsRequest &a, ShowColumnsRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ShowColumnsRequest::ShowColumnsRequest(const ShowColumnsRequest& other360) {
  db_name = other360.db_name;
  table_name = other360.table_name;
  session_id = other360.session_id;
  __isset = other360.__isset;
}
ShowColumnsRequest& ShowColumnsRequest::operator=(const ShowColumnsRequest& other361) {
  db_name = other361.db_name;
  table_name = other361.table_name;
  session_id = other361.session_id;
  __isset = other361.__isset;
  return *this;
}
void ShowColumnsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowColumnsRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


GetTableRequest::~GetTableRequest() noexcept {
}


void GetTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void GetTableRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void GetTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const GetTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTableRequest &a, GetTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

GetTableRequest::GetTableRequest(const GetTableRequest& other362) {
  db_name = other362.db_name;
  table_name = other362.table_name;
  session_id = other362.session_id;
  __isset = other362.__isset;
}
GetTableRequest& GetTableRequest::operator=(const GetTableRequest& other363) {
  db_name = other363.db_name;
  table_name = other363.table_name;
  session_id = other363.session_id;
  __isset = other363.__isset;
  return *this;
}
void GetTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


IndexInfo::~IndexInfo() noexcept {
}


void IndexInfo::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void IndexInfo::__set_index_type(const IndexType::type val) {
  this->index_type = val;
}

void IndexInfo::__set_index_param_list(const std::vector<InitParameter> & val) {
  this->index_param_list = val;
}
std::ostream& operator<<(std::ostream& out, const IndexInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IndexInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast364;
          xfer += iprot->readI32(ecast364);
          this->index_type = static_cast<IndexType::type>(ecast364);
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->index_param_list.clear();
            uint32_t _size365;
            ::apache::thrift::protocol::TType _etype368;
            xfer += iprot->readListBegin(_etype368, _size365);
            this->index_param_list.resize(_size365);
            uint32_t _i369;
            for (_i369 = 0; _i369 < _size365; ++_i369)
            {
              xfer += this->index_param_list[_i369].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.index_param_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IndexInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IndexInfo");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->index_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_param_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->index_param_list.size()));
    std::vector<InitParameter> ::const_iterator _iter370;
    for (_iter370 = this->index_param_list.begin(); _iter370 != this->index_param_list.end(); ++_iter370)
    {
      xfer += (*_iter370).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexInfo &a, IndexInfo &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.index_type, b.index_type);
  swap(a.index_param_list, b.index_param_list);
  swap(a.__isset, b.__isset);
}

IndexInfo::IndexInfo(const IndexInfo& other371) {
  column_name = other371.column_name;
  index_type = other371.index_type;
  index_param_list = other371.index_param_list;
  __isset = other371.__isset;
}
IndexInfo& IndexInfo::operator=(const IndexInfo& other372) {
  column_name = other372.column_name;
  index_type = other372.index_type;
  index_param_list = other372.index_param_list;
  __isset = other372.__isset;
  return *this;
}
void IndexInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IndexInfo(";
  out << "column_name=" << to_string(column_name);
  out << ", " << "index_type=" << to_string(index_type);
  out << ", " << "index_param_list=" << to_string(index_param_list);
  out << ")";
}


CreateIndexRequest::~CreateIndexRequest() noexcept {
}


void CreateIndexRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CreateIndexRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void CreateIndexRequest::__set_index_name(const std::string& val) {
  this->index_name = val;
}

void CreateIndexRequest::__set_index_comment(const std::string& val) {
  this->index_comment = val;
}

void CreateIndexRequest::__set_index_info(const IndexInfo& val) {
  this->index_info = val;
}

void CreateIndexRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateIndexRequest::__set_create_option(const CreateOption& val) {
  this->create_option = val;
}
std::ostream& operator<<(std::ostream& out, const CreateIndexRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateIndexRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_comment);
          this->__isset.index_comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->index_info.read(iprot);
          this->__isset.index_info = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_option.read(iprot);
          this->__isset.create_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateIndexRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateIndexRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_comment", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->index_comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_info", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->index_info.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_option", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->create_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateIndexRequest &a, CreateIndexRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.index_name, b.index_name);
  swap(a.index_comment, b.index_comment);
  swap(a.index_info, b.index_info);
  swap(a.session_id, b.session_id);
  swap(a.create_option, b.create_option);
  swap(a.__isset, b.__isset);
}

CreateIndexRequest::CreateIndexRequest(const CreateIndexRequest& other373) {
  db_name = other373.db_name;
  table_name = other373.table_name;
  index_name = other373.index_name;
  index_comment = other373.index_comment;
  index_info = other373.index_info;
  session_id = other373.session_id;
  create_option = other373.create_option;
  __isset = other373.__isset;
}
CreateIndexRequest& CreateIndexRequest::operator=(const CreateIndexRequest& other374) {
  db_name = other374.db_name;
  table_name = other374.table_name;
  index_name = other374.index_name;
  index_comment = other374.index_comment;
  index_info = other374.index_info;
  session_id = other374.session_id;
  create_option = other374.create_option;
  __isset = other374.__isset;
  return *this;
}
void CreateIndexRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateIndexRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "index_name=" << to_string(index_name);
  out << ", " << "index_comment=" << to_string(index_comment);
  out << ", " << "index_info=" << to_string(index_info);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "create_option=" << to_string(create_option);
  out << ")";
}


DropIndexRequest::~DropIndexRequest() noexcept {
}


void DropIndexRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DropIndexRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DropIndexRequest::__set_index_name(const std::string& val) {
  this->index_name = val;
}

void DropIndexRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void DropIndexRequest::__set_drop_option(const DropOption& val) {
  this->drop_option = val;
}
std::ostream& operator<<(std::ostream& out, const DropIndexRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropIndexRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_option.read(iprot);
          this->__isset.drop_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropIndexRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropIndexRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_option", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->drop_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropIndexRequest &a, DropIndexRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.index_name, b.index_name);
  swap(a.session_id, b.session_id);
  swap(a.drop_option, b.drop_option);
  swap(a.__isset, b.__isset);
}

DropIndexRequest::DropIndexRequest(const DropIndexRequest& other375) {
  db_name = other375.db_name;
  table_name = other375.table_name;
  index_name = other375.index_name;
  session_id = other375.session_id;
  drop_option = other375.drop_option;
  __isset = other375.__isset;
}
DropIndexRequest& DropIndexRequest::operator=(const DropIndexRequest& other376) {
  db_name = other376.db_name;
  table_name = other376.table_name;
  index_name = other376.index_name;
  session_id = other376.session_id;
  drop_option = other376.drop_option;
  __isset = other376.__isset;
  return *this;
}
void DropIndexRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropIndexRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "index_name=" << to_string(index_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "drop_option=" << to_string(drop_option);
  out << ")";
}


ShowIndexRequest::~ShowIndexRequest() noexcept {
}


void ShowIndexRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowIndexRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowIndexRequest::__set_index_name(const std::string& val) {
  this->index_name = val;
}

void ShowIndexRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowIndexRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowIndexRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowIndexRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowIndexRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowIndexRequest &a, ShowIndexRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.index_name, b.index_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ShowIndexRequest::ShowIndexRequest(const ShowIndexRequest& other377) {
  db_name = other377.db_name;
  table_name = other377.table_name;
  index_name = other377.index_name;
  session_id = other377.session_id;
  __isset = other377.__isset;
}
ShowIndexRequest& ShowIndexRequest::operator=(const ShowIndexRequest& other378) {
  db_name = other378.db_name;
  table_name = other378.table_name;
  index_name = other378.index_name;
  session_id = other378.session_id;
  __isset = other378.__isset;
  return *this;
}
void ShowIndexRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowIndexRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "index_name=" << to_string(index_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ShowIndexResponse::~ShowIndexResponse() noexcept {
}


void ShowIndexResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ShowIndexResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ShowIndexResponse::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowIndexResponse::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowIndexResponse::__set_index_name(const std::string& val) {
  this->index_name = val;
}

void ShowIndexResponse::__set_index_comment(const std::string& val) {
  this->index_comment = val;
}

void ShowIndexResponse::__set_index_type(const std::string& val) {
  this->index_type = val;
}

void ShowIndexResponse::__set_index_column_names(const std::string& val) {
  this->index_column_names = val;
}

void ShowIndexResponse::__set_index_column_ids(const std::string& val) {
  this->index_column_ids = val;
}

void ShowIndexResponse::__set_other_parameters(const std::string& val) {
  this->other_parameters = val;
}

void ShowIndexResponse::__set_store_dir(const std::string& val) {
  this->store_dir = val;
}

void ShowIndexResponse::__set_segment_index_count(const std::string& val) {
  this->segment_index_count = val;
}
std::ostream& operator<<(std::ostream& out, const ShowIndexResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowIndexResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_comment);
          this->__isset.index_comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_type);
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_column_names);
          this->__isset.index_column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_column_ids);
          this->__isset.index_column_ids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->other_parameters);
          this->__isset.other_parameters = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->store_dir);
          this->__isset.store_dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->segment_index_count);
          this->__isset.segment_index_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowIndexResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowIndexResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_comment", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->index_comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->index_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_column_names", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->index_column_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_column_ids", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->index_column_ids);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("other_parameters", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->other_parameters);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("store_dir", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->store_dir);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("segment_index_count", ::apache::thrift::protocol::T_STRING, 12);
  xfer += oprot->writeString(this->segment_index_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowIndexResponse &a, ShowIndexResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.index_name, b.index_name);
  swap(a.index_comment, b.index_comment);
  swap(a.index_type, b.index_type);
  swap(a.index_column_names, b.index_column_names);
  swap(a.index_column_ids, b.index_column_ids);
  swap(a.other_parameters, b.other_parameters);
  swap(a.store_dir, b.store_dir);
  swap(a.segment_index_count, b.segment_index_count);
  swap(a.__isset, b.__isset);
}

ShowIndexResponse::ShowIndexResponse(const ShowIndexResponse& other379) {
  error_code = other379.error_code;
  error_msg = other379.error_msg;
  db_name = other379.db_name;
  table_name = other379.table_name;
  index_name = other379.index_name;
  index_comment = other379.index_comment;
  index_type = other379.index_type;
  index_column_names = other379.index_column_names;
  index_column_ids = other379.index_column_ids;
  other_parameters = other379.other_parameters;
  store_dir = other379.store_dir;
  segment_index_count = other379.segment_index_count;
  __isset = other379.__isset;
}
ShowIndexResponse& ShowIndexResponse::operator=(const ShowIndexResponse& other380) {
  error_code = other380.error_code;
  error_msg = other380.error_msg;
  db_name = other380.db_name;
  table_name = other380.table_name;
  index_name = other380.index_name;
  index_comment = other380.index_comment;
  index_type = other380.index_type;
  index_column_names = other380.index_column_names;
  index_column_ids = other380.index_column_ids;
  other_parameters = other380.other_parameters;
  store_dir = other380.store_dir;
  segment_index_count = other380.segment_index_count;
  __isset = other380.__isset;
  return *this;
}
void ShowIndexResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowIndexResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "index_name=" << to_string(index_name);
  out << ", " << "index_comment=" << to_string(index_comment);
  out << ", " << "index_type=" << to_string(index_type);
  out << ", " << "index_column_names=" << to_string(index_column_names);
  out << ", " << "index_column_ids=" << to_string(index_column_ids);
  out << ", " << "other_parameters=" << to_string(other_parameters);
  out << ", " << "store_dir=" << to_string(store_dir);
  out << ", " << "segment_index_count=" << to_string(segment_index_count);
  out << ")";
}


OptimizeRequest::~OptimizeRequest() noexcept {
}


void OptimizeRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void OptimizeRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void OptimizeRequest::__set_optimize_options(const OptimizeOptions& val) {
  this->optimize_options = val;
}

void OptimizeRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const OptimizeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OptimizeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->optimize_options.read(iprot);
          this->__isset.optimize_options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OptimizeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OptimizeRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("optimize_options", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->optimize_options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OptimizeRequest &a, OptimizeRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.optimize_options, b.optimize_options);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

OptimizeRequest::OptimizeRequest(const OptimizeRequest& other381) {
  db_name = other381.db_name;
  table_name = other381.table_name;
  optimize_options = other381.optimize_options;
  session_id = other381.session_id;
  __isset = other381.__isset;
}
OptimizeRequest& OptimizeRequest::operator=(const OptimizeRequest& other382) {
  db_name = other382.db_name;
  table_name = other382.table_name;
  optimize_options = other382.optimize_options;
  session_id = other382.session_id;
  __isset = other382.__isset;
  return *this;
}
void OptimizeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OptimizeRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "optimize_options=" << to_string(optimize_options);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


GetDatabaseRequest::~GetDatabaseRequest() noexcept {
}


void GetDatabaseRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void GetDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const GetDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetDatabaseRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetDatabaseRequest &a, GetDatabaseRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

GetDatabaseRequest::GetDatabaseRequest(const GetDatabaseRequest& other383) {
  db_name = other383.db_name;
  session_id = other383.session_id;
  __isset = other383.__isset;
}
GetDatabaseRequest& GetDatabaseRequest::operator=(const GetDatabaseRequest& other384) {
  db_name = other384.db_name;
  session_id = other384.session_id;
  __isset = other384.__isset;
  return *this;
}
void GetDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetDatabaseRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


CreateDatabaseRequest::~CreateDatabaseRequest() noexcept {
}


void CreateDatabaseRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CreateDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateDatabaseRequest::__set_create_option(const CreateOption& val) {
  this->create_option = val;
}

void CreateDatabaseRequest::__set_db_comment(const std::string& val) {
  this->db_comment = val;
}
std::ostream& operator<<(std::ostream& out, const CreateDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_option.read(iprot);
          this->__isset.create_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_comment);
          this->__isset.db_comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateDatabaseRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_option", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->create_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_comment", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->db_comment);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateDatabaseRequest &a, CreateDatabaseRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.create_option, b.create_option);
  swap(a.db_comment, b.db_comment);
  swap(a.__isset, b.__isset);
}

CreateDatabaseRequest::CreateDatabaseRequest(const CreateDatabaseRequest& other385) {
  db_name = other385.db_name;
  session_id = other385.session_id;
  create_option = other385.create_option;
  db_comment = other385.db_comment;
  __isset = other385.__isset;
}
CreateDatabaseRequest& CreateDatabaseRequest::operator=(const CreateDatabaseRequest& other386) {
  db_name = other386.db_name;
  session_id = other386.session_id;
  create_option = other386.create_option;
  db_comment = other386.db_comment;
  __isset = other386.__isset;
  return *this;
}
void CreateDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateDatabaseRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "create_option=" << to_string(create_option);
  out << ", " << "db_comment=" << to_string(db_comment);
  out << ")";
}


DropDatabaseRequest::~DropDatabaseRequest() noexcept {
}


void DropDatabaseRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DropDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void DropDatabaseRequest::__set_drop_option(const DropOption& val) {
  this->drop_option = val;
}
std::ostream& operator<<(std::ostream& out, const DropDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_option.read(iprot);
          this->__isset.drop_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropDatabaseRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_option", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->drop_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropDatabaseRequest &a, DropDatabaseRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.drop_option, b.drop_option);
  swap(a.__isset, b.__isset);
}

DropDatabaseRequest::DropDatabaseRequest(const DropDatabaseRequest& other387) {
  db_name = other387.db_name;
  session_id = other387.session_id;
  drop_option = other387.drop_option;
  __isset = other387.__isset;
}
DropDatabaseRequest& DropDatabaseRequest::operator=(const DropDatabaseRequest& other388) {
  db_name = other388.db_name;
  session_id = other388.session_id;
  drop_option = other388.drop_option;
  __isset = other388.__isset;
  return *this;
}
void DropDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropDatabaseRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "drop_option=" << to_string(drop_option);
  out << ")";
}


CreateTableRequest::~CreateTableRequest() noexcept {
}


void CreateTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CreateTableRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void CreateTableRequest::__set_column_defs(const std::vector<ColumnDef> & val) {
  this->column_defs = val;
}

void CreateTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateTableRequest::__set_create_option(const CreateOption& val) {
  this->create_option = val;
}
std::ostream& operator<<(std::ostream& out, const CreateTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_defs.clear();
            uint32_t _size389;
            ::apache::thrift::protocol::TType _etype392;
            xfer += iprot->readListBegin(_etype392, _size389);
            this->column_defs.resize(_size389);
            uint32_t _i393;
            for (_i393 = 0; _i393 < _size389; ++_i393)
            {
              xfer += this->column_defs[_i393].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->create_option.read(iprot);
          this->__isset.create_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_defs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_defs.size()));
    std::vector<ColumnDef> ::const_iterator _iter394;
    for (_iter394 = this->column_defs.begin(); _iter394 != this->column_defs.end(); ++_iter394)
    {
      xfer += (*_iter394).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("create_option", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->create_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateTableRequest &a, CreateTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.column_defs, b.column_defs);
  swap(a.session_id, b.session_id);
  swap(a.create_option, b.create_option);
  swap(a.__isset, b.__isset);
}

CreateTableRequest::CreateTableRequest(const CreateTableRequest& other395) {
  db_name = other395.db_name;
  table_name = other395.table_name;
  column_defs = other395.column_defs;
  session_id = other395.session_id;
  create_option = other395.create_option;
  __isset = other395.__isset;
}
CreateTableRequest& CreateTableRequest::operator=(const CreateTableRequest& other396) {
  db_name = other396.db_name;
  table_name = other396.table_name;
  column_defs = other396.column_defs;
  session_id = other396.session_id;
  create_option = other396.create_option;
  __isset = other396.__isset;
  return *this;
}
void CreateTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_defs=" << to_string(column_defs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "create_option=" << to_string(create_option);
  out << ")";
}


DropTableRequest::~DropTableRequest() noexcept {
}


void DropTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DropTableRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DropTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void DropTableRequest::__set_drop_option(const DropOption& val) {
  this->drop_option = val;
}
std::ostream& operator<<(std::ostream& out, const DropTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->drop_option.read(iprot);
          this->__isset.drop_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("drop_option", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->drop_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropTableRequest &a, DropTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.session_id, b.session_id);
  swap(a.drop_option, b.drop_option);
  swap(a.__isset, b.__isset);
}

DropTableRequest::DropTableRequest(const DropTableRequest& other397) {
  db_name = other397.db_name;
  table_name = other397.table_name;
  session_id = other397.session_id;
  drop_option = other397.drop_option;
  __isset = other397.__isset;
}
DropTableRequest& DropTableRequest::operator=(const DropTableRequest& other398) {
  db_name = other398.db_name;
  table_name = other398.table_name;
  session_id = other398.session_id;
  drop_option = other398.drop_option;
  __isset = other398.__isset;
  return *this;
}
void DropTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "drop_option=" << to_string(drop_option);
  out << ")";
}


InsertRequest::~InsertRequest() noexcept {
}


void InsertRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void InsertRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void InsertRequest::__set_fields(const std::vector<Field> & val) {
  this->fields = val;
}

void InsertRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const InsertRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InsertRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size399;
            ::apache::thrift::protocol::TType _etype402;
            xfer += iprot->readListBegin(_etype402, _size399);
            this->fields.resize(_size399);
            uint32_t _i403;
            for (_i403 = 0; _i403 < _size399; ++_i403)
            {
              xfer += this->fields[_i403].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InsertRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InsertRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<Field> ::const_iterator _iter404;
    for (_iter404 = this->fields.begin(); _iter404 != this->fields.end(); ++_iter404)
    {
      xfer += (*_iter404).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InsertRequest &a, InsertRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.fields, b.fields);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

InsertRequest::InsertRequest(const InsertRequest& other405) {
  db_name = other405.db_name;
  table_name = other405.table_name;
  fields = other405.fields;
  session_id = other405.session_id;
  __isset = other405.__isset;
}
InsertRequest& InsertRequest::operator=(const InsertRequest& other406) {
  db_name = other406.db_name;
  table_name = other406.table_name;
  fields = other406.fields;
  session_id = other406.session_id;
  __isset = other406.__isset;
  return *this;
}
void InsertRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InsertRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "fields=" << to_string(fields);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ImportRequest::~ImportRequest() noexcept {
}


void ImportRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ImportRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ImportRequest::__set_file_name(const std::string& val) {
  this->file_name = val;
}

void ImportRequest::__set_import_option(const ImportOption& val) {
  this->import_option = val;
}

void ImportRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ImportRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ImportRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_name);
          this->__isset.file_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->import_option.read(iprot);
          this->__isset.import_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ImportRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ImportRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->file_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("import_option", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->import_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ImportRequest &a, ImportRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.file_name, b.file_name);
  swap(a.import_option, b.import_option);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ImportRequest::ImportRequest(const ImportRequest& other407) {
  db_name = other407.db_name;
  table_name = other407.table_name;
  file_name = other407.file_name;
  import_option = other407.import_option;
  session_id = other407.session_id;
  __isset = other407.__isset;
}
ImportRequest& ImportRequest::operator=(const ImportRequest& other408) {
  db_name = other408.db_name;
  table_name = other408.table_name;
  file_name = other408.file_name;
  import_option = other408.import_option;
  session_id = other408.session_id;
  __isset = other408.__isset;
  return *this;
}
void ImportRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ImportRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "file_name=" << to_string(file_name);
  out << ", " << "import_option=" << to_string(import_option);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ExportRequest::~ExportRequest() noexcept {
}


void ExportRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ExportRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ExportRequest::__set_columns(const std::vector<std::string> & val) {
  this->columns = val;
}

void ExportRequest::__set_file_name(const std::string& val) {
  this->file_name = val;
}

void ExportRequest::__set_export_option(const ExportOption& val) {
  this->export_option = val;
}

void ExportRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ExportRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExportRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns.clear();
            uint32_t _size409;
            ::apache::thrift::protocol::TType _etype412;
            xfer += iprot->readListBegin(_etype412, _size409);
            this->columns.resize(_size409);
            uint32_t _i413;
            for (_i413 = 0; _i413 < _size409; ++_i413)
            {
              xfer += iprot->readString(this->columns[_i413]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_name);
          this->__isset.file_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->export_option.read(iprot);
          this->__isset.export_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExportRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExportRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->columns.size()));
    std::vector<std::string> ::const_iterator _iter414;
    for (_iter414 = this->columns.begin(); _iter414 != this->columns.end(); ++_iter414)
    {
      xfer += oprot->writeString((*_iter414));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->file_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("export_option", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->export_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExportRequest &a, ExportRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.columns, b.columns);
  swap(a.file_name, b.file_name);
  swap(a.export_option, b.export_option);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ExportRequest::ExportRequest(const ExportRequest& other415) {
  db_name = other415.db_name;
  table_name = other415.table_name;
  columns = other415.columns;
  file_name = other415.file_name;
  export_option = other415.export_option;
  session_id = other415.session_id;
  __isset = other415.__isset;
}
ExportRequest& ExportRequest::operator=(const ExportRequest& other416) {
  db_name = other416.db_name;
  table_name = other416.table_name;
  columns = other416.columns;
  file_name = other416.file_name;
  export_option = other416.export_option;
  session_id = other416.session_id;
  __isset = other416.__isset;
  return *this;
}
void ExportRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExportRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "columns=" << to_string(columns);
  out << ", " << "file_name=" << to_string(file_name);
  out << ", " << "export_option=" << to_string(export_option);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ExplainRequest::~ExplainRequest() noexcept {
}


void ExplainRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ExplainRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ExplainRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ExplainRequest::__set_select_list(const std::vector<ParsedExpr> & val) {
  this->select_list = val;
}

void ExplainRequest::__set_highlight_list(const std::vector<ParsedExpr> & val) {
  this->highlight_list = val;
__isset.highlight_list = true;
}

void ExplainRequest::__set_search_expr(const SearchExpr& val) {
  this->search_expr = val;
__isset.search_expr = true;
}

void ExplainRequest::__set_where_expr(const ParsedExpr& val) {
  this->where_expr = val;
__isset.where_expr = true;
}

void ExplainRequest::__set_group_by_list(const std::vector<ParsedExpr> & val) {
  this->group_by_list = val;
__isset.group_by_list = true;
}

void ExplainRequest::__set_having_expr(const ParsedExpr& val) {
  this->having_expr = val;
__isset.having_expr = true;
}

void ExplainRequest::__set_limit_expr(const ParsedExpr& val) {
  this->limit_expr = val;
__isset.limit_expr = true;
}

void ExplainRequest::__set_offset_expr(const ParsedExpr& val) {
  this->offset_expr = val;
__isset.offset_expr = true;
}

void ExplainRequest::__set_order_by_list(const std::vector<OrderByExpr> & val) {
  this->order_by_list = val;
__isset.order_by_list = true;
}

void ExplainRequest::__set_explain_type(const ExplainType::type val) {
  this->explain_type = val;
}
std::ostream& operator<<(std::ostream& out, const ExplainRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExplainRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->select_list.clear();
            uint32_t _size417;
            ::apache::thrift::protocol::TType _etype420;
            xfer += iprot->readListBegin(_etype420, _size417);
            this->select_list.resize(_size417);
            uint32_t _i421;
            for (_i421 = 0; _i421 < _size417; ++_i421)
            {
              xfer += this->select_list[_i421].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.select_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->highlight_list.clear();
            uint32_t _size422;
            ::apache::thrift::protocol::TType _etype425;
            xfer += iprot->readListBegin(_etype425, _size422);
            this->highlight_list.resize(_size422);
            uint32_t _i426;
            for (_i426 = 0; _i426 < _size422; ++_i426)
            {
              xfer += this->highlight_list[_i426].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.highlight_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->search_expr.read(iprot);
          this->__isset.search_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->where_expr.read(iprot);
          this->__isset.where_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group_by_list.clear();
            uint32_t _size427;
            ::apache::thrift::protocol::TType _etype430;
            xfer += iprot->readListBegin(_etype430, _size427);
            this->group_by_list.resize(_size427);
            uint32_t _i431;
            for (_i431 = 0; _i431 < _size427; ++_i431)
            {
              xfer += this->group_by_list[_i431].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.group_by_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->having_expr.read(iprot);
          this->__isset.having_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->limit_expr.read(iprot);
          this->__isset.limit_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->offset_expr.read(iprot);
          this->__isset.offset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->order_by_list.clear();
            uint32_t _size432;
            ::apache::thrift::protocol::TType _etype435;
            xfer += iprot->readListBegin(_etype435, _size432);
            this->order_by_list.resize(_size432);
            uint32_t _i436;
            for (_i436 = 0; _i436 < _size432; ++_i436)
            {
              xfer += this->order_by_list[_i436].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.order_by_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast437;
          xfer += iprot->readI32(ecast437);
          this->explain_type = static_cast<ExplainType::type>(ecast437);
          this->__isset.explain_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExplainRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExplainRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_list", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->select_list.size()));
    std::vector<ParsedExpr> ::const_iterator _iter438;
    for (_iter438 = this->select_list.begin(); _iter438 != this->select_list.end(); ++_iter438)
    {
      xfer += (*_iter438).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.highlight_list) {
    xfer += oprot->writeFieldBegin("highlight_list", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->highlight_list.size()));
      std::vector<ParsedExpr> ::const_iterator _iter439;
      for (_iter439 = this->highlight_list.begin(); _iter439 != this->highlight_list.end(); ++_iter439)
      {
        xfer += (*_iter439).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.search_expr) {
    xfer += oprot->writeFieldBegin("search_expr", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->search_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.where_expr) {
    xfer += oprot->writeFieldBegin("where_expr", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->where_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_by_list) {
    xfer += oprot->writeFieldBegin("group_by_list", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->group_by_list.size()));
      std::vector<ParsedExpr> ::const_iterator _iter440;
      for (_iter440 = this->group_by_list.begin(); _iter440 != this->group_by_list.end(); ++_iter440)
      {
        xfer += (*_iter440).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.having_expr) {
    xfer += oprot->writeFieldBegin("having_expr", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->having_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit_expr) {
    xfer += oprot->writeFieldBegin("limit_expr", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->limit_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset_expr) {
    xfer += oprot->writeFieldBegin("offset_expr", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->offset_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order_by_list) {
    xfer += oprot->writeFieldBegin("order_by_list", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->order_by_list.size()));
      std::vector<OrderByExpr> ::const_iterator _iter441;
      for (_iter441 = this->order_by_list.begin(); _iter441 != this->order_by_list.end(); ++_iter441)
      {
        xfer += (*_iter441).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("explain_type", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(static_cast<int32_t>(this->explain_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExplainRequest &a, ExplainRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.select_list, b.select_list);
  swap(a.highlight_list, b.highlight_list);
  swap(a.search_expr, b.search_expr);
  swap(a.where_expr, b.where_expr);
  swap(a.group_by_list, b.group_by_list);
  swap(a.having_expr, b.having_expr);
  swap(a.limit_expr, b.limit_expr);
  swap(a.offset_expr, b.offset_expr);
  swap(a.order_by_list, b.order_by_list);
  swap(a.explain_type, b.explain_type);
  swap(a.__isset, b.__isset);
}

ExplainRequest::ExplainRequest(const ExplainRequest& other442) {
  session_id = other442.session_id;
  db_name = other442.db_name;
  table_name = other442.table_name;
  select_list = other442.select_list;
  highlight_list = other442.highlight_list;
  search_expr = other442.search_expr;
  where_expr = other442.where_expr;
  group_by_list = other442.group_by_list;
  having_expr = other442.having_expr;
  limit_expr = other442.limit_expr;
  offset_expr = other442.offset_expr;
  order_by_list = other442.order_by_list;
  explain_type = other442.explain_type;
  __isset = other442.__isset;
}
ExplainRequest& ExplainRequest::operator=(const ExplainRequest& other443) {
  session_id = other443.session_id;
  db_name = other443.db_name;
  table_name = other443.table_name;
  select_list = other443.select_list;
  highlight_list = other443.highlight_list;
  search_expr = other443.search_expr;
  where_expr = other443.where_expr;
  group_by_list = other443.group_by_list;
  having_expr = other443.having_expr;
  limit_expr = other443.limit_expr;
  offset_expr = other443.offset_expr;
  order_by_list = other443.order_by_list;
  explain_type = other443.explain_type;
  __isset = other443.__isset;
  return *this;
}
void ExplainRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExplainRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "select_list=" << to_string(select_list);
  out << ", " << "highlight_list="; (__isset.highlight_list ? (out << to_string(highlight_list)) : (out << "<null>"));
  out << ", " << "search_expr="; (__isset.search_expr ? (out << to_string(search_expr)) : (out << "<null>"));
  out << ", " << "where_expr="; (__isset.where_expr ? (out << to_string(where_expr)) : (out << "<null>"));
  out << ", " << "group_by_list="; (__isset.group_by_list ? (out << to_string(group_by_list)) : (out << "<null>"));
  out << ", " << "having_expr="; (__isset.having_expr ? (out << to_string(having_expr)) : (out << "<null>"));
  out << ", " << "limit_expr="; (__isset.limit_expr ? (out << to_string(limit_expr)) : (out << "<null>"));
  out << ", " << "offset_expr="; (__isset.offset_expr ? (out << to_string(offset_expr)) : (out << "<null>"));
  out << ", " << "order_by_list="; (__isset.order_by_list ? (out << to_string(order_by_list)) : (out << "<null>"));
  out << ", " << "explain_type=" << to_string(explain_type);
  out << ")";
}


ExplainResponse::~ExplainResponse() noexcept {
}


void ExplainResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ExplainResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ExplainResponse::__set_column_defs(const std::vector<ColumnDef> & val) {
  this->column_defs = val;
}

void ExplainResponse::__set_column_fields(const std::vector<ColumnField> & val) {
  this->column_fields = val;
}
std::ostream& operator<<(std::ostream& out, const ExplainResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExplainResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_defs.clear();
            uint32_t _size444;
            ::apache::thrift::protocol::TType _etype447;
            xfer += iprot->readListBegin(_etype447, _size444);
            this->column_defs.resize(_size444);
            uint32_t _i448;
            for (_i448 = 0; _i448 < _size444; ++_i448)
            {
              xfer += this->column_defs[_i448].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_fields.clear();
            uint32_t _size449;
            ::apache::thrift::protocol::TType _etype452;
            xfer += iprot->readListBegin(_etype452, _size449);
            this->column_fields.resize(_size449);
            uint32_t _i453;
            for (_i453 = 0; _i453 < _size449; ++_i453)
            {
              xfer += this->column_fields[_i453].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExplainResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExplainResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_defs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_defs.size()));
    std::vector<ColumnDef> ::const_iterator _iter454;
    for (_iter454 = this->column_defs.begin(); _iter454 != this->column_defs.end(); ++_iter454)
    {
      xfer += (*_iter454).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_fields.size()));
    std::vector<ColumnField> ::const_iterator _iter455;
    for (_iter455 = this->column_fields.begin(); _iter455 != this->column_fields.end(); ++_iter455)
    {
      xfer += (*_iter455).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExplainResponse &a, ExplainResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.column_defs, b.column_defs);
  swap(a.column_fields, b.column_fields);
  swap(a.__isset, b.__isset);
}

ExplainResponse::ExplainResponse(const ExplainResponse& other456) {
  error_code = other456.error_code;
  error_msg = other456.error_msg;
  column_defs = other456.column_defs;
  column_fields = other456.column_fields;
  __isset = other456.__isset;
}
ExplainResponse& ExplainResponse::operator=(const ExplainResponse& other457) {
  error_code = other457.error_code;
  error_msg = other457.error_msg;
  column_defs = other457.column_defs;
  column_fields = other457.column_fields;
  __isset = other457.__isset;
  return *this;
}
void ExplainResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExplainResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "column_defs=" << to_string(column_defs);
  out << ", " << "column_fields=" << to_string(column_fields);
  out << ")";
}


SelectRequest::~SelectRequest() noexcept {
}


void SelectRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void SelectRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void SelectRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SelectRequest::__set_select_list(const std::vector<ParsedExpr> & val) {
  this->select_list = val;
}

void SelectRequest::__set_highlight_list(const std::vector<ParsedExpr> & val) {
  this->highlight_list = val;
__isset.highlight_list = true;
}

void SelectRequest::__set_search_expr(const SearchExpr& val) {
  this->search_expr = val;
__isset.search_expr = true;
}

void SelectRequest::__set_where_expr(const ParsedExpr& val) {
  this->where_expr = val;
__isset.where_expr = true;
}

void SelectRequest::__set_group_by_list(const std::vector<ParsedExpr> & val) {
  this->group_by_list = val;
__isset.group_by_list = true;
}

void SelectRequest::__set_having_expr(const ParsedExpr& val) {
  this->having_expr = val;
__isset.having_expr = true;
}

void SelectRequest::__set_limit_expr(const ParsedExpr& val) {
  this->limit_expr = val;
__isset.limit_expr = true;
}

void SelectRequest::__set_offset_expr(const ParsedExpr& val) {
  this->offset_expr = val;
__isset.offset_expr = true;
}

void SelectRequest::__set_order_by_list(const std::vector<OrderByExpr> & val) {
  this->order_by_list = val;
__isset.order_by_list = true;
}

void SelectRequest::__set_total_hits_count(const bool val) {
  this->total_hits_count = val;
__isset.total_hits_count = true;
}
std::ostream& operator<<(std::ostream& out, const SelectRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SelectRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->select_list.clear();
            uint32_t _size458;
            ::apache::thrift::protocol::TType _etype461;
            xfer += iprot->readListBegin(_etype461, _size458);
            this->select_list.resize(_size458);
            uint32_t _i462;
            for (_i462 = 0; _i462 < _size458; ++_i462)
            {
              xfer += this->select_list[_i462].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.select_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->highlight_list.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _etype466;
            xfer += iprot->readListBegin(_etype466, _size463);
            this->highlight_list.resize(_size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              xfer += this->highlight_list[_i467].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.highlight_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->search_expr.read(iprot);
          this->__isset.search_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->where_expr.read(iprot);
          this->__isset.where_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group_by_list.clear();
            uint32_t _size468;
            ::apache::thrift::protocol::TType _etype471;
            xfer += iprot->readListBegin(_etype471, _size468);
            this->group_by_list.resize(_size468);
            uint32_t _i472;
            for (_i472 = 0; _i472 < _size468; ++_i472)
            {
              xfer += this->group_by_list[_i472].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.group_by_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->having_expr.read(iprot);
          this->__isset.having_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->limit_expr.read(iprot);
          this->__isset.limit_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->offset_expr.read(iprot);
          this->__isset.offset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->order_by_list.clear();
            uint32_t _size473;
            ::apache::thrift::protocol::TType _etype476;
            xfer += iprot->readListBegin(_etype476, _size473);
            this->order_by_list.resize(_size473);
            uint32_t _i477;
            for (_i477 = 0; _i477 < _size473; ++_i477)
            {
              xfer += this->order_by_list[_i477].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.order_by_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->total_hits_count);
          this->__isset.total_hits_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SelectRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SelectRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_list", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->select_list.size()));
    std::vector<ParsedExpr> ::const_iterator _iter478;
    for (_iter478 = this->select_list.begin(); _iter478 != this->select_list.end(); ++_iter478)
    {
      xfer += (*_iter478).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.highlight_list) {
    xfer += oprot->writeFieldBegin("highlight_list", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->highlight_list.size()));
      std::vector<ParsedExpr> ::const_iterator _iter479;
      for (_iter479 = this->highlight_list.begin(); _iter479 != this->highlight_list.end(); ++_iter479)
      {
        xfer += (*_iter479).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.search_expr) {
    xfer += oprot->writeFieldBegin("search_expr", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->search_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.where_expr) {
    xfer += oprot->writeFieldBegin("where_expr", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->where_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_by_list) {
    xfer += oprot->writeFieldBegin("group_by_list", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->group_by_list.size()));
      std::vector<ParsedExpr> ::const_iterator _iter480;
      for (_iter480 = this->group_by_list.begin(); _iter480 != this->group_by_list.end(); ++_iter480)
      {
        xfer += (*_iter480).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.having_expr) {
    xfer += oprot->writeFieldBegin("having_expr", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->having_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit_expr) {
    xfer += oprot->writeFieldBegin("limit_expr", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->limit_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset_expr) {
    xfer += oprot->writeFieldBegin("offset_expr", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->offset_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order_by_list) {
    xfer += oprot->writeFieldBegin("order_by_list", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->order_by_list.size()));
      std::vector<OrderByExpr> ::const_iterator _iter481;
      for (_iter481 = this->order_by_list.begin(); _iter481 != this->order_by_list.end(); ++_iter481)
      {
        xfer += (*_iter481).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.total_hits_count) {
    xfer += oprot->writeFieldBegin("total_hits_count", ::apache::thrift::protocol::T_BOOL, 13);
    xfer += oprot->writeBool(this->total_hits_count);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SelectRequest &a, SelectRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.select_list, b.select_list);
  swap(a.highlight_list, b.highlight_list);
  swap(a.search_expr, b.search_expr);
  swap(a.where_expr, b.where_expr);
  swap(a.group_by_list, b.group_by_list);
  swap(a.having_expr, b.having_expr);
  swap(a.limit_expr, b.limit_expr);
  swap(a.offset_expr, b.offset_expr);
  swap(a.order_by_list, b.order_by_list);
  swap(a.total_hits_count, b.total_hits_count);
  swap(a.__isset, b.__isset);
}

SelectRequest::SelectRequest(const SelectRequest& other482) {
  session_id = other482.session_id;
  db_name = other482.db_name;
  table_name = other482.table_name;
  select_list = other482.select_list;
  highlight_list = other482.highlight_list;
  search_expr = other482.search_expr;
  where_expr = other482.where_expr;
  group_by_list = other482.group_by_list;
  having_expr = other482.having_expr;
  limit_expr = other482.limit_expr;
  offset_expr = other482.offset_expr;
  order_by_list = other482.order_by_list;
  total_hits_count = other482.total_hits_count;
  __isset = other482.__isset;
}
SelectRequest& SelectRequest::operator=(const SelectRequest& other483) {
  session_id = other483.session_id;
  db_name = other483.db_name;
  table_name = other483.table_name;
  select_list = other483.select_list;
  highlight_list = other483.highlight_list;
  search_expr = other483.search_expr;
  where_expr = other483.where_expr;
  group_by_list = other483.group_by_list;
  having_expr = other483.having_expr;
  limit_expr = other483.limit_expr;
  offset_expr = other483.offset_expr;
  order_by_list = other483.order_by_list;
  total_hits_count = other483.total_hits_count;
  __isset = other483.__isset;
  return *this;
}
void SelectRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SelectRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "select_list=" << to_string(select_list);
  out << ", " << "highlight_list="; (__isset.highlight_list ? (out << to_string(highlight_list)) : (out << "<null>"));
  out << ", " << "search_expr="; (__isset.search_expr ? (out << to_string(search_expr)) : (out << "<null>"));
  out << ", " << "where_expr="; (__isset.where_expr ? (out << to_string(where_expr)) : (out << "<null>"));
  out << ", " << "group_by_list="; (__isset.group_by_list ? (out << to_string(group_by_list)) : (out << "<null>"));
  out << ", " << "having_expr="; (__isset.having_expr ? (out << to_string(having_expr)) : (out << "<null>"));
  out << ", " << "limit_expr="; (__isset.limit_expr ? (out << to_string(limit_expr)) : (out << "<null>"));
  out << ", " << "offset_expr="; (__isset.offset_expr ? (out << to_string(offset_expr)) : (out << "<null>"));
  out << ", " << "order_by_list="; (__isset.order_by_list ? (out << to_string(order_by_list)) : (out << "<null>"));
  out << ", " << "total_hits_count="; (__isset.total_hits_count ? (out << to_string(total_hits_count)) : (out << "<null>"));
  out << ")";
}


SelectResponse::~SelectResponse() noexcept {
}


void SelectResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void SelectResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void SelectResponse::__set_column_defs(const std::vector<ColumnDef> & val) {
  this->column_defs = val;
}

void SelectResponse::__set_column_fields(const std::vector<ColumnField> & val) {
  this->column_fields = val;
}

void SelectResponse::__set_extra_result(const std::string& val) {
  this->extra_result = val;
}
std::ostream& operator<<(std::ostream& out, const SelectResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SelectResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_defs.clear();
            uint32_t _size484;
            ::apache::thrift::protocol::TType _etype487;
            xfer += iprot->readListBegin(_etype487, _size484);
            this->column_defs.resize(_size484);
            uint32_t _i488;
            for (_i488 = 0; _i488 < _size484; ++_i488)
            {
              xfer += this->column_defs[_i488].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_fields.clear();
            uint32_t _size489;
            ::apache::thrift::protocol::TType _etype492;
            xfer += iprot->readListBegin(_etype492, _size489);
            this->column_fields.resize(_size489);
            uint32_t _i493;
            for (_i493 = 0; _i493 < _size489; ++_i493)
            {
              xfer += this->column_fields[_i493].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->extra_result);
          this->__isset.extra_result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SelectResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SelectResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_defs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_defs.size()));
    std::vector<ColumnDef> ::const_iterator _iter494;
    for (_iter494 = this->column_defs.begin(); _iter494 != this->column_defs.end(); ++_iter494)
    {
      xfer += (*_iter494).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_fields.size()));
    std::vector<ColumnField> ::const_iterator _iter495;
    for (_iter495 = this->column_fields.begin(); _iter495 != this->column_fields.end(); ++_iter495)
    {
      xfer += (*_iter495).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra_result", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->extra_result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SelectResponse &a, SelectResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.column_defs, b.column_defs);
  swap(a.column_fields, b.column_fields);
  swap(a.extra_result, b.extra_result);
  swap(a.__isset, b.__isset);
}

SelectResponse::SelectResponse(const SelectResponse& other496) {
  error_code = other496.error_code;
  error_msg = other496.error_msg;
  column_defs = other496.column_defs;
  column_fields = other496.column_fields;
  extra_result = other496.extra_result;
  __isset = other496.__isset;
}
SelectResponse& SelectResponse::operator=(const SelectResponse& other497) {
  error_code = other497.error_code;
  error_msg = other497.error_msg;
  column_defs = other497.column_defs;
  column_fields = other497.column_fields;
  extra_result = other497.extra_result;
  __isset = other497.__isset;
  return *this;
}
void SelectResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SelectResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "column_defs=" << to_string(column_defs);
  out << ", " << "column_fields=" << to_string(column_fields);
  out << ", " << "extra_result=" << to_string(extra_result);
  out << ")";
}


DeleteRequest::~DeleteRequest() noexcept {
}


void DeleteRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DeleteRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DeleteRequest::__set_where_expr(const ParsedExpr& val) {
  this->where_expr = val;
}

void DeleteRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const DeleteRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeleteRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->where_expr.read(iprot);
          this->__isset.where_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeleteRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeleteRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("where_expr", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->where_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeleteRequest &a, DeleteRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.where_expr, b.where_expr);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

DeleteRequest::DeleteRequest(const DeleteRequest& other498) {
  db_name = other498.db_name;
  table_name = other498.table_name;
  where_expr = other498.where_expr;
  session_id = other498.session_id;
  __isset = other498.__isset;
}
DeleteRequest& DeleteRequest::operator=(const DeleteRequest& other499) {
  db_name = other499.db_name;
  table_name = other499.table_name;
  where_expr = other499.where_expr;
  session_id = other499.session_id;
  __isset = other499.__isset;
  return *this;
}
void DeleteRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeleteRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "where_expr=" << to_string(where_expr);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


DeleteResponse::~DeleteResponse() noexcept {
}


void DeleteResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void DeleteResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void DeleteResponse::__set_deleted_rows(const int64_t val) {
  this->deleted_rows = val;
}
std::ostream& operator<<(std::ostream& out, const DeleteResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeleteResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->deleted_rows);
          this->__isset.deleted_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeleteResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeleteResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("deleted_rows", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->deleted_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeleteResponse &a, DeleteResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.deleted_rows, b.deleted_rows);
  swap(a.__isset, b.__isset);
}

DeleteResponse::DeleteResponse(const DeleteResponse& other500) {
  error_code = other500.error_code;
  error_msg = other500.error_msg;
  deleted_rows = other500.deleted_rows;
  __isset = other500.__isset;
}
DeleteResponse& DeleteResponse::operator=(const DeleteResponse& other501) {
  error_code = other501.error_code;
  error_msg = other501.error_msg;
  deleted_rows = other501.deleted_rows;
  __isset = other501.__isset;
  return *this;
}
void DeleteResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeleteResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "deleted_rows=" << to_string(deleted_rows);
  out << ")";
}


UpdateRequest::~UpdateRequest() noexcept {
}


void UpdateRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void UpdateRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void UpdateRequest::__set_where_expr(const ParsedExpr& val) {
  this->where_expr = val;
}

void UpdateRequest::__set_update_expr_array(const std::vector<UpdateExpr> & val) {
  this->update_expr_array = val;
}

void UpdateRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const UpdateRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UpdateRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->where_expr.read(iprot);
          this->__isset.where_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->update_expr_array.clear();
            uint32_t _size502;
            ::apache::thrift::protocol::TType _etype505;
            xfer += iprot->readListBegin(_etype505, _size502);
            this->update_expr_array.resize(_size502);
            uint32_t _i506;
            for (_i506 = 0; _i506 < _size502; ++_i506)
            {
              xfer += this->update_expr_array[_i506].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.update_expr_array = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("where_expr", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->where_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_expr_array", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->update_expr_array.size()));
    std::vector<UpdateExpr> ::const_iterator _iter507;
    for (_iter507 = this->update_expr_array.begin(); _iter507 != this->update_expr_array.end(); ++_iter507)
    {
      xfer += (*_iter507).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateRequest &a, UpdateRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.where_expr, b.where_expr);
  swap(a.update_expr_array, b.update_expr_array);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

UpdateRequest::UpdateRequest(const UpdateRequest& other508) {
  db_name = other508.db_name;
  table_name = other508.table_name;
  where_expr = other508.where_expr;
  update_expr_array = other508.update_expr_array;
  session_id = other508.session_id;
  __isset = other508.__isset;
}
UpdateRequest& UpdateRequest::operator=(const UpdateRequest& other509) {
  db_name = other509.db_name;
  table_name = other509.table_name;
  where_expr = other509.where_expr;
  update_expr_array = other509.update_expr_array;
  session_id = other509.session_id;
  __isset = other509.__isset;
  return *this;
}
void UpdateRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "where_expr=" << to_string(where_expr);
  out << ", " << "update_expr_array=" << to_string(update_expr_array);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


AddColumnsRequest::~AddColumnsRequest() noexcept {
}


void AddColumnsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void AddColumnsRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void AddColumnsRequest::__set_column_defs(const std::vector<ColumnDef> & val) {
  this->column_defs = val;
}

void AddColumnsRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const AddColumnsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t AddColumnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_defs.clear();
            uint32_t _size510;
            ::apache::thrift::protocol::TType _etype513;
            xfer += iprot->readListBegin(_etype513, _size510);
            this->column_defs.resize(_size510);
            uint32_t _i514;
            for (_i514 = 0; _i514 < _size510; ++_i514)
            {
              xfer += this->column_defs[_i514].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AddColumnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AddColumnsRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_defs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_defs.size()));
    std::vector<ColumnDef> ::const_iterator _iter515;
    for (_iter515 = this->column_defs.begin(); _iter515 != this->column_defs.end(); ++_iter515)
    {
      xfer += (*_iter515).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AddColumnsRequest &a, AddColumnsRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.column_defs, b.column_defs);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

AddColumnsRequest::AddColumnsRequest(const AddColumnsRequest& other516) {
  db_name = other516.db_name;
  table_name = other516.table_name;
  column_defs = other516.column_defs;
  session_id = other516.session_id;
  __isset = other516.__isset;
}
AddColumnsRequest& AddColumnsRequest::operator=(const AddColumnsRequest& other517) {
  db_name = other517.db_name;
  table_name = other517.table_name;
  column_defs = other517.column_defs;
  session_id = other517.session_id;
  __isset = other517.__isset;
  return *this;
}
void AddColumnsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AddColumnsRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_defs=" << to_string(column_defs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


DropColumnsRequest::~DropColumnsRequest() noexcept {
}


void DropColumnsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DropColumnsRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DropColumnsRequest::__set_column_names(const std::vector<std::string> & val) {
  this->column_names = val;
}

void DropColumnsRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const DropColumnsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropColumnsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_names.clear();
            uint32_t _size518;
            ::apache::thrift::protocol::TType _etype521;
            xfer += iprot->readListBegin(_etype521, _size518);
            this->column_names.resize(_size518);
            uint32_t _i522;
            for (_i522 = 0; _i522 < _size518; ++_i522)
            {
              xfer += iprot->readString(this->column_names[_i522]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropColumnsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropColumnsRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_names.size()));
    std::vector<std::string> ::const_iterator _iter523;
    for (_iter523 = this->column_names.begin(); _iter523 != this->column_names.end(); ++_iter523)
    {
      xfer += oprot->writeString((*_iter523));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropColumnsRequest &a, DropColumnsRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.column_names, b.column_names);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

DropColumnsRequest::DropColumnsRequest(const DropColumnsRequest& other524) {
  db_name = other524.db_name;
  table_name = other524.table_name;
  column_names = other524.column_names;
  session_id = other524.session_id;
  __isset = other524.__isset;
}
DropColumnsRequest& DropColumnsRequest::operator=(const DropColumnsRequest& other525) {
  db_name = other525.db_name;
  table_name = other525.table_name;
  column_names = other525.column_names;
  session_id = other525.session_id;
  __isset = other525.__isset;
  return *this;
}
void DropColumnsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropColumnsRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_names=" << to_string(column_names);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


DumpIndexRequest::~DumpIndexRequest() noexcept {
}


void DumpIndexRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DumpIndexRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DumpIndexRequest::__set_index_name(const std::string& val) {
  this->index_name = val;
}

void DumpIndexRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const DumpIndexRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DumpIndexRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DumpIndexRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DumpIndexRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DumpIndexRequest &a, DumpIndexRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.index_name, b.index_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

DumpIndexRequest::DumpIndexRequest(const DumpIndexRequest& other526) {
  db_name = other526.db_name;
  table_name = other526.table_name;
  index_name = other526.index_name;
  session_id = other526.session_id;
  __isset = other526.__isset;
}
DumpIndexRequest& DumpIndexRequest::operator=(const DumpIndexRequest& other527) {
  db_name = other527.db_name;
  table_name = other527.table_name;
  index_name = other527.index_name;
  session_id = other527.session_id;
  __isset = other527.__isset;
  return *this;
}
void DumpIndexRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DumpIndexRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "index_name=" << to_string(index_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ShowTablesRequest::~ShowTablesRequest() noexcept {
}


void ShowTablesRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ShowTablesRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}
std::ostream& operator<<(std::ostream& out, const ShowTablesRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowTablesRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowTablesRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowTablesRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowTablesRequest &a, ShowTablesRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.__isset, b.__isset);
}

ShowTablesRequest::ShowTablesRequest(const ShowTablesRequest& other528) {
  session_id = other528.session_id;
  db_name = other528.db_name;
  __isset = other528.__isset;
}
ShowTablesRequest& ShowTablesRequest::operator=(const ShowTablesRequest& other529) {
  session_id = other529.session_id;
  db_name = other529.db_name;
  __isset = other529.__isset;
  return *this;
}
void ShowTablesRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowTablesRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ")";
}


ShowSegmentsRequest::~ShowSegmentsRequest() noexcept {
}


void ShowSegmentsRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ShowSegmentsRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowSegmentsRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}
std::ostream& operator<<(std::ostream& out, const ShowSegmentsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowSegmentsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowSegmentsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowSegmentsRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowSegmentsRequest &a, ShowSegmentsRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.__isset, b.__isset);
}

ShowSegmentsRequest::ShowSegmentsRequest(const ShowSegmentsRequest& other530) {
  session_id = other530.session_id;
  db_name = other530.db_name;
  table_name = other530.table_name;
  __isset = other530.__isset;
}
ShowSegmentsRequest& ShowSegmentsRequest::operator=(const ShowSegmentsRequest& other531) {
  session_id = other531.session_id;
  db_name = other531.db_name;
  table_name = other531.table_name;
  __isset = other531.__isset;
  return *this;
}
void ShowSegmentsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowSegmentsRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ")";
}


ShowSegmentRequest::~ShowSegmentRequest() noexcept {
}


void ShowSegmentRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ShowSegmentRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowSegmentRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowSegmentRequest::__set_segment_id(const int64_t val) {
  this->segment_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowSegmentRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowSegmentRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->segment_id);
          this->__isset.segment_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowSegmentRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowSegmentRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("segment_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->segment_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowSegmentRequest &a, ShowSegmentRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.segment_id, b.segment_id);
  swap(a.__isset, b.__isset);
}

ShowSegmentRequest::ShowSegmentRequest(const ShowSegmentRequest& other532) {
  session_id = other532.session_id;
  db_name = other532.db_name;
  table_name = other532.table_name;
  segment_id = other532.segment_id;
  __isset = other532.__isset;
}
ShowSegmentRequest& ShowSegmentRequest::operator=(const ShowSegmentRequest& other533) {
  session_id = other533.session_id;
  db_name = other533.db_name;
  table_name = other533.table_name;
  segment_id = other533.segment_id;
  __isset = other533.__isset;
  return *this;
}
void ShowSegmentRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowSegmentRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "segment_id=" << to_string(segment_id);
  out << ")";
}


ShowSegmentResponse::~ShowSegmentResponse() noexcept {
}


void ShowSegmentResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ShowSegmentResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ShowSegmentResponse::__set_segment_id(const int64_t val) {
  this->segment_id = val;
}

void ShowSegmentResponse::__set_status(const std::string& val) {
  this->status = val;
}

void ShowSegmentResponse::__set_path(const std::string& val) {
  this->path = val;
}

void ShowSegmentResponse::__set_size(const std::string& val) {
  this->size = val;
}

void ShowSegmentResponse::__set_block_count(const int64_t val) {
  this->block_count = val;
}

void ShowSegmentResponse::__set_row_capacity(const int64_t val) {
  this->row_capacity = val;
}

void ShowSegmentResponse::__set_row_count(const int64_t val) {
  this->row_count = val;
}

void ShowSegmentResponse::__set_room(const int64_t val) {
  this->room = val;
}

void ShowSegmentResponse::__set_column_count(const int64_t val) {
  this->column_count = val;
}
std::ostream& operator<<(std::ostream& out, const ShowSegmentResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowSegmentResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->segment_id);
          this->__isset.segment_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->block_count);
          this->__isset.block_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_capacity);
          this->__isset.row_capacity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_count);
          this->__isset.row_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->room);
          this->__isset.room = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->column_count);
          this->__isset.column_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowSegmentResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowSegmentResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("segment_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->segment_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_count", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->block_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_capacity", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->row_capacity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_count", ::apache::thrift::protocol::T_I64, 9);
  xfer += oprot->writeI64(this->row_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("room", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->room);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_count", ::apache::thrift::protocol::T_I64, 11);
  xfer += oprot->writeI64(this->column_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowSegmentResponse &a, ShowSegmentResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.segment_id, b.segment_id);
  swap(a.status, b.status);
  swap(a.path, b.path);
  swap(a.size, b.size);
  swap(a.block_count, b.block_count);
  swap(a.row_capacity, b.row_capacity);
  swap(a.row_count, b.row_count);
  swap(a.room, b.room);
  swap(a.column_count, b.column_count);
  swap(a.__isset, b.__isset);
}

ShowSegmentResponse::ShowSegmentResponse(const ShowSegmentResponse& other534) {
  error_code = other534.error_code;
  error_msg = other534.error_msg;
  segment_id = other534.segment_id;
  status = other534.status;
  path = other534.path;
  size = other534.size;
  block_count = other534.block_count;
  row_capacity = other534.row_capacity;
  row_count = other534.row_count;
  room = other534.room;
  column_count = other534.column_count;
  __isset = other534.__isset;
}
ShowSegmentResponse& ShowSegmentResponse::operator=(const ShowSegmentResponse& other535) {
  error_code = other535.error_code;
  error_msg = other535.error_msg;
  segment_id = other535.segment_id;
  status = other535.status;
  path = other535.path;
  size = other535.size;
  block_count = other535.block_count;
  row_capacity = other535.row_capacity;
  row_count = other535.row_count;
  room = other535.room;
  column_count = other535.column_count;
  __isset = other535.__isset;
  return *this;
}
void ShowSegmentResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowSegmentResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "segment_id=" << to_string(segment_id);
  out << ", " << "status=" << to_string(status);
  out << ", " << "path=" << to_string(path);
  out << ", " << "size=" << to_string(size);
  out << ", " << "block_count=" << to_string(block_count);
  out << ", " << "row_capacity=" << to_string(row_capacity);
  out << ", " << "row_count=" << to_string(row_count);
  out << ", " << "room=" << to_string(room);
  out << ", " << "column_count=" << to_string(column_count);
  out << ")";
}


ShowBlocksRequest::~ShowBlocksRequest() noexcept {
}


void ShowBlocksRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ShowBlocksRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowBlocksRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowBlocksRequest::__set_segment_id(const int64_t val) {
  this->segment_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowBlocksRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowBlocksRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->segment_id);
          this->__isset.segment_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowBlocksRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowBlocksRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("segment_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->segment_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowBlocksRequest &a, ShowBlocksRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.segment_id, b.segment_id);
  swap(a.__isset, b.__isset);
}

ShowBlocksRequest::ShowBlocksRequest(const ShowBlocksRequest& other536) {
  session_id = other536.session_id;
  db_name = other536.db_name;
  table_name = other536.table_name;
  segment_id = other536.segment_id;
  __isset = other536.__isset;
}
ShowBlocksRequest& ShowBlocksRequest::operator=(const ShowBlocksRequest& other537) {
  session_id = other537.session_id;
  db_name = other537.db_name;
  table_name = other537.table_name;
  segment_id = other537.segment_id;
  __isset = other537.__isset;
  return *this;
}
void ShowBlocksRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowBlocksRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "segment_id=" << to_string(segment_id);
  out << ")";
}


ShowBlockRequest::~ShowBlockRequest() noexcept {
}


void ShowBlockRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ShowBlockRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowBlockRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowBlockRequest::__set_segment_id(const int64_t val) {
  this->segment_id = val;
}

void ShowBlockRequest::__set_block_id(const int64_t val) {
  this->block_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowBlockRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowBlockRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->segment_id);
          this->__isset.segment_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->block_id);
          this->__isset.block_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowBlockRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowBlockRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("segment_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->segment_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->block_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowBlockRequest &a, ShowBlockRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.segment_id, b.segment_id);
  swap(a.block_id, b.block_id);
  swap(a.__isset, b.__isset);
}

ShowBlockRequest::ShowBlockRequest(const ShowBlockRequest& other538) {
  session_id = other538.session_id;
  db_name = other538.db_name;
  table_name = other538.table_name;
  segment_id = other538.segment_id;
  block_id = other538.block_id;
  __isset = other538.__isset;
}
ShowBlockRequest& ShowBlockRequest::operator=(const ShowBlockRequest& other539) {
  session_id = other539.session_id;
  db_name = other539.db_name;
  table_name = other539.table_name;
  segment_id = other539.segment_id;
  block_id = other539.block_id;
  __isset = other539.__isset;
  return *this;
}
void ShowBlockRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowBlockRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "segment_id=" << to_string(segment_id);
  out << ", " << "block_id=" << to_string(block_id);
  out << ")";
}


ShowBlockResponse::~ShowBlockResponse() noexcept {
}


void ShowBlockResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ShowBlockResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ShowBlockResponse::__set_block_id(const int64_t val) {
  this->block_id = val;
}

void ShowBlockResponse::__set_path(const std::string& val) {
  this->path = val;
}

void ShowBlockResponse::__set_size(const std::string& val) {
  this->size = val;
}

void ShowBlockResponse::__set_row_capacity(const int64_t val) {
  this->row_capacity = val;
}

void ShowBlockResponse::__set_row_count(const int64_t val) {
  this->row_count = val;
}

void ShowBlockResponse::__set_column_count(const int64_t val) {
  this->column_count = val;
}
std::ostream& operator<<(std::ostream& out, const ShowBlockResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowBlockResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->block_id);
          this->__isset.block_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_capacity);
          this->__isset.row_capacity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->row_count);
          this->__isset.row_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->column_count);
          this->__isset.column_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowBlockResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowBlockResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->block_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_capacity", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->row_capacity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("row_count", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->row_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_count", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->column_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowBlockResponse &a, ShowBlockResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.block_id, b.block_id);
  swap(a.path, b.path);
  swap(a.size, b.size);
  swap(a.row_capacity, b.row_capacity);
  swap(a.row_count, b.row_count);
  swap(a.column_count, b.column_count);
  swap(a.__isset, b.__isset);
}

ShowBlockResponse::ShowBlockResponse(const ShowBlockResponse& other540) {
  error_code = other540.error_code;
  error_msg = other540.error_msg;
  block_id = other540.block_id;
  path = other540.path;
  size = other540.size;
  row_capacity = other540.row_capacity;
  row_count = other540.row_count;
  column_count = other540.column_count;
  __isset = other540.__isset;
}
ShowBlockResponse& ShowBlockResponse::operator=(const ShowBlockResponse& other541) {
  error_code = other541.error_code;
  error_msg = other541.error_msg;
  block_id = other541.block_id;
  path = other541.path;
  size = other541.size;
  row_capacity = other541.row_capacity;
  row_count = other541.row_count;
  column_count = other541.column_count;
  __isset = other541.__isset;
  return *this;
}
void ShowBlockResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowBlockResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "block_id=" << to_string(block_id);
  out << ", " << "path=" << to_string(path);
  out << ", " << "size=" << to_string(size);
  out << ", " << "row_capacity=" << to_string(row_capacity);
  out << ", " << "row_count=" << to_string(row_count);
  out << ", " << "column_count=" << to_string(column_count);
  out << ")";
}


ShowBlockColumnRequest::~ShowBlockColumnRequest() noexcept {
}


void ShowBlockColumnRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ShowBlockColumnRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ShowBlockColumnRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ShowBlockColumnRequest::__set_segment_id(const int64_t val) {
  this->segment_id = val;
}

void ShowBlockColumnRequest::__set_block_id(const int64_t val) {
  this->block_id = val;
}

void ShowBlockColumnRequest::__set_column_id(const int64_t val) {
  this->column_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowBlockColumnRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowBlockColumnRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->segment_id);
          this->__isset.segment_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->block_id);
          this->__isset.block_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->column_id);
          this->__isset.column_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowBlockColumnRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowBlockColumnRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("segment_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->segment_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("block_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->block_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_id", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->column_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowBlockColumnRequest &a, ShowBlockColumnRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.segment_id, b.segment_id);
  swap(a.block_id, b.block_id);
  swap(a.column_id, b.column_id);
  swap(a.__isset, b.__isset);
}

ShowBlockColumnRequest::ShowBlockColumnRequest(const ShowBlockColumnRequest& other542) {
  session_id = other542.session_id;
  db_name = other542.db_name;
  table_name = other542.table_name;
  segment_id = other542.segment_id;
  block_id = other542.block_id;
  column_id = other542.column_id;
  __isset = other542.__isset;
}
ShowBlockColumnRequest& ShowBlockColumnRequest::operator=(const ShowBlockColumnRequest& other543) {
  session_id = other543.session_id;
  db_name = other543.db_name;
  table_name = other543.table_name;
  segment_id = other543.segment_id;
  block_id = other543.block_id;
  column_id = other543.column_id;
  __isset = other543.__isset;
  return *this;
}
void ShowBlockColumnRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowBlockColumnRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "segment_id=" << to_string(segment_id);
  out << ", " << "block_id=" << to_string(block_id);
  out << ", " << "column_id=" << to_string(column_id);
  out << ")";
}


ShowBlockColumnResponse::~ShowBlockColumnResponse() noexcept {
}


void ShowBlockColumnResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ShowBlockColumnResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ShowBlockColumnResponse::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void ShowBlockColumnResponse::__set_column_id(const int64_t val) {
  this->column_id = val;
}

void ShowBlockColumnResponse::__set_data_type(const std::string& val) {
  this->data_type = val;
}

void ShowBlockColumnResponse::__set_path(const std::string& val) {
  this->path = val;
}

void ShowBlockColumnResponse::__set_extra_file_count(const int64_t val) {
  this->extra_file_count = val;
}

void ShowBlockColumnResponse::__set_extra_file_names(const std::string& val) {
  this->extra_file_names = val;
}
std::ostream& operator<<(std::ostream& out, const ShowBlockColumnResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowBlockColumnResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->column_id);
          this->__isset.column_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data_type);
          this->__isset.data_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->extra_file_count);
          this->__isset.extra_file_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->extra_file_names);
          this->__isset.extra_file_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowBlockColumnResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowBlockColumnResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->column_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_type", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->data_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra_file_count", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->extra_file_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra_file_names", ::apache::thrift::protocol::T_STRING, 8);
  xfer += oprot->writeString(this->extra_file_names);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowBlockColumnResponse &a, ShowBlockColumnResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.column_name, b.column_name);
  swap(a.column_id, b.column_id);
  swap(a.data_type, b.data_type);
  swap(a.path, b.path);
  swap(a.extra_file_count, b.extra_file_count);
  swap(a.extra_file_names, b.extra_file_names);
  swap(a.__isset, b.__isset);
}

ShowBlockColumnResponse::ShowBlockColumnResponse(const ShowBlockColumnResponse& other544) {
  error_code = other544.error_code;
  error_msg = other544.error_msg;
  column_name = other544.column_name;
  column_id = other544.column_id;
  data_type = other544.data_type;
  path = other544.path;
  extra_file_count = other544.extra_file_count;
  extra_file_names = other544.extra_file_names;
  __isset = other544.__isset;
}
ShowBlockColumnResponse& ShowBlockColumnResponse::operator=(const ShowBlockColumnResponse& other545) {
  error_code = other545.error_code;
  error_msg = other545.error_msg;
  column_name = other545.column_name;
  column_id = other545.column_id;
  data_type = other545.data_type;
  path = other545.path;
  extra_file_count = other545.extra_file_count;
  extra_file_names = other545.extra_file_names;
  __isset = other545.__isset;
  return *this;
}
void ShowBlockColumnResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowBlockColumnResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "column_name=" << to_string(column_name);
  out << ", " << "column_id=" << to_string(column_id);
  out << ", " << "data_type=" << to_string(data_type);
  out << ", " << "path=" << to_string(path);
  out << ", " << "extra_file_count=" << to_string(extra_file_count);
  out << ", " << "extra_file_names=" << to_string(extra_file_names);
  out << ")";
}


ShowCurrentNodeRequest::~ShowCurrentNodeRequest() noexcept {
}


void ShowCurrentNodeRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ShowCurrentNodeRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCurrentNodeRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowCurrentNodeRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCurrentNodeRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCurrentNodeRequest &a, ShowCurrentNodeRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ShowCurrentNodeRequest::ShowCurrentNodeRequest(const ShowCurrentNodeRequest& other546) noexcept {
  session_id = other546.session_id;
  __isset = other546.__isset;
}
ShowCurrentNodeRequest& ShowCurrentNodeRequest::operator=(const ShowCurrentNodeRequest& other547) noexcept {
  session_id = other547.session_id;
  __isset = other547.__isset;
  return *this;
}
void ShowCurrentNodeRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCurrentNodeRequest(";
  out << "session_id=" << to_string(session_id);
  out << ")";
}


ShowCurrentNodeResponse::~ShowCurrentNodeResponse() noexcept {
}


void ShowCurrentNodeResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ShowCurrentNodeResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ShowCurrentNodeResponse::__set_node_role(const std::string& val) {
  this->node_role = val;
}

void ShowCurrentNodeResponse::__set_server_status(const std::string& val) {
  this->server_status = val;
}
std::ostream& operator<<(std::ostream& out, const ShowCurrentNodeResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowCurrentNodeResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->node_role);
          this->__isset.node_role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->server_status);
          this->__isset.server_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowCurrentNodeResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowCurrentNodeResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("node_role", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->node_role);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("server_status", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->server_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowCurrentNodeResponse &a, ShowCurrentNodeResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.node_role, b.node_role);
  swap(a.server_status, b.server_status);
  swap(a.__isset, b.__isset);
}

ShowCurrentNodeResponse::ShowCurrentNodeResponse(const ShowCurrentNodeResponse& other548) {
  error_code = other548.error_code;
  error_msg = other548.error_msg;
  node_role = other548.node_role;
  server_status = other548.server_status;
  __isset = other548.__isset;
}
ShowCurrentNodeResponse& ShowCurrentNodeResponse::operator=(const ShowCurrentNodeResponse& other549) {
  error_code = other549.error_code;
  error_msg = other549.error_msg;
  node_role = other549.node_role;
  server_status = other549.server_status;
  __isset = other549.__isset;
  return *this;
}
void ShowCurrentNodeResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowCurrentNodeResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "node_role=" << to_string(node_role);
  out << ", " << "server_status=" << to_string(server_status);
  out << ")";
}


CommandRequest::~CommandRequest() noexcept {
}


void CommandRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CommandRequest::__set_command_type(const std::string& val) {
  this->command_type = val;
}

void CommandRequest::__set_test_command_content(const std::string& val) {
  this->test_command_content = val;
}
std::ostream& operator<<(std::ostream& out, const CommandRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommandRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->command_type);
          this->__isset.command_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->test_command_content);
          this->__isset.test_command_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommandRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommandRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("command_type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->command_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("test_command_content", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->test_command_content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommandRequest &a, CommandRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.command_type, b.command_type);
  swap(a.test_command_content, b.test_command_content);
  swap(a.__isset, b.__isset);
}

CommandRequest::CommandRequest(const CommandRequest& other550) {
  session_id = other550.session_id;
  command_type = other550.command_type;
  test_command_content = other550.test_command_content;
  __isset = other550.__isset;
}
CommandRequest& CommandRequest::operator=(const CommandRequest& other551) {
  session_id = other551.session_id;
  command_type = other551.command_type;
  test_command_content = other551.test_command_content;
  __isset = other551.__isset;
  return *this;
}
void CommandRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommandRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "command_type=" << to_string(command_type);
  out << ", " << "test_command_content=" << to_string(test_command_content);
  out << ")";
}


FlushRequest::~FlushRequest() noexcept {
}


void FlushRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void FlushRequest::__set_flush_type(const std::string& val) {
  this->flush_type = val;
}
std::ostream& operator<<(std::ostream& out, const FlushRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FlushRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->flush_type);
          this->__isset.flush_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FlushRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FlushRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flush_type", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->flush_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FlushRequest &a, FlushRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.flush_type, b.flush_type);
  swap(a.__isset, b.__isset);
}

FlushRequest::FlushRequest(const FlushRequest& other552) {
  session_id = other552.session_id;
  flush_type = other552.flush_type;
  __isset = other552.__isset;
}
FlushRequest& FlushRequest::operator=(const FlushRequest& other553) {
  session_id = other553.session_id;
  flush_type = other553.flush_type;
  __isset = other553.__isset;
  return *this;
}
void FlushRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FlushRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "flush_type=" << to_string(flush_type);
  out << ")";
}


CompactRequest::~CompactRequest() noexcept {
}


void CompactRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CompactRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CompactRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}
std::ostream& operator<<(std::ostream& out, const CompactRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactRequest &a, CompactRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.__isset, b.__isset);
}

CompactRequest::CompactRequest(const CompactRequest& other554) {
  session_id = other554.session_id;
  db_name = other554.db_name;
  table_name = other554.table_name;
  __isset = other554.__isset;
}
CompactRequest& CompactRequest::operator=(const CompactRequest& other555) {
  session_id = other555.session_id;
  db_name = other555.db_name;
  table_name = other555.table_name;
  __isset = other555.__isset;
  return *this;
}
void CompactRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ")";
}


CreateTableSnapshotRequest::~CreateTableSnapshotRequest() noexcept {
}


void CreateTableSnapshotRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateTableSnapshotRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CreateTableSnapshotRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void CreateTableSnapshotRequest::__set_snapshot_name(const std::string& val) {
  this->snapshot_name = val;
}
std::ostream& operator<<(std::ostream& out, const CreateTableSnapshotRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateTableSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_name);
          this->__isset.snapshot_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateTableSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateTableSnapshotRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->snapshot_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateTableSnapshotRequest &a, CreateTableSnapshotRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.snapshot_name, b.snapshot_name);
  swap(a.__isset, b.__isset);
}

CreateTableSnapshotRequest::CreateTableSnapshotRequest(const CreateTableSnapshotRequest& other556) {
  session_id = other556.session_id;
  db_name = other556.db_name;
  table_name = other556.table_name;
  snapshot_name = other556.snapshot_name;
  __isset = other556.__isset;
}
CreateTableSnapshotRequest& CreateTableSnapshotRequest::operator=(const CreateTableSnapshotRequest& other557) {
  session_id = other557.session_id;
  db_name = other557.db_name;
  table_name = other557.table_name;
  snapshot_name = other557.snapshot_name;
  __isset = other557.__isset;
  return *this;
}
void CreateTableSnapshotRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateTableSnapshotRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "snapshot_name=" << to_string(snapshot_name);
  out << ")";
}


CreateDatabaseSnapshotRequest::~CreateDatabaseSnapshotRequest() noexcept {
}


void CreateDatabaseSnapshotRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateDatabaseSnapshotRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CreateDatabaseSnapshotRequest::__set_snapshot_name(const std::string& val) {
  this->snapshot_name = val;
}
std::ostream& operator<<(std::ostream& out, const CreateDatabaseSnapshotRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateDatabaseSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_name);
          this->__isset.snapshot_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateDatabaseSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateDatabaseSnapshotRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->snapshot_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateDatabaseSnapshotRequest &a, CreateDatabaseSnapshotRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.snapshot_name, b.snapshot_name);
  swap(a.__isset, b.__isset);
}

CreateDatabaseSnapshotRequest::CreateDatabaseSnapshotRequest(const CreateDatabaseSnapshotRequest& other558) {
  session_id = other558.session_id;
  db_name = other558.db_name;
  snapshot_name = other558.snapshot_name;
  __isset = other558.__isset;
}
CreateDatabaseSnapshotRequest& CreateDatabaseSnapshotRequest::operator=(const CreateDatabaseSnapshotRequest& other559) {
  session_id = other559.session_id;
  db_name = other559.db_name;
  snapshot_name = other559.snapshot_name;
  __isset = other559.__isset;
  return *this;
}
void CreateDatabaseSnapshotRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateDatabaseSnapshotRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "snapshot_name=" << to_string(snapshot_name);
  out << ")";
}


CreateSystemSnapshotRequest::~CreateSystemSnapshotRequest() noexcept {
}


void CreateSystemSnapshotRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateSystemSnapshotRequest::__set_snapshot_name(const std::string& val) {
  this->snapshot_name = val;
}
std::ostream& operator<<(std::ostream& out, const CreateSystemSnapshotRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateSystemSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_name);
          this->__isset.snapshot_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateSystemSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateSystemSnapshotRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->snapshot_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateSystemSnapshotRequest &a, CreateSystemSnapshotRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.snapshot_name, b.snapshot_name);
  swap(a.__isset, b.__isset);
}

CreateSystemSnapshotRequest::CreateSystemSnapshotRequest(const CreateSystemSnapshotRequest& other560) {
  session_id = other560.session_id;
  snapshot_name = other560.snapshot_name;
  __isset = other560.__isset;
}
CreateSystemSnapshotRequest& CreateSystemSnapshotRequest::operator=(const CreateSystemSnapshotRequest& other561) {
  session_id = other561.session_id;
  snapshot_name = other561.snapshot_name;
  __isset = other561.__isset;
  return *this;
}
void CreateSystemSnapshotRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateSystemSnapshotRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "snapshot_name=" << to_string(snapshot_name);
  out << ")";
}


RestoreSnapshotRequest::~RestoreSnapshotRequest() noexcept {
}


void RestoreSnapshotRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void RestoreSnapshotRequest::__set_snapshot_name(const std::string& val) {
  this->snapshot_name = val;
}

void RestoreSnapshotRequest::__set_scope(const std::string& val) {
  this->scope = val;
}
std::ostream& operator<<(std::ostream& out, const RestoreSnapshotRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RestoreSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_name);
          this->__isset.snapshot_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scope);
          this->__isset.scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RestoreSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RestoreSnapshotRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->snapshot_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->scope);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RestoreSnapshotRequest &a, RestoreSnapshotRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.snapshot_name, b.snapshot_name);
  swap(a.scope, b.scope);
  swap(a.__isset, b.__isset);
}

RestoreSnapshotRequest::RestoreSnapshotRequest(const RestoreSnapshotRequest& other562) {
  session_id = other562.session_id;
  snapshot_name = other562.snapshot_name;
  scope = other562.scope;
  __isset = other562.__isset;
}
RestoreSnapshotRequest& RestoreSnapshotRequest::operator=(const RestoreSnapshotRequest& other563) {
  session_id = other563.session_id;
  snapshot_name = other563.snapshot_name;
  scope = other563.scope;
  __isset = other563.__isset;
  return *this;
}
void RestoreSnapshotRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RestoreSnapshotRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "snapshot_name=" << to_string(snapshot_name);
  out << ", " << "scope=" << to_string(scope);
  out << ")";
}


SnapshotInfo::~SnapshotInfo() noexcept {
}


void SnapshotInfo::__set_name(const std::string& val) {
  this->name = val;
}

void SnapshotInfo::__set_scope(const std::string& val) {
  this->scope = val;
}

void SnapshotInfo::__set_time(const std::string& val) {
  this->time = val;
}

void SnapshotInfo::__set_commit(const int64_t val) {
  this->commit = val;
}

void SnapshotInfo::__set_size(const std::string& val) {
  this->size = val;
}
std::ostream& operator<<(std::ostream& out, const SnapshotInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SnapshotInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->scope);
          this->__isset.scope = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->time);
          this->__isset.time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->commit);
          this->__isset.commit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->size);
          this->__isset.size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnapshotInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnapshotInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("scope", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->scope);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("commit", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->commit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnapshotInfo &a, SnapshotInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.scope, b.scope);
  swap(a.time, b.time);
  swap(a.commit, b.commit);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

SnapshotInfo::SnapshotInfo(const SnapshotInfo& other564) {
  name = other564.name;
  scope = other564.scope;
  time = other564.time;
  commit = other564.commit;
  size = other564.size;
  __isset = other564.__isset;
}
SnapshotInfo& SnapshotInfo::operator=(const SnapshotInfo& other565) {
  name = other565.name;
  scope = other565.scope;
  time = other565.time;
  commit = other565.commit;
  size = other565.size;
  __isset = other565.__isset;
  return *this;
}
void SnapshotInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnapshotInfo(";
  out << "name=" << to_string(name);
  out << ", " << "scope=" << to_string(scope);
  out << ", " << "time=" << to_string(time);
  out << ", " << "commit=" << to_string(commit);
  out << ", " << "size=" << to_string(size);
  out << ")";
}


ShowSnapshotRequest::~ShowSnapshotRequest() noexcept {
}


void ShowSnapshotRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ShowSnapshotRequest::__set_snapshot_name(const std::string& val) {
  this->snapshot_name = val;
}
std::ostream& operator<<(std::ostream& out, const ShowSnapshotRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_name);
          this->__isset.snapshot_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowSnapshotRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->snapshot_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowSnapshotRequest &a, ShowSnapshotRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.snapshot_name, b.snapshot_name);
  swap(a.__isset, b.__isset);
}

ShowSnapshotRequest::ShowSnapshotRequest(const ShowSnapshotRequest& other566) {
  session_id = other566.session_id;
  snapshot_name = other566.snapshot_name;
  __isset = other566.__isset;
}
ShowSnapshotRequest& ShowSnapshotRequest::operator=(const ShowSnapshotRequest& other567) {
  session_id = other567.session_id;
  snapshot_name = other567.snapshot_name;
  __isset = other567.__isset;
  return *this;
}
void ShowSnapshotRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowSnapshotRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "snapshot_name=" << to_string(snapshot_name);
  out << ")";
}


ShowSnapshotResponse::~ShowSnapshotResponse() noexcept {
}


void ShowSnapshotResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ShowSnapshotResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ShowSnapshotResponse::__set_snapshot(const SnapshotInfo& val) {
  this->snapshot = val;
}
std::ostream& operator<<(std::ostream& out, const ShowSnapshotResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ShowSnapshotResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->snapshot.read(iprot);
          this->__isset.snapshot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ShowSnapshotResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ShowSnapshotResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->snapshot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ShowSnapshotResponse &a, ShowSnapshotResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.snapshot, b.snapshot);
  swap(a.__isset, b.__isset);
}

ShowSnapshotResponse::ShowSnapshotResponse(const ShowSnapshotResponse& other568) {
  error_code = other568.error_code;
  error_msg = other568.error_msg;
  snapshot = other568.snapshot;
  __isset = other568.__isset;
}
ShowSnapshotResponse& ShowSnapshotResponse::operator=(const ShowSnapshotResponse& other569) {
  error_code = other569.error_code;
  error_msg = other569.error_msg;
  snapshot = other569.snapshot;
  __isset = other569.__isset;
  return *this;
}
void ShowSnapshotResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ShowSnapshotResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "snapshot=" << to_string(snapshot);
  out << ")";
}


ListSnapshotsRequest::~ListSnapshotsRequest() noexcept {
}


void ListSnapshotsRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ListSnapshotsRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListSnapshotsRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListSnapshotsRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListSnapshotsRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListSnapshotsRequest &a, ListSnapshotsRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ListSnapshotsRequest::ListSnapshotsRequest(const ListSnapshotsRequest& other570) noexcept {
  session_id = other570.session_id;
  __isset = other570.__isset;
}
ListSnapshotsRequest& ListSnapshotsRequest::operator=(const ListSnapshotsRequest& other571) noexcept {
  session_id = other571.session_id;
  __isset = other571.__isset;
  return *this;
}
void ListSnapshotsRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListSnapshotsRequest(";
  out << "session_id=" << to_string(session_id);
  out << ")";
}


ListSnapshotsResponse::~ListSnapshotsResponse() noexcept {
}


void ListSnapshotsResponse::__set_error_code(const int64_t val) {
  this->error_code = val;
}

void ListSnapshotsResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ListSnapshotsResponse::__set_snapshots(const std::vector<SnapshotInfo> & val) {
  this->snapshots = val;
}
std::ostream& operator<<(std::ostream& out, const ListSnapshotsResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListSnapshotsResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->error_code);
          this->__isset.error_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->snapshots.clear();
            uint32_t _size572;
            ::apache::thrift::protocol::TType _etype575;
            xfer += iprot->readListBegin(_etype575, _size572);
            this->snapshots.resize(_size572);
            uint32_t _i576;
            for (_i576 = 0; _i576 < _size572; ++_i576)
            {
              xfer += this->snapshots[_i576].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.snapshots = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListSnapshotsResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListSnapshotsResponse");

  xfer += oprot->writeFieldBegin("error_code", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->error_code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshots", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->snapshots.size()));
    std::vector<SnapshotInfo> ::const_iterator _iter577;
    for (_iter577 = this->snapshots.begin(); _iter577 != this->snapshots.end(); ++_iter577)
    {
      xfer += (*_iter577).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListSnapshotsResponse &a, ListSnapshotsResponse &b) {
  using ::std::swap;
  swap(a.error_code, b.error_code);
  swap(a.error_msg, b.error_msg);
  swap(a.snapshots, b.snapshots);
  swap(a.__isset, b.__isset);
}

ListSnapshotsResponse::ListSnapshotsResponse(const ListSnapshotsResponse& other578) {
  error_code = other578.error_code;
  error_msg = other578.error_msg;
  snapshots = other578.snapshots;
  __isset = other578.__isset;
}
ListSnapshotsResponse& ListSnapshotsResponse::operator=(const ListSnapshotsResponse& other579) {
  error_code = other579.error_code;
  error_msg = other579.error_msg;
  snapshots = other579.snapshots;
  __isset = other579.__isset;
  return *this;
}
void ListSnapshotsResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListSnapshotsResponse(";
  out << "error_code=" << to_string(error_code);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "snapshots=" << to_string(snapshots);
  out << ")";
}


DropSnapshotRequest::~DropSnapshotRequest() noexcept {
}


void DropSnapshotRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void DropSnapshotRequest::__set_snapshot_name(const std::string& val) {
  this->snapshot_name = val;
}
std::ostream& operator<<(std::ostream& out, const DropSnapshotRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropSnapshotRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->snapshot_name);
          this->__isset.snapshot_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropSnapshotRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropSnapshotRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("snapshot_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->snapshot_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropSnapshotRequest &a, DropSnapshotRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.snapshot_name, b.snapshot_name);
  swap(a.__isset, b.__isset);
}

DropSnapshotRequest::DropSnapshotRequest(const DropSnapshotRequest& other580) {
  session_id = other580.session_id;
  snapshot_name = other580.snapshot_name;
  __isset = other580.__isset;
}
DropSnapshotRequest& DropSnapshotRequest::operator=(const DropSnapshotRequest& other581) {
  session_id = other581.session_id;
  snapshot_name = other581.snapshot_name;
  __isset = other581.__isset;
  return *this;
}
void DropSnapshotRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropSnapshotRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "snapshot_name=" << to_string(snapshot_name);
  out << ")";
}

} // namespace
