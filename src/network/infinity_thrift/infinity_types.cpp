/**
 * Autogenerated by Thrift Compiler (0.19.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "infinity_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace infinity_thrift_rpc {

int _kLogicTypeValues[] = {
  LogicType::Boolean,
  LogicType::TinyInt,
  LogicType::SmallInt,
  LogicType::Integer,
  LogicType::BigInt,
  LogicType::HugeInt,
  LogicType::Decimal,
  LogicType::Float,
  LogicType::Double,
  LogicType::Varchar,
  LogicType::Embedding,
  LogicType::Invalid
};
const char* _kLogicTypeNames[] = {
  "Boolean",
  "TinyInt",
  "SmallInt",
  "Integer",
  "BigInt",
  "HugeInt",
  "Decimal",
  "Float",
  "Double",
  "Varchar",
  "Embedding",
  "Invalid"
};
const std::map<int, const char*> _LogicType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(12, _kLogicTypeValues, _kLogicTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LogicType::type& val) {
  std::map<int, const char*>::const_iterator it = _LogicType_VALUES_TO_NAMES.find(val);
  if (it != _LogicType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LogicType::type& val) {
  std::map<int, const char*>::const_iterator it = _LogicType_VALUES_TO_NAMES.find(val);
  if (it != _LogicType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kConflictTypeValues[] = {
  ConflictType::Invalid,
  ConflictType::Ignore,
  ConflictType::Error,
  ConflictType::Replace
};
const char* _kConflictTypeNames[] = {
  "Invalid",
  "Ignore",
  "Error",
  "Replace"
};
const std::map<int, const char*> _ConflictType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kConflictTypeValues, _kConflictTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ConflictType::type& val) {
  std::map<int, const char*>::const_iterator it = _ConflictType_VALUES_TO_NAMES.find(val);
  if (it != _ConflictType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ConflictType::type& val) {
  std::map<int, const char*>::const_iterator it = _ConflictType_VALUES_TO_NAMES.find(val);
  if (it != _ConflictType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kElementTypeValues[] = {
  ElementType::ElementBit,
  ElementType::ElementInt8,
  ElementType::ElementInt16,
  ElementType::ElementInt32,
  ElementType::ElementInt64,
  ElementType::ElementFloat32,
  ElementType::ElementFloat64
};
const char* _kElementTypeNames[] = {
  "ElementBit",
  "ElementInt8",
  "ElementInt16",
  "ElementInt32",
  "ElementInt64",
  "ElementFloat32",
  "ElementFloat64"
};
const std::map<int, const char*> _ElementType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kElementTypeValues, _kElementTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ElementType::type& val) {
  std::map<int, const char*>::const_iterator it = _ElementType_VALUES_TO_NAMES.find(val);
  if (it != _ElementType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ElementType::type& val) {
  std::map<int, const char*>::const_iterator it = _ElementType_VALUES_TO_NAMES.find(val);
  if (it != _ElementType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kConstraintValues[] = {
  Constraint::PrimaryKey,
  Constraint::NotNull,
  Constraint::Null,
  Constraint::Unique
};
const char* _kConstraintNames[] = {
  "PrimaryKey",
  "NotNull",
  "Null",
  "Unique"
};
const std::map<int, const char*> _Constraint_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kConstraintValues, _kConstraintNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Constraint::type& val) {
  std::map<int, const char*>::const_iterator it = _Constraint_VALUES_TO_NAMES.find(val);
  if (it != _Constraint_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Constraint::type& val) {
  std::map<int, const char*>::const_iterator it = _Constraint_VALUES_TO_NAMES.find(val);
  if (it != _Constraint_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kLiteralTypeValues[] = {
  LiteralType::Boolean,
  LiteralType::Double,
  LiteralType::String,
  LiteralType::Int64,
  LiteralType::Null,
  LiteralType::IntegerArray,
  LiteralType::DoubleArray
};
const char* _kLiteralTypeNames[] = {
  "Boolean",
  "Double",
  "String",
  "Int64",
  "Null",
  "IntegerArray",
  "DoubleArray"
};
const std::map<int, const char*> _LiteralType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kLiteralTypeValues, _kLiteralTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const LiteralType::type& val) {
  std::map<int, const char*>::const_iterator it = _LiteralType_VALUES_TO_NAMES.find(val);
  if (it != _LiteralType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const LiteralType::type& val) {
  std::map<int, const char*>::const_iterator it = _LiteralType_VALUES_TO_NAMES.find(val);
  if (it != _LiteralType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kKnnDistanceTypeValues[] = {
  KnnDistanceType::L2,
  KnnDistanceType::Cosine,
  KnnDistanceType::InnerProduct,
  KnnDistanceType::Hamming
};
const char* _kKnnDistanceTypeNames[] = {
  "L2",
  "Cosine",
  "InnerProduct",
  "Hamming"
};
const std::map<int, const char*> _KnnDistanceType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kKnnDistanceTypeValues, _kKnnDistanceTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const KnnDistanceType::type& val) {
  std::map<int, const char*>::const_iterator it = _KnnDistanceType_VALUES_TO_NAMES.find(val);
  if (it != _KnnDistanceType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const KnnDistanceType::type& val) {
  std::map<int, const char*>::const_iterator it = _KnnDistanceType_VALUES_TO_NAMES.find(val);
  if (it != _KnnDistanceType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCopyFileTypeValues[] = {
  CopyFileType::CSV,
  CopyFileType::JSON,
  CopyFileType::FVECS
};
const char* _kCopyFileTypeNames[] = {
  "CSV",
  "JSON",
  "FVECS"
};
const std::map<int, const char*> _CopyFileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kCopyFileTypeValues, _kCopyFileTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CopyFileType::type& val) {
  std::map<int, const char*>::const_iterator it = _CopyFileType_VALUES_TO_NAMES.find(val);
  if (it != _CopyFileType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CopyFileType::type& val) {
  std::map<int, const char*>::const_iterator it = _CopyFileType_VALUES_TO_NAMES.find(val);
  if (it != _CopyFileType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kColumnTypeValues[] = {
  ColumnType::ColumnBool,
  ColumnType::ColumnInt8,
  ColumnType::ColumnInt16,
  ColumnType::ColumnInt32,
  ColumnType::ColumnInt64,
  ColumnType::ColumnFloat32,
  ColumnType::ColumnFloat64,
  ColumnType::ColumnVarchar,
  ColumnType::ColumnEmbedding,
  ColumnType::ColumnRowID,
  ColumnType::ColumnInvalid
};
const char* _kColumnTypeNames[] = {
  "ColumnBool",
  "ColumnInt8",
  "ColumnInt16",
  "ColumnInt32",
  "ColumnInt64",
  "ColumnFloat32",
  "ColumnFloat64",
  "ColumnVarchar",
  "ColumnEmbedding",
  "ColumnRowID",
  "ColumnInvalid"
};
const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(11, _kColumnTypeValues, _kColumnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kIndexTypeValues[] = {
  IndexType::IVFFlat,
  IndexType::HnswLVQ,
  IndexType::Hnsw,
  IndexType::IRSFullText
};
const char* _kIndexTypeNames[] = {
  "IVFFlat",
  "HnswLVQ",
  "Hnsw",
  "IRSFullText"
};
const std::map<int, const char*> _IndexType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kIndexTypeValues, _kIndexTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const IndexType::type& val) {
  std::map<int, const char*>::const_iterator it = _IndexType_VALUES_TO_NAMES.find(val);
  if (it != _IndexType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const IndexType::type& val) {
  std::map<int, const char*>::const_iterator it = _IndexType_VALUES_TO_NAMES.find(val);
  if (it != _IndexType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kExplainTypeValues[] = {
  ExplainType::Analyze,
  ExplainType::Ast,
  ExplainType::UnOpt,
  ExplainType::Opt,
  ExplainType::Physical,
  ExplainType::Pipeline,
  ExplainType::Fragment
};
const char* _kExplainTypeNames[] = {
  "Analyze",
  "Ast",
  "UnOpt",
  "Opt",
  "Physical",
  "Pipeline",
  "Fragment"
};
const std::map<int, const char*> _ExplainType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kExplainTypeValues, _kExplainTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ExplainType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExplainType_VALUES_TO_NAMES.find(val);
  if (it != _ExplainType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ExplainType::type& val) {
  std::map<int, const char*>::const_iterator it = _ExplainType_VALUES_TO_NAMES.find(val);
  if (it != _ExplainType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Option::~Option() noexcept {
}

std::ostream& operator<<(std::ostream& out, const Option& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Option::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Option::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Option");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Option &a, Option &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

Option::Option(const Option& other0) noexcept {
  (void) other0;
}
Option& Option::operator=(const Option& other1) noexcept {
  (void) other1;
  return *this;
}
void Option::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Option(";
  out << ")";
}


DropTableOptions::~DropTableOptions() noexcept {
}


void DropTableOptions::__set_conflict_type(const ConflictType::type val) {
  this->conflict_type = val;
}
std::ostream& operator<<(std::ostream& out, const DropTableOptions& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropTableOptions::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->conflict_type = static_cast<ConflictType::type>(ecast2);
          this->__isset.conflict_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropTableOptions::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropTableOptions");

  xfer += oprot->writeFieldBegin("conflict_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->conflict_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropTableOptions &a, DropTableOptions &b) {
  using ::std::swap;
  swap(a.conflict_type, b.conflict_type);
  swap(a.__isset, b.__isset);
}

DropTableOptions::DropTableOptions(const DropTableOptions& other3) noexcept {
  conflict_type = other3.conflict_type;
  __isset = other3.__isset;
}
DropTableOptions& DropTableOptions::operator=(const DropTableOptions& other4) noexcept {
  conflict_type = other4.conflict_type;
  __isset = other4.__isset;
  return *this;
}
void DropTableOptions::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropTableOptions(";
  out << "conflict_type=" << to_string(conflict_type);
  out << ")";
}


NumberType::~NumberType() noexcept {
}

std::ostream& operator<<(std::ostream& out, const NumberType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NumberType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NumberType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NumberType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NumberType &a, NumberType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

NumberType::NumberType(const NumberType& other5) noexcept {
  (void) other5;
}
NumberType& NumberType::operator=(const NumberType& other6) noexcept {
  (void) other6;
  return *this;
}
void NumberType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NumberType(";
  out << ")";
}


VarcharType::~VarcharType() noexcept {
}

std::ostream& operator<<(std::ostream& out, const VarcharType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t VarcharType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VarcharType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VarcharType");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VarcharType &a, VarcharType &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

VarcharType::VarcharType(const VarcharType& other7) noexcept {
  (void) other7;
}
VarcharType& VarcharType::operator=(const VarcharType& other8) noexcept {
  (void) other8;
  return *this;
}
void VarcharType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VarcharType(";
  out << ")";
}


EmbeddingType::~EmbeddingType() noexcept {
}


void EmbeddingType::__set_dimension(const int32_t val) {
  this->dimension = val;
}

void EmbeddingType::__set_element_type(const ElementType::type val) {
  this->element_type = val;
}
std::ostream& operator<<(std::ostream& out, const EmbeddingType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EmbeddingType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dimension);
          this->__isset.dimension = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->element_type = static_cast<ElementType::type>(ecast9);
          this->__isset.element_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EmbeddingType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EmbeddingType");

  xfer += oprot->writeFieldBegin("dimension", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->dimension);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("element_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->element_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EmbeddingType &a, EmbeddingType &b) {
  using ::std::swap;
  swap(a.dimension, b.dimension);
  swap(a.element_type, b.element_type);
  swap(a.__isset, b.__isset);
}

EmbeddingType::EmbeddingType(const EmbeddingType& other10) noexcept {
  dimension = other10.dimension;
  element_type = other10.element_type;
  __isset = other10.__isset;
}
EmbeddingType& EmbeddingType::operator=(const EmbeddingType& other11) noexcept {
  dimension = other11.dimension;
  element_type = other11.element_type;
  __isset = other11.__isset;
  return *this;
}
void EmbeddingType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EmbeddingType(";
  out << "dimension=" << to_string(dimension);
  out << ", " << "element_type=" << to_string(element_type);
  out << ")";
}


PhysicalType::~PhysicalType() noexcept {
}


void PhysicalType::__set_number_type(const NumberType& val) {
  this->number_type = val;
__isset.number_type = true;
}

void PhysicalType::__set_varchar_type(const VarcharType& val) {
  this->varchar_type = val;
__isset.varchar_type = true;
}

void PhysicalType::__set_embedding_type(const EmbeddingType& val) {
  this->embedding_type = val;
__isset.embedding_type = true;
}
std::ostream& operator<<(std::ostream& out, const PhysicalType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PhysicalType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->number_type.read(iprot);
          this->__isset.number_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->varchar_type.read(iprot);
          this->__isset.varchar_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->embedding_type.read(iprot);
          this->__isset.embedding_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PhysicalType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PhysicalType");

  if (this->__isset.number_type) {
    xfer += oprot->writeFieldBegin("number_type", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->number_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.varchar_type) {
    xfer += oprot->writeFieldBegin("varchar_type", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->varchar_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.embedding_type) {
    xfer += oprot->writeFieldBegin("embedding_type", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->embedding_type.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PhysicalType &a, PhysicalType &b) {
  using ::std::swap;
  swap(a.number_type, b.number_type);
  swap(a.varchar_type, b.varchar_type);
  swap(a.embedding_type, b.embedding_type);
  swap(a.__isset, b.__isset);
}

PhysicalType::PhysicalType(const PhysicalType& other12) noexcept {
  number_type = other12.number_type;
  varchar_type = other12.varchar_type;
  embedding_type = other12.embedding_type;
  __isset = other12.__isset;
}
PhysicalType& PhysicalType::operator=(const PhysicalType& other13) noexcept {
  number_type = other13.number_type;
  varchar_type = other13.varchar_type;
  embedding_type = other13.embedding_type;
  __isset = other13.__isset;
  return *this;
}
void PhysicalType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PhysicalType(";
  out << "number_type="; (__isset.number_type ? (out << to_string(number_type)) : (out << "<null>"));
  out << ", " << "varchar_type="; (__isset.varchar_type ? (out << to_string(varchar_type)) : (out << "<null>"));
  out << ", " << "embedding_type="; (__isset.embedding_type ? (out << to_string(embedding_type)) : (out << "<null>"));
  out << ")";
}


DataType::~DataType() noexcept {
}


void DataType::__set_logic_type(const LogicType::type val) {
  this->logic_type = val;
}

void DataType::__set_physical_type(const PhysicalType& val) {
  this->physical_type = val;
}
std::ostream& operator<<(std::ostream& out, const DataType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DataType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast14;
          xfer += iprot->readI32(ecast14);
          this->logic_type = static_cast<LogicType::type>(ecast14);
          this->__isset.logic_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->physical_type.read(iprot);
          this->__isset.physical_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataType");

  xfer += oprot->writeFieldBegin("logic_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->logic_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("physical_type", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->physical_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataType &a, DataType &b) {
  using ::std::swap;
  swap(a.logic_type, b.logic_type);
  swap(a.physical_type, b.physical_type);
  swap(a.__isset, b.__isset);
}

DataType::DataType(const DataType& other15) noexcept {
  logic_type = other15.logic_type;
  physical_type = other15.physical_type;
  __isset = other15.__isset;
}
DataType& DataType::operator=(const DataType& other16) noexcept {
  logic_type = other16.logic_type;
  physical_type = other16.physical_type;
  __isset = other16.__isset;
  return *this;
}
void DataType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataType(";
  out << "logic_type=" << to_string(logic_type);
  out << ", " << "physical_type=" << to_string(physical_type);
  out << ")";
}


ColumnDef::~ColumnDef() noexcept {
}


void ColumnDef::__set_id(const int32_t val) {
  this->id = val;
}

void ColumnDef::__set_name(const std::string& val) {
  this->name = val;
}

void ColumnDef::__set_data_type(const DataType& val) {
  this->data_type = val;
}

void ColumnDef::__set_constraints(const std::vector<Constraint::type> & val) {
  this->constraints = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnDef& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnDef::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data_type.read(iprot);
          this->__isset.data_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->constraints.clear();
            uint32_t _size17;
            ::apache::thrift::protocol::TType _etype20;
            xfer += iprot->readListBegin(_etype20, _size17);
            this->constraints.resize(_size17);
            uint32_t _i21;
            for (_i21 = 0; _i21 < _size17; ++_i21)
            {
              int32_t ecast22;
              xfer += iprot->readI32(ecast22);
              this->constraints[_i21] = static_cast<Constraint::type>(ecast22);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.constraints = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnDef::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnDef");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_type", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->data_type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("constraints", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->constraints.size()));
    std::vector<Constraint::type> ::const_iterator _iter23;
    for (_iter23 = this->constraints.begin(); _iter23 != this->constraints.end(); ++_iter23)
    {
      xfer += oprot->writeI32(static_cast<int32_t>((*_iter23)));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnDef &a, ColumnDef &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.data_type, b.data_type);
  swap(a.constraints, b.constraints);
  swap(a.__isset, b.__isset);
}

ColumnDef::ColumnDef(const ColumnDef& other24) {
  id = other24.id;
  name = other24.name;
  data_type = other24.data_type;
  constraints = other24.constraints;
  __isset = other24.__isset;
}
ColumnDef& ColumnDef::operator=(const ColumnDef& other25) {
  id = other25.id;
  name = other25.name;
  data_type = other25.data_type;
  constraints = other25.constraints;
  __isset = other25.__isset;
  return *this;
}
void ColumnDef::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnDef(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "data_type=" << to_string(data_type);
  out << ", " << "constraints=" << to_string(constraints);
  out << ")";
}


ParsedExprType::~ParsedExprType() noexcept {
}


void ParsedExprType::__set_constant_expr(::std::shared_ptr<ConstantExpr> val) {
  this->constant_expr = val;
__isset.constant_expr = true;
}

void ParsedExprType::__set_column_expr(::std::shared_ptr<ColumnExpr> val) {
  this->column_expr = val;
__isset.column_expr = true;
}

void ParsedExprType::__set_function_expr(::std::shared_ptr<FunctionExpr> val) {
  this->function_expr = val;
__isset.function_expr = true;
}

void ParsedExprType::__set_between_expr(::std::shared_ptr<BetweenExpr> val) {
  this->between_expr = val;
__isset.between_expr = true;
}

void ParsedExprType::__set_knn_expr(::std::shared_ptr<KnnExpr> val) {
  this->knn_expr = val;
__isset.knn_expr = true;
}

void ParsedExprType::__set_match_expr(::std::shared_ptr<MatchExpr> val) {
  this->match_expr = val;
__isset.match_expr = true;
}

void ParsedExprType::__set_fusion_expr(::std::shared_ptr<FusionExpr> val) {
  this->fusion_expr = val;
__isset.fusion_expr = true;
}

void ParsedExprType::__set_search_expr(::std::shared_ptr<SearchExpr> val) {
  this->search_expr = val;
__isset.search_expr = true;
}
std::ostream& operator<<(std::ostream& out, const ParsedExprType& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ParsedExprType::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->constant_expr) { 
            this->constant_expr = ::std::shared_ptr<ConstantExpr>(new ConstantExpr);
          }
          xfer += this->constant_expr->read(iprot);
          bool wasSet = false;
          if (this->constant_expr->__isset.literal_type) { wasSet = true; }
          if (this->constant_expr->__isset.bool_value) { wasSet = true; }
          if (this->constant_expr->__isset.i64_value) { wasSet = true; }
          if (this->constant_expr->__isset.f64_value) { wasSet = true; }
          if (this->constant_expr->__isset.str_value) { wasSet = true; }
          if (this->constant_expr->__isset.i64_array_value) { wasSet = true; }
          if (this->constant_expr->__isset.f64_array_value) { wasSet = true; }
          if (!wasSet) { this->constant_expr.reset(); }
          this->__isset.constant_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->column_expr) { 
            this->column_expr = ::std::shared_ptr<ColumnExpr>(new ColumnExpr);
          }
          xfer += this->column_expr->read(iprot);
          bool wasSet = false;
          if (this->column_expr->__isset.column_name) { wasSet = true; }
          if (this->column_expr->__isset.star) { wasSet = true; }
          if (!wasSet) { this->column_expr.reset(); }
          this->__isset.column_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->function_expr) { 
            this->function_expr = ::std::shared_ptr<FunctionExpr>(new FunctionExpr);
          }
          xfer += this->function_expr->read(iprot);
          bool wasSet = false;
          if (this->function_expr->__isset.function_name) { wasSet = true; }
          if (this->function_expr->__isset.arguments) { wasSet = true; }
          if (!wasSet) { this->function_expr.reset(); }
          this->__isset.function_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->between_expr) { 
            this->between_expr = ::std::shared_ptr<BetweenExpr>(new BetweenExpr);
          }
          xfer += this->between_expr->read(iprot);
          bool wasSet = false;
          if (this->between_expr->__isset.value) { wasSet = true; }
          if (this->between_expr->__isset.upper_bound) { wasSet = true; }
          if (this->between_expr->__isset.lower_bound) { wasSet = true; }
          if (!wasSet) { this->between_expr.reset(); }
          this->__isset.between_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->knn_expr) { 
            this->knn_expr = ::std::shared_ptr<KnnExpr>(new KnnExpr);
          }
          xfer += this->knn_expr->read(iprot);
          bool wasSet = false;
          if (this->knn_expr->__isset.column_expr) { wasSet = true; }
          if (this->knn_expr->__isset.embedding_data) { wasSet = true; }
          if (this->knn_expr->__isset.embedding_data_type) { wasSet = true; }
          if (this->knn_expr->__isset.distance_type) { wasSet = true; }
          if (this->knn_expr->__isset.topn) { wasSet = true; }
          if (this->knn_expr->__isset.opt_params) { wasSet = true; }
          if (!wasSet) { this->knn_expr.reset(); }
          this->__isset.knn_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->match_expr) { 
            this->match_expr = ::std::shared_ptr<MatchExpr>(new MatchExpr);
          }
          xfer += this->match_expr->read(iprot);
          bool wasSet = false;
          if (this->match_expr->__isset.fields) { wasSet = true; }
          if (this->match_expr->__isset.matching_text) { wasSet = true; }
          if (this->match_expr->__isset.options_text) { wasSet = true; }
          if (!wasSet) { this->match_expr.reset(); }
          this->__isset.match_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->fusion_expr) { 
            this->fusion_expr = ::std::shared_ptr<FusionExpr>(new FusionExpr);
          }
          xfer += this->fusion_expr->read(iprot);
          bool wasSet = false;
          if (this->fusion_expr->__isset.method) { wasSet = true; }
          if (this->fusion_expr->__isset.options_text) { wasSet = true; }
          if (!wasSet) { this->fusion_expr.reset(); }
          this->__isset.fusion_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          if (!this->search_expr) { 
            this->search_expr = ::std::shared_ptr<SearchExpr>(new SearchExpr);
          }
          xfer += this->search_expr->read(iprot);
          bool wasSet = false;
          if (this->search_expr->__isset.match_exprs) { wasSet = true; }
          if (this->search_expr->__isset.knn_exprs) { wasSet = true; }
          if (this->search_expr->__isset.fusion_expr) { wasSet = true; }
          if (!wasSet) { this->search_expr.reset(); }
          this->__isset.search_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ParsedExprType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParsedExprType");

  if (this->__isset.constant_expr) {
    xfer += oprot->writeFieldBegin("constant_expr", ::apache::thrift::protocol::T_STRUCT, 1);
    if (this->constant_expr) {
      xfer += this->constant_expr->write(oprot); 
    } else {oprot->writeStructBegin("ConstantExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.column_expr) {
    xfer += oprot->writeFieldBegin("column_expr", ::apache::thrift::protocol::T_STRUCT, 2);
    if (this->column_expr) {
      xfer += this->column_expr->write(oprot); 
    } else {oprot->writeStructBegin("ColumnExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.function_expr) {
    xfer += oprot->writeFieldBegin("function_expr", ::apache::thrift::protocol::T_STRUCT, 3);
    if (this->function_expr) {
      xfer += this->function_expr->write(oprot); 
    } else {oprot->writeStructBegin("FunctionExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.between_expr) {
    xfer += oprot->writeFieldBegin("between_expr", ::apache::thrift::protocol::T_STRUCT, 4);
    if (this->between_expr) {
      xfer += this->between_expr->write(oprot); 
    } else {oprot->writeStructBegin("BetweenExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.knn_expr) {
    xfer += oprot->writeFieldBegin("knn_expr", ::apache::thrift::protocol::T_STRUCT, 5);
    if (this->knn_expr) {
      xfer += this->knn_expr->write(oprot); 
    } else {oprot->writeStructBegin("KnnExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.match_expr) {
    xfer += oprot->writeFieldBegin("match_expr", ::apache::thrift::protocol::T_STRUCT, 6);
    if (this->match_expr) {
      xfer += this->match_expr->write(oprot); 
    } else {oprot->writeStructBegin("MatchExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fusion_expr) {
    xfer += oprot->writeFieldBegin("fusion_expr", ::apache::thrift::protocol::T_STRUCT, 7);
    if (this->fusion_expr) {
      xfer += this->fusion_expr->write(oprot); 
    } else {oprot->writeStructBegin("FusionExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.search_expr) {
    xfer += oprot->writeFieldBegin("search_expr", ::apache::thrift::protocol::T_STRUCT, 8);
    if (this->search_expr) {
      xfer += this->search_expr->write(oprot); 
    } else {oprot->writeStructBegin("SearchExpr"); 
      oprot->writeStructEnd();
      oprot->writeFieldStop();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParsedExprType &a, ParsedExprType &b) {
  using ::std::swap;
  swap(a.constant_expr, b.constant_expr);
  swap(a.column_expr, b.column_expr);
  swap(a.function_expr, b.function_expr);
  swap(a.between_expr, b.between_expr);
  swap(a.knn_expr, b.knn_expr);
  swap(a.match_expr, b.match_expr);
  swap(a.fusion_expr, b.fusion_expr);
  swap(a.search_expr, b.search_expr);
  swap(a.__isset, b.__isset);
}

ParsedExprType::ParsedExprType(const ParsedExprType& other26) {
  constant_expr = other26.constant_expr;
  column_expr = other26.column_expr;
  function_expr = other26.function_expr;
  between_expr = other26.between_expr;
  knn_expr = other26.knn_expr;
  match_expr = other26.match_expr;
  fusion_expr = other26.fusion_expr;
  search_expr = other26.search_expr;
  __isset = other26.__isset;
}
ParsedExprType& ParsedExprType::operator=(const ParsedExprType& other27) {
  constant_expr = other27.constant_expr;
  column_expr = other27.column_expr;
  function_expr = other27.function_expr;
  between_expr = other27.between_expr;
  knn_expr = other27.knn_expr;
  match_expr = other27.match_expr;
  fusion_expr = other27.fusion_expr;
  search_expr = other27.search_expr;
  __isset = other27.__isset;
  return *this;
}
void ParsedExprType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParsedExprType(";
  out << "constant_expr="; (__isset.constant_expr ? (out << to_string(constant_expr)) : (out << "<null>"));
  out << ", " << "column_expr="; (__isset.column_expr ? (out << to_string(column_expr)) : (out << "<null>"));
  out << ", " << "function_expr="; (__isset.function_expr ? (out << to_string(function_expr)) : (out << "<null>"));
  out << ", " << "between_expr="; (__isset.between_expr ? (out << to_string(between_expr)) : (out << "<null>"));
  out << ", " << "knn_expr="; (__isset.knn_expr ? (out << to_string(knn_expr)) : (out << "<null>"));
  out << ", " << "match_expr="; (__isset.match_expr ? (out << to_string(match_expr)) : (out << "<null>"));
  out << ", " << "fusion_expr="; (__isset.fusion_expr ? (out << to_string(fusion_expr)) : (out << "<null>"));
  out << ", " << "search_expr="; (__isset.search_expr ? (out << to_string(search_expr)) : (out << "<null>"));
  out << ")";
}


ParsedExpr::~ParsedExpr() noexcept {
}


void ParsedExpr::__set_type(const ParsedExprType& val) {
  this->type = val;
}

void ParsedExpr::__set_alias_name(const std::string& val) {
  this->alias_name = val;
}
std::ostream& operator<<(std::ostream& out, const ParsedExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ParsedExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->type.read(iprot);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alias_name);
          this->__isset.alias_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ParsedExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ParsedExpr");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->type.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alias_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->alias_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ParsedExpr &a, ParsedExpr &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.alias_name, b.alias_name);
  swap(a.__isset, b.__isset);
}

ParsedExpr::ParsedExpr(const ParsedExpr& other28) {
  type = other28.type;
  alias_name = other28.alias_name;
  __isset = other28.__isset;
}
ParsedExpr& ParsedExpr::operator=(const ParsedExpr& other29) {
  type = other29.type;
  alias_name = other29.alias_name;
  __isset = other29.__isset;
  return *this;
}
void ParsedExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ParsedExpr(";
  out << "type=" << to_string(type);
  out << ", " << "alias_name=" << to_string(alias_name);
  out << ")";
}


ColumnExpr::~ColumnExpr() noexcept {
}


void ColumnExpr::__set_column_name(const std::vector<std::string> & val) {
  this->column_name = val;
}

void ColumnExpr::__set_star(const bool val) {
  this->star = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_name.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->column_name.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += iprot->readString(this->column_name[_i34]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->star);
          this->__isset.star = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnExpr");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_name.size()));
    std::vector<std::string> ::const_iterator _iter35;
    for (_iter35 = this->column_name.begin(); _iter35 != this->column_name.end(); ++_iter35)
    {
      xfer += oprot->writeString((*_iter35));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("star", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->star);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnExpr &a, ColumnExpr &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.star, b.star);
  swap(a.__isset, b.__isset);
}

ColumnExpr::ColumnExpr(const ColumnExpr& other36) {
  column_name = other36.column_name;
  star = other36.star;
  __isset = other36.__isset;
}
ColumnExpr& ColumnExpr::operator=(const ColumnExpr& other37) {
  column_name = other37.column_name;
  star = other37.star;
  __isset = other37.__isset;
  return *this;
}
void ColumnExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnExpr(";
  out << "column_name=" << to_string(column_name);
  out << ", " << "star=" << to_string(star);
  out << ")";
}


EmbeddingData::~EmbeddingData() noexcept {
}


void EmbeddingData::__set_bool_array_value(const std::vector<bool> & val) {
  this->bool_array_value = val;
__isset.bool_array_value = true;
}

void EmbeddingData::__set_i8_array_value(const std::vector<std::string> & val) {
  this->i8_array_value = val;
__isset.i8_array_value = true;
}

void EmbeddingData::__set_i16_array_value(const std::vector<int16_t> & val) {
  this->i16_array_value = val;
__isset.i16_array_value = true;
}

void EmbeddingData::__set_i32_array_value(const std::vector<int32_t> & val) {
  this->i32_array_value = val;
__isset.i32_array_value = true;
}

void EmbeddingData::__set_i64_array_value(const std::vector<int64_t> & val) {
  this->i64_array_value = val;
__isset.i64_array_value = true;
}

void EmbeddingData::__set_f32_array_value(const std::vector<double> & val) {
  this->f32_array_value = val;
__isset.f32_array_value = true;
}

void EmbeddingData::__set_f64_array_value(const std::vector<double> & val) {
  this->f64_array_value = val;
__isset.f64_array_value = true;
}
std::ostream& operator<<(std::ostream& out, const EmbeddingData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EmbeddingData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bool_array_value.clear();
            uint32_t _size38;
            ::apache::thrift::protocol::TType _etype41;
            xfer += iprot->readListBegin(_etype41, _size38);
            this->bool_array_value.resize(_size38);
            uint32_t _i42;
            for (_i42 = 0; _i42 < _size38; ++_i42)
            {
              xfer += iprot->readBool(this->bool_array_value[_i42]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.bool_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i8_array_value.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->i8_array_value.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readBinary(this->i8_array_value[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i8_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i16_array_value.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->i16_array_value.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readI16(this->i16_array_value[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i16_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i32_array_value.clear();
            uint32_t _size53;
            ::apache::thrift::protocol::TType _etype56;
            xfer += iprot->readListBegin(_etype56, _size53);
            this->i32_array_value.resize(_size53);
            uint32_t _i57;
            for (_i57 = 0; _i57 < _size53; ++_i57)
            {
              xfer += iprot->readI32(this->i32_array_value[_i57]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i32_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_array_value.clear();
            uint32_t _size58;
            ::apache::thrift::protocol::TType _etype61;
            xfer += iprot->readListBegin(_etype61, _size58);
            this->i64_array_value.resize(_size58);
            uint32_t _i62;
            for (_i62 = 0; _i62 < _size58; ++_i62)
            {
              xfer += iprot->readI64(this->i64_array_value[_i62]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f32_array_value.clear();
            uint32_t _size63;
            ::apache::thrift::protocol::TType _etype66;
            xfer += iprot->readListBegin(_etype66, _size63);
            this->f32_array_value.resize(_size63);
            uint32_t _i67;
            for (_i67 = 0; _i67 < _size63; ++_i67)
            {
              xfer += iprot->readDouble(this->f32_array_value[_i67]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f32_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f64_array_value.clear();
            uint32_t _size68;
            ::apache::thrift::protocol::TType _etype71;
            xfer += iprot->readListBegin(_etype71, _size68);
            this->f64_array_value.resize(_size68);
            uint32_t _i72;
            for (_i72 = 0; _i72 < _size68; ++_i72)
            {
              xfer += iprot->readDouble(this->f64_array_value[_i72]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f64_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EmbeddingData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EmbeddingData");

  if (this->__isset.bool_array_value) {
    xfer += oprot->writeFieldBegin("bool_array_value", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BOOL, static_cast<uint32_t>(this->bool_array_value.size()));
      std::vector<bool> ::const_iterator _iter73;
      for (_iter73 = this->bool_array_value.begin(); _iter73 != this->bool_array_value.end(); ++_iter73)
      {
        xfer += oprot->writeBool((*_iter73));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i8_array_value) {
    xfer += oprot->writeFieldBegin("i8_array_value", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->i8_array_value.size()));
      std::vector<std::string> ::const_iterator _iter74;
      for (_iter74 = this->i8_array_value.begin(); _iter74 != this->i8_array_value.end(); ++_iter74)
      {
        xfer += oprot->writeBinary((*_iter74));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i16_array_value) {
    xfer += oprot->writeFieldBegin("i16_array_value", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I16, static_cast<uint32_t>(this->i16_array_value.size()));
      std::vector<int16_t> ::const_iterator _iter75;
      for (_iter75 = this->i16_array_value.begin(); _iter75 != this->i16_array_value.end(); ++_iter75)
      {
        xfer += oprot->writeI16((*_iter75));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i32_array_value) {
    xfer += oprot->writeFieldBegin("i32_array_value", ::apache::thrift::protocol::T_LIST, 4);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->i32_array_value.size()));
      std::vector<int32_t> ::const_iterator _iter76;
      for (_iter76 = this->i32_array_value.begin(); _iter76 != this->i32_array_value.end(); ++_iter76)
      {
        xfer += oprot->writeI32((*_iter76));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.i64_array_value) {
    xfer += oprot->writeFieldBegin("i64_array_value", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->i64_array_value.size()));
      std::vector<int64_t> ::const_iterator _iter77;
      for (_iter77 = this->i64_array_value.begin(); _iter77 != this->i64_array_value.end(); ++_iter77)
      {
        xfer += oprot->writeI64((*_iter77));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f32_array_value) {
    xfer += oprot->writeFieldBegin("f32_array_value", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->f32_array_value.size()));
      std::vector<double> ::const_iterator _iter78;
      for (_iter78 = this->f32_array_value.begin(); _iter78 != this->f32_array_value.end(); ++_iter78)
      {
        xfer += oprot->writeDouble((*_iter78));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.f64_array_value) {
    xfer += oprot->writeFieldBegin("f64_array_value", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->f64_array_value.size()));
      std::vector<double> ::const_iterator _iter79;
      for (_iter79 = this->f64_array_value.begin(); _iter79 != this->f64_array_value.end(); ++_iter79)
      {
        xfer += oprot->writeDouble((*_iter79));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EmbeddingData &a, EmbeddingData &b) {
  using ::std::swap;
  swap(a.bool_array_value, b.bool_array_value);
  swap(a.i8_array_value, b.i8_array_value);
  swap(a.i16_array_value, b.i16_array_value);
  swap(a.i32_array_value, b.i32_array_value);
  swap(a.i64_array_value, b.i64_array_value);
  swap(a.f32_array_value, b.f32_array_value);
  swap(a.f64_array_value, b.f64_array_value);
  swap(a.__isset, b.__isset);
}

EmbeddingData::EmbeddingData(const EmbeddingData& other80) {
  bool_array_value = other80.bool_array_value;
  i8_array_value = other80.i8_array_value;
  i16_array_value = other80.i16_array_value;
  i32_array_value = other80.i32_array_value;
  i64_array_value = other80.i64_array_value;
  f32_array_value = other80.f32_array_value;
  f64_array_value = other80.f64_array_value;
  __isset = other80.__isset;
}
EmbeddingData& EmbeddingData::operator=(const EmbeddingData& other81) {
  bool_array_value = other81.bool_array_value;
  i8_array_value = other81.i8_array_value;
  i16_array_value = other81.i16_array_value;
  i32_array_value = other81.i32_array_value;
  i64_array_value = other81.i64_array_value;
  f32_array_value = other81.f32_array_value;
  f64_array_value = other81.f64_array_value;
  __isset = other81.__isset;
  return *this;
}
void EmbeddingData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EmbeddingData(";
  out << "bool_array_value="; (__isset.bool_array_value ? (out << to_string(bool_array_value)) : (out << "<null>"));
  out << ", " << "i8_array_value="; (__isset.i8_array_value ? (out << to_string(i8_array_value)) : (out << "<null>"));
  out << ", " << "i16_array_value="; (__isset.i16_array_value ? (out << to_string(i16_array_value)) : (out << "<null>"));
  out << ", " << "i32_array_value="; (__isset.i32_array_value ? (out << to_string(i32_array_value)) : (out << "<null>"));
  out << ", " << "i64_array_value="; (__isset.i64_array_value ? (out << to_string(i64_array_value)) : (out << "<null>"));
  out << ", " << "f32_array_value="; (__isset.f32_array_value ? (out << to_string(f32_array_value)) : (out << "<null>"));
  out << ", " << "f64_array_value="; (__isset.f64_array_value ? (out << to_string(f64_array_value)) : (out << "<null>"));
  out << ")";
}


InitParameter::~InitParameter() noexcept {
}


void InitParameter::__set_param_name(const std::string& val) {
  this->param_name = val;
}

void InitParameter::__set_param_value(const std::string& val) {
  this->param_value = val;
}
std::ostream& operator<<(std::ostream& out, const InitParameter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InitParameter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param_name);
          this->__isset.param_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->param_value);
          this->__isset.param_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InitParameter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InitParameter");

  xfer += oprot->writeFieldBegin("param_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->param_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("param_value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->param_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InitParameter &a, InitParameter &b) {
  using ::std::swap;
  swap(a.param_name, b.param_name);
  swap(a.param_value, b.param_value);
  swap(a.__isset, b.__isset);
}

InitParameter::InitParameter(const InitParameter& other82) {
  param_name = other82.param_name;
  param_value = other82.param_value;
  __isset = other82.__isset;
}
InitParameter& InitParameter::operator=(const InitParameter& other83) {
  param_name = other83.param_name;
  param_value = other83.param_value;
  __isset = other83.__isset;
  return *this;
}
void InitParameter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InitParameter(";
  out << "param_name=" << to_string(param_name);
  out << ", " << "param_value=" << to_string(param_value);
  out << ")";
}


KnnExpr::~KnnExpr() noexcept {
}


void KnnExpr::__set_column_expr(const ColumnExpr& val) {
  this->column_expr = val;
}

void KnnExpr::__set_embedding_data(const EmbeddingData& val) {
  this->embedding_data = val;
}

void KnnExpr::__set_embedding_data_type(const ElementType::type val) {
  this->embedding_data_type = val;
}

void KnnExpr::__set_distance_type(const KnnDistanceType::type val) {
  this->distance_type = val;
}

void KnnExpr::__set_topn(const int64_t val) {
  this->topn = val;
}

void KnnExpr::__set_opt_params(const std::vector<InitParameter> & val) {
  this->opt_params = val;
}
std::ostream& operator<<(std::ostream& out, const KnnExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KnnExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->column_expr.read(iprot);
          this->__isset.column_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->embedding_data.read(iprot);
          this->__isset.embedding_data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast84;
          xfer += iprot->readI32(ecast84);
          this->embedding_data_type = static_cast<ElementType::type>(ecast84);
          this->__isset.embedding_data_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast85;
          xfer += iprot->readI32(ecast85);
          this->distance_type = static_cast<KnnDistanceType::type>(ecast85);
          this->__isset.distance_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->topn);
          this->__isset.topn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->opt_params.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _etype89;
            xfer += iprot->readListBegin(_etype89, _size86);
            this->opt_params.resize(_size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              xfer += this->opt_params[_i90].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.opt_params = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KnnExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KnnExpr");

  xfer += oprot->writeFieldBegin("column_expr", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->column_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("embedding_data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->embedding_data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("embedding_data_type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->embedding_data_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("distance_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->distance_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("topn", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->topn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("opt_params", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->opt_params.size()));
    std::vector<InitParameter> ::const_iterator _iter91;
    for (_iter91 = this->opt_params.begin(); _iter91 != this->opt_params.end(); ++_iter91)
    {
      xfer += (*_iter91).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KnnExpr &a, KnnExpr &b) {
  using ::std::swap;
  swap(a.column_expr, b.column_expr);
  swap(a.embedding_data, b.embedding_data);
  swap(a.embedding_data_type, b.embedding_data_type);
  swap(a.distance_type, b.distance_type);
  swap(a.topn, b.topn);
  swap(a.opt_params, b.opt_params);
  swap(a.__isset, b.__isset);
}

KnnExpr::KnnExpr(const KnnExpr& other92) {
  column_expr = other92.column_expr;
  embedding_data = other92.embedding_data;
  embedding_data_type = other92.embedding_data_type;
  distance_type = other92.distance_type;
  topn = other92.topn;
  opt_params = other92.opt_params;
  __isset = other92.__isset;
}
KnnExpr& KnnExpr::operator=(const KnnExpr& other93) {
  column_expr = other93.column_expr;
  embedding_data = other93.embedding_data;
  embedding_data_type = other93.embedding_data_type;
  distance_type = other93.distance_type;
  topn = other93.topn;
  opt_params = other93.opt_params;
  __isset = other93.__isset;
  return *this;
}
void KnnExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KnnExpr(";
  out << "column_expr=" << to_string(column_expr);
  out << ", " << "embedding_data=" << to_string(embedding_data);
  out << ", " << "embedding_data_type=" << to_string(embedding_data_type);
  out << ", " << "distance_type=" << to_string(distance_type);
  out << ", " << "topn=" << to_string(topn);
  out << ", " << "opt_params=" << to_string(opt_params);
  out << ")";
}


MatchExpr::~MatchExpr() noexcept {
}


void MatchExpr::__set_fields(const std::string& val) {
  this->fields = val;
}

void MatchExpr::__set_matching_text(const std::string& val) {
  this->matching_text = val;
}

void MatchExpr::__set_options_text(const std::string& val) {
  this->options_text = val;
}
std::ostream& operator<<(std::ostream& out, const MatchExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MatchExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->fields);
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->matching_text);
          this->__isset.matching_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->options_text);
          this->__isset.options_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MatchExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MatchExpr");

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->fields);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("matching_text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->matching_text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options_text", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->options_text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MatchExpr &a, MatchExpr &b) {
  using ::std::swap;
  swap(a.fields, b.fields);
  swap(a.matching_text, b.matching_text);
  swap(a.options_text, b.options_text);
  swap(a.__isset, b.__isset);
}

MatchExpr::MatchExpr(const MatchExpr& other94) {
  fields = other94.fields;
  matching_text = other94.matching_text;
  options_text = other94.options_text;
  __isset = other94.__isset;
}
MatchExpr& MatchExpr::operator=(const MatchExpr& other95) {
  fields = other95.fields;
  matching_text = other95.matching_text;
  options_text = other95.options_text;
  __isset = other95.__isset;
  return *this;
}
void MatchExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MatchExpr(";
  out << "fields=" << to_string(fields);
  out << ", " << "matching_text=" << to_string(matching_text);
  out << ", " << "options_text=" << to_string(options_text);
  out << ")";
}


FusionExpr::~FusionExpr() noexcept {
}


void FusionExpr::__set_method(const std::string& val) {
  this->method = val;
}

void FusionExpr::__set_options_text(const std::string& val) {
  this->options_text = val;
}
std::ostream& operator<<(std::ostream& out, const FusionExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FusionExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->method);
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->options_text);
          this->__isset.options_text = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FusionExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FusionExpr");

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->method);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options_text", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->options_text);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FusionExpr &a, FusionExpr &b) {
  using ::std::swap;
  swap(a.method, b.method);
  swap(a.options_text, b.options_text);
  swap(a.__isset, b.__isset);
}

FusionExpr::FusionExpr(const FusionExpr& other96) {
  method = other96.method;
  options_text = other96.options_text;
  __isset = other96.__isset;
}
FusionExpr& FusionExpr::operator=(const FusionExpr& other97) {
  method = other97.method;
  options_text = other97.options_text;
  __isset = other97.__isset;
  return *this;
}
void FusionExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FusionExpr(";
  out << "method=" << to_string(method);
  out << ", " << "options_text=" << to_string(options_text);
  out << ")";
}


SearchExpr::~SearchExpr() noexcept {
}


void SearchExpr::__set_match_exprs(const std::vector<MatchExpr> & val) {
  this->match_exprs = val;
__isset.match_exprs = true;
}

void SearchExpr::__set_knn_exprs(const std::vector<KnnExpr> & val) {
  this->knn_exprs = val;
__isset.knn_exprs = true;
}

void SearchExpr::__set_fusion_expr(const FusionExpr& val) {
  this->fusion_expr = val;
__isset.fusion_expr = true;
}
std::ostream& operator<<(std::ostream& out, const SearchExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SearchExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->match_exprs.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _etype101;
            xfer += iprot->readListBegin(_etype101, _size98);
            this->match_exprs.resize(_size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              xfer += this->match_exprs[_i102].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.match_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->knn_exprs.clear();
            uint32_t _size103;
            ::apache::thrift::protocol::TType _etype106;
            xfer += iprot->readListBegin(_etype106, _size103);
            this->knn_exprs.resize(_size103);
            uint32_t _i107;
            for (_i107 = 0; _i107 < _size103; ++_i107)
            {
              xfer += this->knn_exprs[_i107].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.knn_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fusion_expr.read(iprot);
          this->__isset.fusion_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SearchExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SearchExpr");

  if (this->__isset.match_exprs) {
    xfer += oprot->writeFieldBegin("match_exprs", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->match_exprs.size()));
      std::vector<MatchExpr> ::const_iterator _iter108;
      for (_iter108 = this->match_exprs.begin(); _iter108 != this->match_exprs.end(); ++_iter108)
      {
        xfer += (*_iter108).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.knn_exprs) {
    xfer += oprot->writeFieldBegin("knn_exprs", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->knn_exprs.size()));
      std::vector<KnnExpr> ::const_iterator _iter109;
      for (_iter109 = this->knn_exprs.begin(); _iter109 != this->knn_exprs.end(); ++_iter109)
      {
        xfer += (*_iter109).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.fusion_expr) {
    xfer += oprot->writeFieldBegin("fusion_expr", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->fusion_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SearchExpr &a, SearchExpr &b) {
  using ::std::swap;
  swap(a.match_exprs, b.match_exprs);
  swap(a.knn_exprs, b.knn_exprs);
  swap(a.fusion_expr, b.fusion_expr);
  swap(a.__isset, b.__isset);
}

SearchExpr::SearchExpr(const SearchExpr& other110) {
  match_exprs = other110.match_exprs;
  knn_exprs = other110.knn_exprs;
  fusion_expr = other110.fusion_expr;
  __isset = other110.__isset;
}
SearchExpr& SearchExpr::operator=(const SearchExpr& other111) {
  match_exprs = other111.match_exprs;
  knn_exprs = other111.knn_exprs;
  fusion_expr = other111.fusion_expr;
  __isset = other111.__isset;
  return *this;
}
void SearchExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SearchExpr(";
  out << "match_exprs="; (__isset.match_exprs ? (out << to_string(match_exprs)) : (out << "<null>"));
  out << ", " << "knn_exprs="; (__isset.knn_exprs ? (out << to_string(knn_exprs)) : (out << "<null>"));
  out << ", " << "fusion_expr="; (__isset.fusion_expr ? (out << to_string(fusion_expr)) : (out << "<null>"));
  out << ")";
}


ConstantExpr::~ConstantExpr() noexcept {
}


void ConstantExpr::__set_literal_type(const LiteralType::type val) {
  this->literal_type = val;
}

void ConstantExpr::__set_bool_value(const bool val) {
  this->bool_value = val;
}

void ConstantExpr::__set_i64_value(const int64_t val) {
  this->i64_value = val;
}

void ConstantExpr::__set_f64_value(const double val) {
  this->f64_value = val;
}

void ConstantExpr::__set_str_value(const std::string& val) {
  this->str_value = val;
}

void ConstantExpr::__set_i64_array_value(const std::vector<int64_t> & val) {
  this->i64_array_value = val;
}

void ConstantExpr::__set_f64_array_value(const std::vector<double> & val) {
  this->f64_array_value = val;
}
std::ostream& operator<<(std::ostream& out, const ConstantExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ConstantExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast112;
          xfer += iprot->readI32(ecast112);
          this->literal_type = static_cast<LiteralType::type>(ecast112);
          this->__isset.literal_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bool_value);
          this->__isset.bool_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->i64_value);
          this->__isset.i64_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->f64_value);
          this->__isset.f64_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->str_value);
          this->__isset.str_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->i64_array_value.clear();
            uint32_t _size113;
            ::apache::thrift::protocol::TType _etype116;
            xfer += iprot->readListBegin(_etype116, _size113);
            this->i64_array_value.resize(_size113);
            uint32_t _i117;
            for (_i117 = 0; _i117 < _size113; ++_i117)
            {
              xfer += iprot->readI64(this->i64_array_value[_i117]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.i64_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->f64_array_value.clear();
            uint32_t _size118;
            ::apache::thrift::protocol::TType _etype121;
            xfer += iprot->readListBegin(_etype121, _size118);
            this->f64_array_value.resize(_size118);
            uint32_t _i122;
            for (_i122 = 0; _i122 < _size118; ++_i122)
            {
              xfer += iprot->readDouble(this->f64_array_value[_i122]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.f64_array_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ConstantExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ConstantExpr");

  xfer += oprot->writeFieldBegin("literal_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->literal_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bool_value", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bool_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_value", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->i64_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f64_value", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->f64_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("str_value", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->str_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i64_array_value", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->i64_array_value.size()));
    std::vector<int64_t> ::const_iterator _iter123;
    for (_iter123 = this->i64_array_value.begin(); _iter123 != this->i64_array_value.end(); ++_iter123)
    {
      xfer += oprot->writeI64((*_iter123));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f64_array_value", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_DOUBLE, static_cast<uint32_t>(this->f64_array_value.size()));
    std::vector<double> ::const_iterator _iter124;
    for (_iter124 = this->f64_array_value.begin(); _iter124 != this->f64_array_value.end(); ++_iter124)
    {
      xfer += oprot->writeDouble((*_iter124));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ConstantExpr &a, ConstantExpr &b) {
  using ::std::swap;
  swap(a.literal_type, b.literal_type);
  swap(a.bool_value, b.bool_value);
  swap(a.i64_value, b.i64_value);
  swap(a.f64_value, b.f64_value);
  swap(a.str_value, b.str_value);
  swap(a.i64_array_value, b.i64_array_value);
  swap(a.f64_array_value, b.f64_array_value);
  swap(a.__isset, b.__isset);
}

ConstantExpr::ConstantExpr(const ConstantExpr& other125) {
  literal_type = other125.literal_type;
  bool_value = other125.bool_value;
  i64_value = other125.i64_value;
  f64_value = other125.f64_value;
  str_value = other125.str_value;
  i64_array_value = other125.i64_array_value;
  f64_array_value = other125.f64_array_value;
  __isset = other125.__isset;
}
ConstantExpr& ConstantExpr::operator=(const ConstantExpr& other126) {
  literal_type = other126.literal_type;
  bool_value = other126.bool_value;
  i64_value = other126.i64_value;
  f64_value = other126.f64_value;
  str_value = other126.str_value;
  i64_array_value = other126.i64_array_value;
  f64_array_value = other126.f64_array_value;
  __isset = other126.__isset;
  return *this;
}
void ConstantExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ConstantExpr(";
  out << "literal_type=" << to_string(literal_type);
  out << ", " << "bool_value=" << to_string(bool_value);
  out << ", " << "i64_value=" << to_string(i64_value);
  out << ", " << "f64_value=" << to_string(f64_value);
  out << ", " << "str_value=" << to_string(str_value);
  out << ", " << "i64_array_value=" << to_string(i64_array_value);
  out << ", " << "f64_array_value=" << to_string(f64_array_value);
  out << ")";
}


FunctionExpr::~FunctionExpr() noexcept {
}


void FunctionExpr::__set_function_name(const std::string& val) {
  this->function_name = val;
}

void FunctionExpr::__set_arguments(const std::vector<ParsedExpr> & val) {
  this->arguments = val;
}
std::ostream& operator<<(std::ostream& out, const FunctionExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FunctionExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->function_name);
          this->__isset.function_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->arguments.clear();
            uint32_t _size127;
            ::apache::thrift::protocol::TType _etype130;
            xfer += iprot->readListBegin(_etype130, _size127);
            this->arguments.resize(_size127);
            uint32_t _i131;
            for (_i131 = 0; _i131 < _size127; ++_i131)
            {
              xfer += this->arguments[_i131].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.arguments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FunctionExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FunctionExpr");

  xfer += oprot->writeFieldBegin("function_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->function_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("arguments", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->arguments.size()));
    std::vector<ParsedExpr> ::const_iterator _iter132;
    for (_iter132 = this->arguments.begin(); _iter132 != this->arguments.end(); ++_iter132)
    {
      xfer += (*_iter132).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FunctionExpr &a, FunctionExpr &b) {
  using ::std::swap;
  swap(a.function_name, b.function_name);
  swap(a.arguments, b.arguments);
  swap(a.__isset, b.__isset);
}

FunctionExpr::FunctionExpr(const FunctionExpr& other133) {
  function_name = other133.function_name;
  arguments = other133.arguments;
  __isset = other133.__isset;
}
FunctionExpr& FunctionExpr::operator=(const FunctionExpr& other134) {
  function_name = other134.function_name;
  arguments = other134.arguments;
  __isset = other134.__isset;
  return *this;
}
void FunctionExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FunctionExpr(";
  out << "function_name=" << to_string(function_name);
  out << ", " << "arguments=" << to_string(arguments);
  out << ")";
}


BetweenExpr::~BetweenExpr() noexcept {
}


void BetweenExpr::__set_value(const ParsedExpr& val) {
  this->value = val;
}

void BetweenExpr::__set_upper_bound(const ParsedExpr& val) {
  this->upper_bound = val;
}

void BetweenExpr::__set_lower_bound(const ParsedExpr& val) {
  this->lower_bound = val;
}
std::ostream& operator<<(std::ostream& out, const BetweenExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BetweenExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->upper_bound.read(iprot);
          this->__isset.upper_bound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lower_bound.read(iprot);
          this->__isset.lower_bound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BetweenExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BetweenExpr");

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("upper_bound", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->upper_bound.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lower_bound", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->lower_bound.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BetweenExpr &a, BetweenExpr &b) {
  using ::std::swap;
  swap(a.value, b.value);
  swap(a.upper_bound, b.upper_bound);
  swap(a.lower_bound, b.lower_bound);
  swap(a.__isset, b.__isset);
}

BetweenExpr::BetweenExpr(const BetweenExpr& other135) {
  value = other135.value;
  upper_bound = other135.upper_bound;
  lower_bound = other135.lower_bound;
  __isset = other135.__isset;
}
BetweenExpr& BetweenExpr::operator=(const BetweenExpr& other136) {
  value = other136.value;
  upper_bound = other136.upper_bound;
  lower_bound = other136.lower_bound;
  __isset = other136.__isset;
  return *this;
}
void BetweenExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BetweenExpr(";
  out << "value=" << to_string(value);
  out << ", " << "upper_bound=" << to_string(upper_bound);
  out << ", " << "lower_bound=" << to_string(lower_bound);
  out << ")";
}


UpdateExpr::~UpdateExpr() noexcept {
}


void UpdateExpr::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void UpdateExpr::__set_value(const ParsedExpr& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const UpdateExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UpdateExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->value.read(iprot);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateExpr");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->value.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateExpr &a, UpdateExpr &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

UpdateExpr::UpdateExpr(const UpdateExpr& other137) {
  column_name = other137.column_name;
  value = other137.value;
  __isset = other137.__isset;
}
UpdateExpr& UpdateExpr::operator=(const UpdateExpr& other138) {
  column_name = other138.column_name;
  value = other138.value;
  __isset = other138.__isset;
  return *this;
}
void UpdateExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateExpr(";
  out << "column_name=" << to_string(column_name);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


OrderByExpr::~OrderByExpr() noexcept {
}


void OrderByExpr::__set_expr(const ParsedExpr& val) {
  this->expr = val;
}

void OrderByExpr::__set_asc(const bool val) {
  this->asc = val;
}
std::ostream& operator<<(std::ostream& out, const OrderByExpr& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t OrderByExpr::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->expr.read(iprot);
          this->__isset.expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->asc);
          this->__isset.asc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t OrderByExpr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("OrderByExpr");

  xfer += oprot->writeFieldBegin("expr", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("asc", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->asc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(OrderByExpr &a, OrderByExpr &b) {
  using ::std::swap;
  swap(a.expr, b.expr);
  swap(a.asc, b.asc);
  swap(a.__isset, b.__isset);
}

OrderByExpr::OrderByExpr(const OrderByExpr& other139) {
  expr = other139.expr;
  asc = other139.asc;
  __isset = other139.__isset;
}
OrderByExpr& OrderByExpr::operator=(const OrderByExpr& other140) {
  expr = other140.expr;
  asc = other140.asc;
  __isset = other140.__isset;
  return *this;
}
void OrderByExpr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "OrderByExpr(";
  out << "expr=" << to_string(expr);
  out << ", " << "asc=" << to_string(asc);
  out << ")";
}


Field::~Field() noexcept {
}


void Field::__set_parse_exprs(const std::vector<ParsedExpr> & val) {
  this->parse_exprs = val;
}
std::ostream& operator<<(std::ostream& out, const Field& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Field::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->parse_exprs.clear();
            uint32_t _size141;
            ::apache::thrift::protocol::TType _etype144;
            xfer += iprot->readListBegin(_etype144, _size141);
            this->parse_exprs.resize(_size141);
            uint32_t _i145;
            for (_i145 = 0; _i145 < _size141; ++_i145)
            {
              xfer += this->parse_exprs[_i145].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.parse_exprs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Field::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Field");

  xfer += oprot->writeFieldBegin("parse_exprs", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->parse_exprs.size()));
    std::vector<ParsedExpr> ::const_iterator _iter146;
    for (_iter146 = this->parse_exprs.begin(); _iter146 != this->parse_exprs.end(); ++_iter146)
    {
      xfer += (*_iter146).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Field &a, Field &b) {
  using ::std::swap;
  swap(a.parse_exprs, b.parse_exprs);
  swap(a.__isset, b.__isset);
}

Field::Field(const Field& other147) {
  parse_exprs = other147.parse_exprs;
  __isset = other147.__isset;
}
Field& Field::operator=(const Field& other148) {
  parse_exprs = other148.parse_exprs;
  __isset = other148.__isset;
  return *this;
}
void Field::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Field(";
  out << "parse_exprs=" << to_string(parse_exprs);
  out << ")";
}


ColumnField::~ColumnField() noexcept {
}


void ColumnField::__set_column_type(const ColumnType::type val) {
  this->column_type = val;
}

void ColumnField::__set_column_vectors(const std::vector<std::string> & val) {
  this->column_vectors = val;
}

void ColumnField::__set_column_name(const std::string& val) {
  this->column_name = val;
}
std::ostream& operator<<(std::ostream& out, const ColumnField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ColumnField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast149;
          xfer += iprot->readI32(ecast149);
          this->column_type = static_cast<ColumnType::type>(ecast149);
          this->__isset.column_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_vectors.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->column_vectors.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += iprot->readBinary(this->column_vectors[_i154]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_vectors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ColumnField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ColumnField");

  xfer += oprot->writeFieldBegin("column_type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->column_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_vectors", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_vectors.size()));
    std::vector<std::string> ::const_iterator _iter155;
    for (_iter155 = this->column_vectors.begin(); _iter155 != this->column_vectors.end(); ++_iter155)
    {
      xfer += oprot->writeBinary((*_iter155));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ColumnField &a, ColumnField &b) {
  using ::std::swap;
  swap(a.column_type, b.column_type);
  swap(a.column_vectors, b.column_vectors);
  swap(a.column_name, b.column_name);
  swap(a.__isset, b.__isset);
}

ColumnField::ColumnField(const ColumnField& other156) {
  column_type = other156.column_type;
  column_vectors = other156.column_vectors;
  column_name = other156.column_name;
  __isset = other156.__isset;
}
ColumnField& ColumnField::operator=(const ColumnField& other157) {
  column_type = other157.column_type;
  column_vectors = other157.column_vectors;
  column_name = other157.column_name;
  __isset = other157.__isset;
  return *this;
}
void ColumnField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ColumnField(";
  out << "column_type=" << to_string(column_type);
  out << ", " << "column_vectors=" << to_string(column_vectors);
  out << ", " << "column_name=" << to_string(column_name);
  out << ")";
}


ImportOption::~ImportOption() noexcept {
}


void ImportOption::__set_delimiter(const std::string& val) {
  this->delimiter = val;
}

void ImportOption::__set_copy_from(const bool val) {
  this->copy_from = val;
}

void ImportOption::__set_has_header(const bool val) {
  this->has_header = val;
}

void ImportOption::__set_copy_file_type(const CopyFileType::type val) {
  this->copy_file_type = val;
}
std::ostream& operator<<(std::ostream& out, const ImportOption& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ImportOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->delimiter);
          this->__isset.delimiter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->copy_from);
          this->__isset.copy_from = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->has_header);
          this->__isset.has_header = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast158;
          xfer += iprot->readI32(ecast158);
          this->copy_file_type = static_cast<CopyFileType::type>(ecast158);
          this->__isset.copy_file_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ImportOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ImportOption");

  xfer += oprot->writeFieldBegin("delimiter", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->delimiter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_from", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->copy_from);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("has_header", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->has_header);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("copy_file_type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(static_cast<int32_t>(this->copy_file_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ImportOption &a, ImportOption &b) {
  using ::std::swap;
  swap(a.delimiter, b.delimiter);
  swap(a.copy_from, b.copy_from);
  swap(a.has_header, b.has_header);
  swap(a.copy_file_type, b.copy_file_type);
  swap(a.__isset, b.__isset);
}

ImportOption::ImportOption(const ImportOption& other159) {
  delimiter = other159.delimiter;
  copy_from = other159.copy_from;
  has_header = other159.has_header;
  copy_file_type = other159.copy_file_type;
  __isset = other159.__isset;
}
ImportOption& ImportOption::operator=(const ImportOption& other160) {
  delimiter = other160.delimiter;
  copy_from = other160.copy_from;
  has_header = other160.has_header;
  copy_file_type = other160.copy_file_type;
  __isset = other160.__isset;
  return *this;
}
void ImportOption::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ImportOption(";
  out << "delimiter=" << to_string(delimiter);
  out << ", " << "copy_from=" << to_string(copy_from);
  out << ", " << "has_header=" << to_string(has_header);
  out << ", " << "copy_file_type=" << to_string(copy_file_type);
  out << ")";
}


UploadResponse::~UploadResponse() noexcept {
}


void UploadResponse::__set_success(const bool val) {
  this->success = val;
}

void UploadResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void UploadResponse::__set_can_skip(const bool val) {
  this->can_skip = val;
}
std::ostream& operator<<(std::ostream& out, const UploadResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UploadResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->can_skip);
          this->__isset.can_skip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UploadResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UploadResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("can_skip", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->can_skip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UploadResponse &a, UploadResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.error_msg, b.error_msg);
  swap(a.can_skip, b.can_skip);
  swap(a.__isset, b.__isset);
}

UploadResponse::UploadResponse(const UploadResponse& other161) {
  success = other161.success;
  error_msg = other161.error_msg;
  can_skip = other161.can_skip;
  __isset = other161.__isset;
}
UploadResponse& UploadResponse::operator=(const UploadResponse& other162) {
  success = other162.success;
  error_msg = other162.error_msg;
  can_skip = other162.can_skip;
  __isset = other162.__isset;
  return *this;
}
void UploadResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UploadResponse(";
  out << "success=" << to_string(success);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "can_skip=" << to_string(can_skip);
  out << ")";
}


CommonResponse::~CommonResponse() noexcept {
}


void CommonResponse::__set_success(const bool val) {
  this->success = val;
}

void CommonResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void CommonResponse::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const CommonResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommonResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommonResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommonResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommonResponse &a, CommonResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.error_msg, b.error_msg);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

CommonResponse::CommonResponse(const CommonResponse& other163) {
  success = other163.success;
  error_msg = other163.error_msg;
  session_id = other163.session_id;
  __isset = other163.__isset;
}
CommonResponse& CommonResponse::operator=(const CommonResponse& other164) {
  success = other164.success;
  error_msg = other164.error_msg;
  session_id = other164.session_id;
  __isset = other164.__isset;
  return *this;
}
void CommonResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommonResponse(";
  out << "success=" << to_string(success);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


CommonRequest::~CommonRequest() noexcept {
}


void CommonRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const CommonRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CommonRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommonRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommonRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommonRequest &a, CommonRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

CommonRequest::CommonRequest(const CommonRequest& other165) noexcept {
  session_id = other165.session_id;
  __isset = other165.__isset;
}
CommonRequest& CommonRequest::operator=(const CommonRequest& other166) noexcept {
  session_id = other166.session_id;
  __isset = other166.__isset;
  return *this;
}
void CommonRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommonRequest(";
  out << "session_id=" << to_string(session_id);
  out << ")";
}


ListDatabaseRequest::~ListDatabaseRequest() noexcept {
}


void ListDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ListDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListDatabaseRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListDatabaseRequest &a, ListDatabaseRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ListDatabaseRequest::ListDatabaseRequest(const ListDatabaseRequest& other167) noexcept {
  session_id = other167.session_id;
  __isset = other167.__isset;
}
ListDatabaseRequest& ListDatabaseRequest::operator=(const ListDatabaseRequest& other168) noexcept {
  session_id = other168.session_id;
  __isset = other168.__isset;
  return *this;
}
void ListDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListDatabaseRequest(";
  out << "session_id=" << to_string(session_id);
  out << ")";
}


ListDatabaseResponse::~ListDatabaseResponse() noexcept {
}


void ListDatabaseResponse::__set_success(const bool val) {
  this->success = val;
}

void ListDatabaseResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ListDatabaseResponse::__set_db_names(const std::vector<std::string> & val) {
  this->db_names = val;
}
std::ostream& operator<<(std::ostream& out, const ListDatabaseResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListDatabaseResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->db_names.clear();
            uint32_t _size169;
            ::apache::thrift::protocol::TType _etype172;
            xfer += iprot->readListBegin(_etype172, _size169);
            this->db_names.resize(_size169);
            uint32_t _i173;
            for (_i173 = 0; _i173 < _size169; ++_i173)
            {
              xfer += iprot->readString(this->db_names[_i173]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.db_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListDatabaseResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListDatabaseResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->db_names.size()));
    std::vector<std::string> ::const_iterator _iter174;
    for (_iter174 = this->db_names.begin(); _iter174 != this->db_names.end(); ++_iter174)
    {
      xfer += oprot->writeString((*_iter174));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListDatabaseResponse &a, ListDatabaseResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.error_msg, b.error_msg);
  swap(a.db_names, b.db_names);
  swap(a.__isset, b.__isset);
}

ListDatabaseResponse::ListDatabaseResponse(const ListDatabaseResponse& other175) {
  success = other175.success;
  error_msg = other175.error_msg;
  db_names = other175.db_names;
  __isset = other175.__isset;
}
ListDatabaseResponse& ListDatabaseResponse::operator=(const ListDatabaseResponse& other176) {
  success = other176.success;
  error_msg = other176.error_msg;
  db_names = other176.db_names;
  __isset = other176.__isset;
  return *this;
}
void ListDatabaseResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListDatabaseResponse(";
  out << "success=" << to_string(success);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "db_names=" << to_string(db_names);
  out << ")";
}


ListTableRequest::~ListTableRequest() noexcept {
}


void ListTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ListTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ListTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListTableRequest &a, ListTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ListTableRequest::ListTableRequest(const ListTableRequest& other177) {
  db_name = other177.db_name;
  session_id = other177.session_id;
  __isset = other177.__isset;
}
ListTableRequest& ListTableRequest::operator=(const ListTableRequest& other178) {
  db_name = other178.db_name;
  session_id = other178.session_id;
  __isset = other178.__isset;
  return *this;
}
void ListTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ListTableResponse::~ListTableResponse() noexcept {
}


void ListTableResponse::__set_success(const bool val) {
  this->success = val;
}

void ListTableResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ListTableResponse::__set_table_names(const std::vector<std::string> & val) {
  this->table_names = val;
}
std::ostream& operator<<(std::ostream& out, const ListTableResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ListTableResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->table_names.clear();
            uint32_t _size179;
            ::apache::thrift::protocol::TType _etype182;
            xfer += iprot->readListBegin(_etype182, _size179);
            this->table_names.resize(_size179);
            uint32_t _i183;
            for (_i183 = 0; _i183 < _size179; ++_i183)
            {
              xfer += iprot->readString(this->table_names[_i183]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.table_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ListTableResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ListTableResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->table_names.size()));
    std::vector<std::string> ::const_iterator _iter184;
    for (_iter184 = this->table_names.begin(); _iter184 != this->table_names.end(); ++_iter184)
    {
      xfer += oprot->writeString((*_iter184));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ListTableResponse &a, ListTableResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.error_msg, b.error_msg);
  swap(a.table_names, b.table_names);
  swap(a.__isset, b.__isset);
}

ListTableResponse::ListTableResponse(const ListTableResponse& other185) {
  success = other185.success;
  error_msg = other185.error_msg;
  table_names = other185.table_names;
  __isset = other185.__isset;
}
ListTableResponse& ListTableResponse::operator=(const ListTableResponse& other186) {
  success = other186.success;
  error_msg = other186.error_msg;
  table_names = other186.table_names;
  __isset = other186.__isset;
  return *this;
}
void ListTableResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ListTableResponse(";
  out << "success=" << to_string(success);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "table_names=" << to_string(table_names);
  out << ")";
}


DescribeDatabaseRequest::~DescribeDatabaseRequest() noexcept {
}


void DescribeDatabaseRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DescribeDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const DescribeDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DescribeDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DescribeDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DescribeDatabaseRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DescribeDatabaseRequest &a, DescribeDatabaseRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

DescribeDatabaseRequest::DescribeDatabaseRequest(const DescribeDatabaseRequest& other187) {
  db_name = other187.db_name;
  session_id = other187.session_id;
  __isset = other187.__isset;
}
DescribeDatabaseRequest& DescribeDatabaseRequest::operator=(const DescribeDatabaseRequest& other188) {
  db_name = other188.db_name;
  session_id = other188.session_id;
  __isset = other188.__isset;
  return *this;
}
void DescribeDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DescribeDatabaseRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


DescribeDatabaseResponse::~DescribeDatabaseResponse() noexcept {
}


void DescribeDatabaseResponse::__set_success(const bool val) {
  this->success = val;
}

void DescribeDatabaseResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void DescribeDatabaseResponse::__set_num_segments(const int64_t val) {
  this->num_segments = val;
}

void DescribeDatabaseResponse::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}

void DescribeDatabaseResponse::__set_num_blocks(const int64_t val) {
  this->num_blocks = val;
}
std::ostream& operator<<(std::ostream& out, const DescribeDatabaseResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DescribeDatabaseResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_segments);
          this->__isset.num_segments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_blocks);
          this->__isset.num_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DescribeDatabaseResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DescribeDatabaseResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_segments", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_segments);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_blocks", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_blocks);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DescribeDatabaseResponse &a, DescribeDatabaseResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.error_msg, b.error_msg);
  swap(a.num_segments, b.num_segments);
  swap(a.num_rows, b.num_rows);
  swap(a.num_blocks, b.num_blocks);
  swap(a.__isset, b.__isset);
}

DescribeDatabaseResponse::DescribeDatabaseResponse(const DescribeDatabaseResponse& other189) {
  success = other189.success;
  error_msg = other189.error_msg;
  num_segments = other189.num_segments;
  num_rows = other189.num_rows;
  num_blocks = other189.num_blocks;
  __isset = other189.__isset;
}
DescribeDatabaseResponse& DescribeDatabaseResponse::operator=(const DescribeDatabaseResponse& other190) {
  success = other190.success;
  error_msg = other190.error_msg;
  num_segments = other190.num_segments;
  num_rows = other190.num_rows;
  num_blocks = other190.num_blocks;
  __isset = other190.__isset;
  return *this;
}
void DescribeDatabaseResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DescribeDatabaseResponse(";
  out << "success=" << to_string(success);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "num_segments=" << to_string(num_segments);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ", " << "num_blocks=" << to_string(num_blocks);
  out << ")";
}


DescribeTableRequest::~DescribeTableRequest() noexcept {
}


void DescribeTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DescribeTableRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DescribeTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const DescribeTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DescribeTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DescribeTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DescribeTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DescribeTableRequest &a, DescribeTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

DescribeTableRequest::DescribeTableRequest(const DescribeTableRequest& other191) {
  db_name = other191.db_name;
  table_name = other191.table_name;
  session_id = other191.session_id;
  __isset = other191.__isset;
}
DescribeTableRequest& DescribeTableRequest::operator=(const DescribeTableRequest& other192) {
  db_name = other192.db_name;
  table_name = other192.table_name;
  session_id = other192.session_id;
  __isset = other192.__isset;
  return *this;
}
void DescribeTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DescribeTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


DescribeTableResponse::~DescribeTableResponse() noexcept {
}


void DescribeTableResponse::__set_success(const bool val) {
  this->success = val;
}

void DescribeTableResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void DescribeTableResponse::__set_num_segments(const int64_t val) {
  this->num_segments = val;
}

void DescribeTableResponse::__set_num_rows(const int64_t val) {
  this->num_rows = val;
}

void DescribeTableResponse::__set_num_blocks(const int64_t val) {
  this->num_blocks = val;
}
std::ostream& operator<<(std::ostream& out, const DescribeTableResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DescribeTableResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_segments);
          this->__isset.num_segments = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_rows);
          this->__isset.num_rows = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->num_blocks);
          this->__isset.num_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DescribeTableResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DescribeTableResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_segments", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->num_segments);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_rows", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->num_rows);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("num_blocks", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->num_blocks);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DescribeTableResponse &a, DescribeTableResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.error_msg, b.error_msg);
  swap(a.num_segments, b.num_segments);
  swap(a.num_rows, b.num_rows);
  swap(a.num_blocks, b.num_blocks);
  swap(a.__isset, b.__isset);
}

DescribeTableResponse::DescribeTableResponse(const DescribeTableResponse& other193) {
  success = other193.success;
  error_msg = other193.error_msg;
  num_segments = other193.num_segments;
  num_rows = other193.num_rows;
  num_blocks = other193.num_blocks;
  __isset = other193.__isset;
}
DescribeTableResponse& DescribeTableResponse::operator=(const DescribeTableResponse& other194) {
  success = other194.success;
  error_msg = other194.error_msg;
  num_segments = other194.num_segments;
  num_rows = other194.num_rows;
  num_blocks = other194.num_blocks;
  __isset = other194.__isset;
  return *this;
}
void DescribeTableResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DescribeTableResponse(";
  out << "success=" << to_string(success);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "num_segments=" << to_string(num_segments);
  out << ", " << "num_rows=" << to_string(num_rows);
  out << ", " << "num_blocks=" << to_string(num_blocks);
  out << ")";
}


GetTableRequest::~GetTableRequest() noexcept {
}


void GetTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void GetTableRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void GetTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const GetTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetTableRequest &a, GetTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

GetTableRequest::GetTableRequest(const GetTableRequest& other195) {
  db_name = other195.db_name;
  table_name = other195.table_name;
  session_id = other195.session_id;
  __isset = other195.__isset;
}
GetTableRequest& GetTableRequest::operator=(const GetTableRequest& other196) {
  db_name = other196.db_name;
  table_name = other196.table_name;
  session_id = other196.session_id;
  __isset = other196.__isset;
  return *this;
}
void GetTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


IndexInfo::~IndexInfo() noexcept {
}


void IndexInfo::__set_column_name(const std::string& val) {
  this->column_name = val;
}

void IndexInfo::__set_index_type(const IndexType::type val) {
  this->index_type = val;
}

void IndexInfo::__set_index_param_list(const std::vector<InitParameter> & val) {
  this->index_param_list = val;
}
std::ostream& operator<<(std::ostream& out, const IndexInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IndexInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->column_name);
          this->__isset.column_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast197;
          xfer += iprot->readI32(ecast197);
          this->index_type = static_cast<IndexType::type>(ecast197);
          this->__isset.index_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->index_param_list.clear();
            uint32_t _size198;
            ::apache::thrift::protocol::TType _etype201;
            xfer += iprot->readListBegin(_etype201, _size198);
            this->index_param_list.resize(_size198);
            uint32_t _i202;
            for (_i202 = 0; _i202 < _size198; ++_i202)
            {
              xfer += this->index_param_list[_i202].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.index_param_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IndexInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IndexInfo");

  xfer += oprot->writeFieldBegin("column_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->column_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_type", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->index_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_param_list", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->index_param_list.size()));
    std::vector<InitParameter> ::const_iterator _iter203;
    for (_iter203 = this->index_param_list.begin(); _iter203 != this->index_param_list.end(); ++_iter203)
    {
      xfer += (*_iter203).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IndexInfo &a, IndexInfo &b) {
  using ::std::swap;
  swap(a.column_name, b.column_name);
  swap(a.index_type, b.index_type);
  swap(a.index_param_list, b.index_param_list);
  swap(a.__isset, b.__isset);
}

IndexInfo::IndexInfo(const IndexInfo& other204) {
  column_name = other204.column_name;
  index_type = other204.index_type;
  index_param_list = other204.index_param_list;
  __isset = other204.__isset;
}
IndexInfo& IndexInfo::operator=(const IndexInfo& other205) {
  column_name = other205.column_name;
  index_type = other205.index_type;
  index_param_list = other205.index_param_list;
  __isset = other205.__isset;
  return *this;
}
void IndexInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IndexInfo(";
  out << "column_name=" << to_string(column_name);
  out << ", " << "index_type=" << to_string(index_type);
  out << ", " << "index_param_list=" << to_string(index_param_list);
  out << ")";
}


CreateIndexRequest::~CreateIndexRequest() noexcept {
}


void CreateIndexRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CreateIndexRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void CreateIndexRequest::__set_index_name(const std::string& val) {
  this->index_name = val;
}

void CreateIndexRequest::__set_index_info_list(const std::vector<IndexInfo> & val) {
  this->index_info_list = val;
}

void CreateIndexRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateIndexRequest::__set_option(const Option& val) {
  this->option = val;
__isset.option = true;
}
std::ostream& operator<<(std::ostream& out, const CreateIndexRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateIndexRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->index_info_list.clear();
            uint32_t _size206;
            ::apache::thrift::protocol::TType _etype209;
            xfer += iprot->readListBegin(_etype209, _size206);
            this->index_info_list.resize(_size206);
            uint32_t _i210;
            for (_i210 = 0; _i210 < _size206; ++_i210)
            {
              xfer += this->index_info_list[_i210].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.index_info_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->option.read(iprot);
          this->__isset.option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateIndexRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateIndexRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_info_list", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->index_info_list.size()));
    std::vector<IndexInfo> ::const_iterator _iter211;
    for (_iter211 = this->index_info_list.begin(); _iter211 != this->index_info_list.end(); ++_iter211)
    {
      xfer += (*_iter211).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.option) {
    xfer += oprot->writeFieldBegin("option", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->option.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateIndexRequest &a, CreateIndexRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.index_name, b.index_name);
  swap(a.index_info_list, b.index_info_list);
  swap(a.session_id, b.session_id);
  swap(a.option, b.option);
  swap(a.__isset, b.__isset);
}

CreateIndexRequest::CreateIndexRequest(const CreateIndexRequest& other212) {
  db_name = other212.db_name;
  table_name = other212.table_name;
  index_name = other212.index_name;
  index_info_list = other212.index_info_list;
  session_id = other212.session_id;
  option = other212.option;
  __isset = other212.__isset;
}
CreateIndexRequest& CreateIndexRequest::operator=(const CreateIndexRequest& other213) {
  db_name = other213.db_name;
  table_name = other213.table_name;
  index_name = other213.index_name;
  index_info_list = other213.index_info_list;
  session_id = other213.session_id;
  option = other213.option;
  __isset = other213.__isset;
  return *this;
}
void CreateIndexRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateIndexRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "index_name=" << to_string(index_name);
  out << ", " << "index_info_list=" << to_string(index_info_list);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "option="; (__isset.option ? (out << to_string(option)) : (out << "<null>"));
  out << ")";
}


DropIndexRequest::~DropIndexRequest() noexcept {
}


void DropIndexRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DropIndexRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DropIndexRequest::__set_index_name(const std::string& val) {
  this->index_name = val;
}

void DropIndexRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const DropIndexRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropIndexRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->index_name);
          this->__isset.index_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropIndexRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropIndexRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->index_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropIndexRequest &a, DropIndexRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.index_name, b.index_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

DropIndexRequest::DropIndexRequest(const DropIndexRequest& other214) {
  db_name = other214.db_name;
  table_name = other214.table_name;
  index_name = other214.index_name;
  session_id = other214.session_id;
  __isset = other214.__isset;
}
DropIndexRequest& DropIndexRequest::operator=(const DropIndexRequest& other215) {
  db_name = other215.db_name;
  table_name = other215.table_name;
  index_name = other215.index_name;
  session_id = other215.session_id;
  __isset = other215.__isset;
  return *this;
}
void DropIndexRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropIndexRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "index_name=" << to_string(index_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


GetDatabaseRequest::~GetDatabaseRequest() noexcept {
}


void GetDatabaseRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void GetDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const GetDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t GetDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GetDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GetDatabaseRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GetDatabaseRequest &a, GetDatabaseRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

GetDatabaseRequest::GetDatabaseRequest(const GetDatabaseRequest& other216) {
  db_name = other216.db_name;
  session_id = other216.session_id;
  __isset = other216.__isset;
}
GetDatabaseRequest& GetDatabaseRequest::operator=(const GetDatabaseRequest& other217) {
  db_name = other217.db_name;
  session_id = other217.session_id;
  __isset = other217.__isset;
  return *this;
}
void GetDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GetDatabaseRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


CreateDatabaseRequest::~CreateDatabaseRequest() noexcept {
}


void CreateDatabaseRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CreateDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateDatabaseRequest::__set_option(const Option& val) {
  this->option = val;
}
std::ostream& operator<<(std::ostream& out, const CreateDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->option.read(iprot);
          this->__isset.option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateDatabaseRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("option", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateDatabaseRequest &a, CreateDatabaseRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.option, b.option);
  swap(a.__isset, b.__isset);
}

CreateDatabaseRequest::CreateDatabaseRequest(const CreateDatabaseRequest& other218) {
  db_name = other218.db_name;
  session_id = other218.session_id;
  option = other218.option;
  __isset = other218.__isset;
}
CreateDatabaseRequest& CreateDatabaseRequest::operator=(const CreateDatabaseRequest& other219) {
  db_name = other219.db_name;
  session_id = other219.session_id;
  option = other219.option;
  __isset = other219.__isset;
  return *this;
}
void CreateDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateDatabaseRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "option=" << to_string(option);
  out << ")";
}


DropDatabaseRequest::~DropDatabaseRequest() noexcept {
}


void DropDatabaseRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DropDatabaseRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void DropDatabaseRequest::__set_option(const Option& val) {
  this->option = val;
}
std::ostream& operator<<(std::ostream& out, const DropDatabaseRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropDatabaseRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->option.read(iprot);
          this->__isset.option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropDatabaseRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropDatabaseRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("option", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropDatabaseRequest &a, DropDatabaseRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.session_id, b.session_id);
  swap(a.option, b.option);
  swap(a.__isset, b.__isset);
}

DropDatabaseRequest::DropDatabaseRequest(const DropDatabaseRequest& other220) {
  db_name = other220.db_name;
  session_id = other220.session_id;
  option = other220.option;
  __isset = other220.__isset;
}
DropDatabaseRequest& DropDatabaseRequest::operator=(const DropDatabaseRequest& other221) {
  db_name = other221.db_name;
  session_id = other221.session_id;
  option = other221.option;
  __isset = other221.__isset;
  return *this;
}
void DropDatabaseRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropDatabaseRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "option=" << to_string(option);
  out << ")";
}


CreateTableRequest::~CreateTableRequest() noexcept {
}


void CreateTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void CreateTableRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void CreateTableRequest::__set_column_defs(const std::vector<ColumnDef> & val) {
  this->column_defs = val;
}

void CreateTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void CreateTableRequest::__set_option(const Option& val) {
  this->option = val;
}
std::ostream& operator<<(std::ostream& out, const CreateTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CreateTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_defs.clear();
            uint32_t _size222;
            ::apache::thrift::protocol::TType _etype225;
            xfer += iprot->readListBegin(_etype225, _size222);
            this->column_defs.resize(_size222);
            uint32_t _i226;
            for (_i226 = 0; _i226 < _size222; ++_i226)
            {
              xfer += this->column_defs[_i226].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->option.read(iprot);
          this->__isset.option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreateTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreateTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_defs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_defs.size()));
    std::vector<ColumnDef> ::const_iterator _iter227;
    for (_iter227 = this->column_defs.begin(); _iter227 != this->column_defs.end(); ++_iter227)
    {
      xfer += (*_iter227).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("option", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreateTableRequest &a, CreateTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.column_defs, b.column_defs);
  swap(a.session_id, b.session_id);
  swap(a.option, b.option);
  swap(a.__isset, b.__isset);
}

CreateTableRequest::CreateTableRequest(const CreateTableRequest& other228) {
  db_name = other228.db_name;
  table_name = other228.table_name;
  column_defs = other228.column_defs;
  session_id = other228.session_id;
  option = other228.option;
  __isset = other228.__isset;
}
CreateTableRequest& CreateTableRequest::operator=(const CreateTableRequest& other229) {
  db_name = other229.db_name;
  table_name = other229.table_name;
  column_defs = other229.column_defs;
  session_id = other229.session_id;
  option = other229.option;
  __isset = other229.__isset;
  return *this;
}
void CreateTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreateTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_defs=" << to_string(column_defs);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "option=" << to_string(option);
  out << ")";
}


DropTableRequest::~DropTableRequest() noexcept {
}


void DropTableRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DropTableRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DropTableRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void DropTableRequest::__set_options(const DropTableOptions& val) {
  this->options = val;
}
std::ostream& operator<<(std::ostream& out, const DropTableRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DropTableRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->options.read(iprot);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DropTableRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DropTableRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->options.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DropTableRequest &a, DropTableRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.session_id, b.session_id);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

DropTableRequest::DropTableRequest(const DropTableRequest& other230) {
  db_name = other230.db_name;
  table_name = other230.table_name;
  session_id = other230.session_id;
  options = other230.options;
  __isset = other230.__isset;
}
DropTableRequest& DropTableRequest::operator=(const DropTableRequest& other231) {
  db_name = other231.db_name;
  table_name = other231.table_name;
  session_id = other231.session_id;
  options = other231.options;
  __isset = other231.__isset;
  return *this;
}
void DropTableRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DropTableRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "options=" << to_string(options);
  out << ")";
}


InsertRequest::~InsertRequest() noexcept {
}


void InsertRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void InsertRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void InsertRequest::__set_column_names(const std::vector<std::string> & val) {
  this->column_names = val;
}

void InsertRequest::__set_fields(const std::vector<Field> & val) {
  this->fields = val;
}

void InsertRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const InsertRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t InsertRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_names.clear();
            uint32_t _size232;
            ::apache::thrift::protocol::TType _etype235;
            xfer += iprot->readListBegin(_etype235, _size232);
            this->column_names.resize(_size232);
            uint32_t _i236;
            for (_i236 = 0; _i236 < _size232; ++_i236)
            {
              xfer += iprot->readString(this->column_names[_i236]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size237;
            ::apache::thrift::protocol::TType _etype240;
            xfer += iprot->readListBegin(_etype240, _size237);
            this->fields.resize(_size237);
            uint32_t _i241;
            for (_i241 = 0; _i241 < _size237; ++_i241)
            {
              xfer += this->fields[_i241].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InsertRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InsertRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_names", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->column_names.size()));
    std::vector<std::string> ::const_iterator _iter242;
    for (_iter242 = this->column_names.begin(); _iter242 != this->column_names.end(); ++_iter242)
    {
      xfer += oprot->writeString((*_iter242));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<Field> ::const_iterator _iter243;
    for (_iter243 = this->fields.begin(); _iter243 != this->fields.end(); ++_iter243)
    {
      xfer += (*_iter243).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InsertRequest &a, InsertRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.column_names, b.column_names);
  swap(a.fields, b.fields);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

InsertRequest::InsertRequest(const InsertRequest& other244) {
  db_name = other244.db_name;
  table_name = other244.table_name;
  column_names = other244.column_names;
  fields = other244.fields;
  session_id = other244.session_id;
  __isset = other244.__isset;
}
InsertRequest& InsertRequest::operator=(const InsertRequest& other245) {
  db_name = other245.db_name;
  table_name = other245.table_name;
  column_names = other245.column_names;
  fields = other245.fields;
  session_id = other245.session_id;
  __isset = other245.__isset;
  return *this;
}
void InsertRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InsertRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "column_names=" << to_string(column_names);
  out << ", " << "fields=" << to_string(fields);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


ImportRequest::~ImportRequest() noexcept {
}


void ImportRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ImportRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ImportRequest::__set_file_name(const std::string& val) {
  this->file_name = val;
}

void ImportRequest::__set_file_content(const std::string& val) {
  this->file_content = val;
}

void ImportRequest::__set_import_option(const ImportOption& val) {
  this->import_option = val;
}

void ImportRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const ImportRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ImportRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_name);
          this->__isset.file_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->file_content);
          this->__isset.file_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->import_option.read(iprot);
          this->__isset.import_option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ImportRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ImportRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->file_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_content", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->file_content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("import_option", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->import_option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ImportRequest &a, ImportRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.file_name, b.file_name);
  swap(a.file_content, b.file_content);
  swap(a.import_option, b.import_option);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

ImportRequest::ImportRequest(const ImportRequest& other246) {
  db_name = other246.db_name;
  table_name = other246.table_name;
  file_name = other246.file_name;
  file_content = other246.file_content;
  import_option = other246.import_option;
  session_id = other246.session_id;
  __isset = other246.__isset;
}
ImportRequest& ImportRequest::operator=(const ImportRequest& other247) {
  db_name = other247.db_name;
  table_name = other247.table_name;
  file_name = other247.file_name;
  file_content = other247.file_content;
  import_option = other247.import_option;
  session_id = other247.session_id;
  __isset = other247.__isset;
  return *this;
}
void ImportRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ImportRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "file_name=" << to_string(file_name);
  out << ", " << "file_content=" << to_string(file_content);
  out << ", " << "import_option=" << to_string(import_option);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


FileChunk::~FileChunk() noexcept {
}


void FileChunk::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void FileChunk::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void FileChunk::__set_file_name(const std::string& val) {
  this->file_name = val;
}

void FileChunk::__set_data(const std::string& val) {
  this->data = val;
}

void FileChunk::__set_index(const int32_t val) {
  this->index = val;
}

void FileChunk::__set_is_last(const bool val) {
  this->is_last = val;
}

void FileChunk::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void FileChunk::__set_total_size(const int64_t val) {
  this->total_size = val;
}
std::ostream& operator<<(std::ostream& out, const FileChunk& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FileChunk::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->file_name);
          this->__isset.file_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->is_last);
          this->__isset.is_last = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->total_size);
          this->__isset.total_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FileChunk::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FileChunk");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("file_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->file_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("is_last", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->is_last);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("total_size", ::apache::thrift::protocol::T_I64, 8);
  xfer += oprot->writeI64(this->total_size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FileChunk &a, FileChunk &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.file_name, b.file_name);
  swap(a.data, b.data);
  swap(a.index, b.index);
  swap(a.is_last, b.is_last);
  swap(a.session_id, b.session_id);
  swap(a.total_size, b.total_size);
  swap(a.__isset, b.__isset);
}

FileChunk::FileChunk(const FileChunk& other248) {
  db_name = other248.db_name;
  table_name = other248.table_name;
  file_name = other248.file_name;
  data = other248.data;
  index = other248.index;
  is_last = other248.is_last;
  session_id = other248.session_id;
  total_size = other248.total_size;
  __isset = other248.__isset;
}
FileChunk& FileChunk::operator=(const FileChunk& other249) {
  db_name = other249.db_name;
  table_name = other249.table_name;
  file_name = other249.file_name;
  data = other249.data;
  index = other249.index;
  is_last = other249.is_last;
  session_id = other249.session_id;
  total_size = other249.total_size;
  __isset = other249.__isset;
  return *this;
}
void FileChunk::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FileChunk(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "file_name=" << to_string(file_name);
  out << ", " << "data=" << to_string(data);
  out << ", " << "index=" << to_string(index);
  out << ", " << "is_last=" << to_string(is_last);
  out << ", " << "session_id=" << to_string(session_id);
  out << ", " << "total_size=" << to_string(total_size);
  out << ")";
}


ExplainRequest::~ExplainRequest() noexcept {
}


void ExplainRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void ExplainRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void ExplainRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void ExplainRequest::__set_select_list(const std::vector<ParsedExpr> & val) {
  this->select_list = val;
}

void ExplainRequest::__set_search_expr(const SearchExpr& val) {
  this->search_expr = val;
__isset.search_expr = true;
}

void ExplainRequest::__set_where_expr(const ParsedExpr& val) {
  this->where_expr = val;
__isset.where_expr = true;
}

void ExplainRequest::__set_group_by_list(const std::vector<ParsedExpr> & val) {
  this->group_by_list = val;
__isset.group_by_list = true;
}

void ExplainRequest::__set_having_expr(const ParsedExpr& val) {
  this->having_expr = val;
__isset.having_expr = true;
}

void ExplainRequest::__set_limit_expr(const ParsedExpr& val) {
  this->limit_expr = val;
__isset.limit_expr = true;
}

void ExplainRequest::__set_offset_expr(const ParsedExpr& val) {
  this->offset_expr = val;
__isset.offset_expr = true;
}

void ExplainRequest::__set_order_by_list(const std::vector<OrderByExpr> & val) {
  this->order_by_list = val;
__isset.order_by_list = true;
}

void ExplainRequest::__set_explain_type(const ExplainType::type val) {
  this->explain_type = val;
}
std::ostream& operator<<(std::ostream& out, const ExplainRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExplainRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->select_list.clear();
            uint32_t _size250;
            ::apache::thrift::protocol::TType _etype253;
            xfer += iprot->readListBegin(_etype253, _size250);
            this->select_list.resize(_size250);
            uint32_t _i254;
            for (_i254 = 0; _i254 < _size250; ++_i254)
            {
              xfer += this->select_list[_i254].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.select_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->search_expr.read(iprot);
          this->__isset.search_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->where_expr.read(iprot);
          this->__isset.where_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group_by_list.clear();
            uint32_t _size255;
            ::apache::thrift::protocol::TType _etype258;
            xfer += iprot->readListBegin(_etype258, _size255);
            this->group_by_list.resize(_size255);
            uint32_t _i259;
            for (_i259 = 0; _i259 < _size255; ++_i259)
            {
              xfer += this->group_by_list[_i259].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.group_by_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->having_expr.read(iprot);
          this->__isset.having_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->limit_expr.read(iprot);
          this->__isset.limit_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->offset_expr.read(iprot);
          this->__isset.offset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->order_by_list.clear();
            uint32_t _size260;
            ::apache::thrift::protocol::TType _etype263;
            xfer += iprot->readListBegin(_etype263, _size260);
            this->order_by_list.resize(_size260);
            uint32_t _i264;
            for (_i264 = 0; _i264 < _size260; ++_i264)
            {
              xfer += this->order_by_list[_i264].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.order_by_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast265;
          xfer += iprot->readI32(ecast265);
          this->explain_type = static_cast<ExplainType::type>(ecast265);
          this->__isset.explain_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExplainRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExplainRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_list", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->select_list.size()));
    std::vector<ParsedExpr> ::const_iterator _iter266;
    for (_iter266 = this->select_list.begin(); _iter266 != this->select_list.end(); ++_iter266)
    {
      xfer += (*_iter266).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.search_expr) {
    xfer += oprot->writeFieldBegin("search_expr", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->search_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.where_expr) {
    xfer += oprot->writeFieldBegin("where_expr", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->where_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_by_list) {
    xfer += oprot->writeFieldBegin("group_by_list", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->group_by_list.size()));
      std::vector<ParsedExpr> ::const_iterator _iter267;
      for (_iter267 = this->group_by_list.begin(); _iter267 != this->group_by_list.end(); ++_iter267)
      {
        xfer += (*_iter267).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.having_expr) {
    xfer += oprot->writeFieldBegin("having_expr", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->having_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit_expr) {
    xfer += oprot->writeFieldBegin("limit_expr", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->limit_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset_expr) {
    xfer += oprot->writeFieldBegin("offset_expr", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->offset_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order_by_list) {
    xfer += oprot->writeFieldBegin("order_by_list", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->order_by_list.size()));
      std::vector<OrderByExpr> ::const_iterator _iter268;
      for (_iter268 = this->order_by_list.begin(); _iter268 != this->order_by_list.end(); ++_iter268)
      {
        xfer += (*_iter268).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("explain_type", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(static_cast<int32_t>(this->explain_type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExplainRequest &a, ExplainRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.select_list, b.select_list);
  swap(a.search_expr, b.search_expr);
  swap(a.where_expr, b.where_expr);
  swap(a.group_by_list, b.group_by_list);
  swap(a.having_expr, b.having_expr);
  swap(a.limit_expr, b.limit_expr);
  swap(a.offset_expr, b.offset_expr);
  swap(a.order_by_list, b.order_by_list);
  swap(a.explain_type, b.explain_type);
  swap(a.__isset, b.__isset);
}

ExplainRequest::ExplainRequest(const ExplainRequest& other269) {
  session_id = other269.session_id;
  db_name = other269.db_name;
  table_name = other269.table_name;
  select_list = other269.select_list;
  search_expr = other269.search_expr;
  where_expr = other269.where_expr;
  group_by_list = other269.group_by_list;
  having_expr = other269.having_expr;
  limit_expr = other269.limit_expr;
  offset_expr = other269.offset_expr;
  order_by_list = other269.order_by_list;
  explain_type = other269.explain_type;
  __isset = other269.__isset;
}
ExplainRequest& ExplainRequest::operator=(const ExplainRequest& other270) {
  session_id = other270.session_id;
  db_name = other270.db_name;
  table_name = other270.table_name;
  select_list = other270.select_list;
  search_expr = other270.search_expr;
  where_expr = other270.where_expr;
  group_by_list = other270.group_by_list;
  having_expr = other270.having_expr;
  limit_expr = other270.limit_expr;
  offset_expr = other270.offset_expr;
  order_by_list = other270.order_by_list;
  explain_type = other270.explain_type;
  __isset = other270.__isset;
  return *this;
}
void ExplainRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExplainRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "select_list=" << to_string(select_list);
  out << ", " << "search_expr="; (__isset.search_expr ? (out << to_string(search_expr)) : (out << "<null>"));
  out << ", " << "where_expr="; (__isset.where_expr ? (out << to_string(where_expr)) : (out << "<null>"));
  out << ", " << "group_by_list="; (__isset.group_by_list ? (out << to_string(group_by_list)) : (out << "<null>"));
  out << ", " << "having_expr="; (__isset.having_expr ? (out << to_string(having_expr)) : (out << "<null>"));
  out << ", " << "limit_expr="; (__isset.limit_expr ? (out << to_string(limit_expr)) : (out << "<null>"));
  out << ", " << "offset_expr="; (__isset.offset_expr ? (out << to_string(offset_expr)) : (out << "<null>"));
  out << ", " << "order_by_list="; (__isset.order_by_list ? (out << to_string(order_by_list)) : (out << "<null>"));
  out << ", " << "explain_type=" << to_string(explain_type);
  out << ")";
}


ExplainResponse::~ExplainResponse() noexcept {
}


void ExplainResponse::__set_success(const bool val) {
  this->success = val;
}

void ExplainResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void ExplainResponse::__set_column_defs(const std::vector<ColumnDef> & val) {
  this->column_defs = val;
}

void ExplainResponse::__set_column_fields(const std::vector<ColumnField> & val) {
  this->column_fields = val;
}
std::ostream& operator<<(std::ostream& out, const ExplainResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ExplainResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_defs.clear();
            uint32_t _size271;
            ::apache::thrift::protocol::TType _etype274;
            xfer += iprot->readListBegin(_etype274, _size271);
            this->column_defs.resize(_size271);
            uint32_t _i275;
            for (_i275 = 0; _i275 < _size271; ++_i275)
            {
              xfer += this->column_defs[_i275].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_fields.clear();
            uint32_t _size276;
            ::apache::thrift::protocol::TType _etype279;
            xfer += iprot->readListBegin(_etype279, _size276);
            this->column_fields.resize(_size276);
            uint32_t _i280;
            for (_i280 = 0; _i280 < _size276; ++_i280)
            {
              xfer += this->column_fields[_i280].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ExplainResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ExplainResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_defs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_defs.size()));
    std::vector<ColumnDef> ::const_iterator _iter281;
    for (_iter281 = this->column_defs.begin(); _iter281 != this->column_defs.end(); ++_iter281)
    {
      xfer += (*_iter281).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_fields.size()));
    std::vector<ColumnField> ::const_iterator _iter282;
    for (_iter282 = this->column_fields.begin(); _iter282 != this->column_fields.end(); ++_iter282)
    {
      xfer += (*_iter282).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ExplainResponse &a, ExplainResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.error_msg, b.error_msg);
  swap(a.column_defs, b.column_defs);
  swap(a.column_fields, b.column_fields);
  swap(a.__isset, b.__isset);
}

ExplainResponse::ExplainResponse(const ExplainResponse& other283) {
  success = other283.success;
  error_msg = other283.error_msg;
  column_defs = other283.column_defs;
  column_fields = other283.column_fields;
  __isset = other283.__isset;
}
ExplainResponse& ExplainResponse::operator=(const ExplainResponse& other284) {
  success = other284.success;
  error_msg = other284.error_msg;
  column_defs = other284.column_defs;
  column_fields = other284.column_fields;
  __isset = other284.__isset;
  return *this;
}
void ExplainResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ExplainResponse(";
  out << "success=" << to_string(success);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "column_defs=" << to_string(column_defs);
  out << ", " << "column_fields=" << to_string(column_fields);
  out << ")";
}


SelectRequest::~SelectRequest() noexcept {
}


void SelectRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}

void SelectRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void SelectRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void SelectRequest::__set_select_list(const std::vector<ParsedExpr> & val) {
  this->select_list = val;
}

void SelectRequest::__set_search_expr(const SearchExpr& val) {
  this->search_expr = val;
__isset.search_expr = true;
}

void SelectRequest::__set_where_expr(const ParsedExpr& val) {
  this->where_expr = val;
__isset.where_expr = true;
}

void SelectRequest::__set_group_by_list(const std::vector<ParsedExpr> & val) {
  this->group_by_list = val;
__isset.group_by_list = true;
}

void SelectRequest::__set_having_expr(const ParsedExpr& val) {
  this->having_expr = val;
__isset.having_expr = true;
}

void SelectRequest::__set_limit_expr(const ParsedExpr& val) {
  this->limit_expr = val;
__isset.limit_expr = true;
}

void SelectRequest::__set_offset_expr(const ParsedExpr& val) {
  this->offset_expr = val;
__isset.offset_expr = true;
}

void SelectRequest::__set_order_by_list(const std::vector<OrderByExpr> & val) {
  this->order_by_list = val;
__isset.order_by_list = true;
}
std::ostream& operator<<(std::ostream& out, const SelectRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SelectRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->select_list.clear();
            uint32_t _size285;
            ::apache::thrift::protocol::TType _etype288;
            xfer += iprot->readListBegin(_etype288, _size285);
            this->select_list.resize(_size285);
            uint32_t _i289;
            for (_i289 = 0; _i289 < _size285; ++_i289)
            {
              xfer += this->select_list[_i289].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.select_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->search_expr.read(iprot);
          this->__isset.search_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->where_expr.read(iprot);
          this->__isset.where_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->group_by_list.clear();
            uint32_t _size290;
            ::apache::thrift::protocol::TType _etype293;
            xfer += iprot->readListBegin(_etype293, _size290);
            this->group_by_list.resize(_size290);
            uint32_t _i294;
            for (_i294 = 0; _i294 < _size290; ++_i294)
            {
              xfer += this->group_by_list[_i294].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.group_by_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->having_expr.read(iprot);
          this->__isset.having_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->limit_expr.read(iprot);
          this->__isset.limit_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->offset_expr.read(iprot);
          this->__isset.offset_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->order_by_list.clear();
            uint32_t _size295;
            ::apache::thrift::protocol::TType _etype298;
            xfer += iprot->readListBegin(_etype298, _size295);
            this->order_by_list.resize(_size295);
            uint32_t _i299;
            for (_i299 = 0; _i299 < _size295; ++_i299)
            {
              xfer += this->order_by_list[_i299].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.order_by_list = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SelectRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SelectRequest");

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("select_list", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->select_list.size()));
    std::vector<ParsedExpr> ::const_iterator _iter300;
    for (_iter300 = this->select_list.begin(); _iter300 != this->select_list.end(); ++_iter300)
    {
      xfer += (*_iter300).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.search_expr) {
    xfer += oprot->writeFieldBegin("search_expr", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->search_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.where_expr) {
    xfer += oprot->writeFieldBegin("where_expr", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->where_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.group_by_list) {
    xfer += oprot->writeFieldBegin("group_by_list", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->group_by_list.size()));
      std::vector<ParsedExpr> ::const_iterator _iter301;
      for (_iter301 = this->group_by_list.begin(); _iter301 != this->group_by_list.end(); ++_iter301)
      {
        xfer += (*_iter301).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.having_expr) {
    xfer += oprot->writeFieldBegin("having_expr", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->having_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.limit_expr) {
    xfer += oprot->writeFieldBegin("limit_expr", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->limit_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset_expr) {
    xfer += oprot->writeFieldBegin("offset_expr", ::apache::thrift::protocol::T_STRUCT, 10);
    xfer += this->offset_expr.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.order_by_list) {
    xfer += oprot->writeFieldBegin("order_by_list", ::apache::thrift::protocol::T_LIST, 11);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->order_by_list.size()));
      std::vector<OrderByExpr> ::const_iterator _iter302;
      for (_iter302 = this->order_by_list.begin(); _iter302 != this->order_by_list.end(); ++_iter302)
      {
        xfer += (*_iter302).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SelectRequest &a, SelectRequest &b) {
  using ::std::swap;
  swap(a.session_id, b.session_id);
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.select_list, b.select_list);
  swap(a.search_expr, b.search_expr);
  swap(a.where_expr, b.where_expr);
  swap(a.group_by_list, b.group_by_list);
  swap(a.having_expr, b.having_expr);
  swap(a.limit_expr, b.limit_expr);
  swap(a.offset_expr, b.offset_expr);
  swap(a.order_by_list, b.order_by_list);
  swap(a.__isset, b.__isset);
}

SelectRequest::SelectRequest(const SelectRequest& other303) {
  session_id = other303.session_id;
  db_name = other303.db_name;
  table_name = other303.table_name;
  select_list = other303.select_list;
  search_expr = other303.search_expr;
  where_expr = other303.where_expr;
  group_by_list = other303.group_by_list;
  having_expr = other303.having_expr;
  limit_expr = other303.limit_expr;
  offset_expr = other303.offset_expr;
  order_by_list = other303.order_by_list;
  __isset = other303.__isset;
}
SelectRequest& SelectRequest::operator=(const SelectRequest& other304) {
  session_id = other304.session_id;
  db_name = other304.db_name;
  table_name = other304.table_name;
  select_list = other304.select_list;
  search_expr = other304.search_expr;
  where_expr = other304.where_expr;
  group_by_list = other304.group_by_list;
  having_expr = other304.having_expr;
  limit_expr = other304.limit_expr;
  offset_expr = other304.offset_expr;
  order_by_list = other304.order_by_list;
  __isset = other304.__isset;
  return *this;
}
void SelectRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SelectRequest(";
  out << "session_id=" << to_string(session_id);
  out << ", " << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "select_list=" << to_string(select_list);
  out << ", " << "search_expr="; (__isset.search_expr ? (out << to_string(search_expr)) : (out << "<null>"));
  out << ", " << "where_expr="; (__isset.where_expr ? (out << to_string(where_expr)) : (out << "<null>"));
  out << ", " << "group_by_list="; (__isset.group_by_list ? (out << to_string(group_by_list)) : (out << "<null>"));
  out << ", " << "having_expr="; (__isset.having_expr ? (out << to_string(having_expr)) : (out << "<null>"));
  out << ", " << "limit_expr="; (__isset.limit_expr ? (out << to_string(limit_expr)) : (out << "<null>"));
  out << ", " << "offset_expr="; (__isset.offset_expr ? (out << to_string(offset_expr)) : (out << "<null>"));
  out << ", " << "order_by_list="; (__isset.order_by_list ? (out << to_string(order_by_list)) : (out << "<null>"));
  out << ")";
}


SelectResponse::~SelectResponse() noexcept {
}


void SelectResponse::__set_success(const bool val) {
  this->success = val;
}

void SelectResponse::__set_error_msg(const std::string& val) {
  this->error_msg = val;
}

void SelectResponse::__set_column_defs(const std::vector<ColumnDef> & val) {
  this->column_defs = val;
}

void SelectResponse::__set_column_fields(const std::vector<ColumnField> & val) {
  this->column_fields = val;
}
std::ostream& operator<<(std::ostream& out, const SelectResponse& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SelectResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error_msg);
          this->__isset.error_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_defs.clear();
            uint32_t _size305;
            ::apache::thrift::protocol::TType _etype308;
            xfer += iprot->readListBegin(_etype308, _size305);
            this->column_defs.resize(_size305);
            uint32_t _i309;
            for (_i309 = 0; _i309 < _size305; ++_i309)
            {
              xfer += this->column_defs[_i309].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_defs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->column_fields.clear();
            uint32_t _size310;
            ::apache::thrift::protocol::TType _etype313;
            xfer += iprot->readListBegin(_etype313, _size310);
            this->column_fields.resize(_size310);
            uint32_t _i314;
            for (_i314 = 0; _i314 < _size310; ++_i314)
            {
              xfer += this->column_fields[_i314].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.column_fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SelectResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SelectResponse");

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_msg", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->error_msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_defs", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_defs.size()));
    std::vector<ColumnDef> ::const_iterator _iter315;
    for (_iter315 = this->column_defs.begin(); _iter315 != this->column_defs.end(); ++_iter315)
    {
      xfer += (*_iter315).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("column_fields", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->column_fields.size()));
    std::vector<ColumnField> ::const_iterator _iter316;
    for (_iter316 = this->column_fields.begin(); _iter316 != this->column_fields.end(); ++_iter316)
    {
      xfer += (*_iter316).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SelectResponse &a, SelectResponse &b) {
  using ::std::swap;
  swap(a.success, b.success);
  swap(a.error_msg, b.error_msg);
  swap(a.column_defs, b.column_defs);
  swap(a.column_fields, b.column_fields);
  swap(a.__isset, b.__isset);
}

SelectResponse::SelectResponse(const SelectResponse& other317) {
  success = other317.success;
  error_msg = other317.error_msg;
  column_defs = other317.column_defs;
  column_fields = other317.column_fields;
  __isset = other317.__isset;
}
SelectResponse& SelectResponse::operator=(const SelectResponse& other318) {
  success = other318.success;
  error_msg = other318.error_msg;
  column_defs = other318.column_defs;
  column_fields = other318.column_fields;
  __isset = other318.__isset;
  return *this;
}
void SelectResponse::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SelectResponse(";
  out << "success=" << to_string(success);
  out << ", " << "error_msg=" << to_string(error_msg);
  out << ", " << "column_defs=" << to_string(column_defs);
  out << ", " << "column_fields=" << to_string(column_fields);
  out << ")";
}


DeleteRequest::~DeleteRequest() noexcept {
}


void DeleteRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void DeleteRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void DeleteRequest::__set_where_expr(const ParsedExpr& val) {
  this->where_expr = val;
}

void DeleteRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const DeleteRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DeleteRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->where_expr.read(iprot);
          this->__isset.where_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DeleteRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DeleteRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("where_expr", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->where_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DeleteRequest &a, DeleteRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.where_expr, b.where_expr);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

DeleteRequest::DeleteRequest(const DeleteRequest& other319) {
  db_name = other319.db_name;
  table_name = other319.table_name;
  where_expr = other319.where_expr;
  session_id = other319.session_id;
  __isset = other319.__isset;
}
DeleteRequest& DeleteRequest::operator=(const DeleteRequest& other320) {
  db_name = other320.db_name;
  table_name = other320.table_name;
  where_expr = other320.where_expr;
  session_id = other320.session_id;
  __isset = other320.__isset;
  return *this;
}
void DeleteRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DeleteRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "where_expr=" << to_string(where_expr);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}


UpdateRequest::~UpdateRequest() noexcept {
}


void UpdateRequest::__set_db_name(const std::string& val) {
  this->db_name = val;
}

void UpdateRequest::__set_table_name(const std::string& val) {
  this->table_name = val;
}

void UpdateRequest::__set_where_expr(const ParsedExpr& val) {
  this->where_expr = val;
}

void UpdateRequest::__set_update_expr_array(const std::vector<UpdateExpr> & val) {
  this->update_expr_array = val;
}

void UpdateRequest::__set_session_id(const int64_t val) {
  this->session_id = val;
}
std::ostream& operator<<(std::ostream& out, const UpdateRequest& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UpdateRequest::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->db_name);
          this->__isset.db_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->table_name);
          this->__isset.table_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->where_expr.read(iprot);
          this->__isset.where_expr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->update_expr_array.clear();
            uint32_t _size321;
            ::apache::thrift::protocol::TType _etype324;
            xfer += iprot->readListBegin(_etype324, _size321);
            this->update_expr_array.resize(_size321);
            uint32_t _i325;
            for (_i325 = 0; _i325 < _size321; ++_i325)
            {
              xfer += this->update_expr_array[_i325].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.update_expr_array = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->session_id);
          this->__isset.session_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UpdateRequest::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UpdateRequest");

  xfer += oprot->writeFieldBegin("db_name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->db_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("table_name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->table_name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("where_expr", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->where_expr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("update_expr_array", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->update_expr_array.size()));
    std::vector<UpdateExpr> ::const_iterator _iter326;
    for (_iter326 = this->update_expr_array.begin(); _iter326 != this->update_expr_array.end(); ++_iter326)
    {
      xfer += (*_iter326).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session_id", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->session_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UpdateRequest &a, UpdateRequest &b) {
  using ::std::swap;
  swap(a.db_name, b.db_name);
  swap(a.table_name, b.table_name);
  swap(a.where_expr, b.where_expr);
  swap(a.update_expr_array, b.update_expr_array);
  swap(a.session_id, b.session_id);
  swap(a.__isset, b.__isset);
}

UpdateRequest::UpdateRequest(const UpdateRequest& other327) {
  db_name = other327.db_name;
  table_name = other327.table_name;
  where_expr = other327.where_expr;
  update_expr_array = other327.update_expr_array;
  session_id = other327.session_id;
  __isset = other327.__isset;
}
UpdateRequest& UpdateRequest::operator=(const UpdateRequest& other328) {
  db_name = other328.db_name;
  table_name = other328.table_name;
  where_expr = other328.where_expr;
  update_expr_array = other328.update_expr_array;
  session_id = other328.session_id;
  __isset = other328.__isset;
  return *this;
}
void UpdateRequest::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UpdateRequest(";
  out << "db_name=" << to_string(db_name);
  out << ", " << "table_name=" << to_string(table_name);
  out << ", " << "where_expr=" << to_string(where_expr);
  out << ", " << "update_expr_array=" << to_string(update_expr_array);
  out << ", " << "session_id=" << to_string(session_id);
  out << ")";
}

} // namespace
